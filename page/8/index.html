<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/M_32px.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/M_16px.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":7,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="半吊子民工 英特纳雄耐尔就一定要实现">
<meta property="og:type" content="website">
<meta property="og:title" content="Mark blog">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="Mark blog">
<meta property="og:description" content="半吊子民工 英特纳雄耐尔就一定要实现">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Mark">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Mark blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Mark blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">知行合一 划水归档</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/Linux-Shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6-%E4%B8%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mark_avatar.png">
      <meta itemprop="name" content="Mark">
      <meta itemprop="description" content="半吊子民工 英特纳雄耐尔就一定要实现">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mark blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Linux-Shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6-%E4%B8%89/" class="post-title-link" itemprop="url">Linux Shell 脚本编程进阶(三)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-08-26 13:53:48" itemprop="dateCreated datePublished" datetime="2015-08-26T13:53:48+08:00">2015-08-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-02 23:33:28" itemprop="dateModified" datetime="2019-01-02T23:33:28+08:00">2019-01-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%B5%B7%E6%8B%BE%E8%B4%9D/" itemprop="url" rel="index"><span itemprop="name">学海拾贝</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="信号捕捉trap"><a href="#信号捕捉trap" class="headerlink" title="信号捕捉trap"></a>信号捕捉trap</h3><p>trap ‘触发指令’ 信号<br>​    自定义进程收到系统发出的指定信号后,将执行触发指令,而不会执行原操作<br>trap ‘’ 信号<br>​    忽略信号的操作<br>trap ‘-‘ 信号<br>​    恢复原信号的操作<br>trap -p<br>​    列出自定义信号操作</p>
<p>trap例程:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"> trap 'echo “signal:SIGINT"' int</span><br><span class="line"> trap -p</span><br><span class="line"> for((i=0;i&lt;=10;i++))</span><br><span class="line"> do</span><br><span class="line"> 	sleep 1</span><br><span class="line">	echo $i</span><br><span class="line"> done</span><br><span class="line"> trap '' int</span><br><span class="line"> trap -p</span><br><span class="line"> for((i=11;i&lt;=20;i++))</span><br><span class="line"> do</span><br><span class="line"> 	sleep 1</span><br><span class="line"> 	echo $i</span><br><span class="line"> done</span><br><span class="line"> trap '-' int</span><br><span class="line"> trap -p</span><br><span class="line"> for((i=21;i&lt;=30;i++))</span><br><span class="line"> do</span><br><span class="line"> 	sleep 1</span><br><span class="line"> 	echo $i</span><br><span class="line"> done</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>变量:存储单个元素的内存空间<br>数组:存储多个元素的连续的内存空间,相当于多个变量的集合<br>数组名和索引<br>​    索引:编号从0开始,属于数值索引<br>​    注意:索引可支持使用自定义的格式,而不仅是数值格式,即为关联索引,bash4.0版本之后开始支持<br>​    bash的数组支持稀疏格式（索引不连续）<br>声明数组:<br>​    declare -a ARRAY_NAME<br>​    declare -A ARRAY_NAME: 关联数组<br>​    注意:两者不可相互转换</p>
<h4 id="数组赋值"><a href="#数组赋值" class="headerlink" title="数组赋值"></a>数组赋值</h4><p>数组元素的赋值<br>​    (1) 一次只赋值一个元素<br>​    ARRAY_NAME[INDEX]=VALUE<br>​    weekdays[0]=”Sunday”<br>​    weekdays[4]=”Thursday”<br>​    (2) 一次赋值全部元素<br>​    ARRAY_NAME=(“VAL1” “VAL2” “VAL3” …)<br>​    (3) 只赋值特定元素<br>​    ARRAY_NAME=([0]=”VAL1” [3]=”VAL2” …)<br>​    (4) 交互式数组值对赋值<br>​    read -a ARRAY<br>显示所有数组:declare -a </p>
<h4 id="引用数组"><a href="#引用数组" class="headerlink" title="引用数组"></a>引用数组</h4><p>引用数组元素:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`$&#123;ARRAY_NAME[INDEX]&#125;`</span><br><span class="line"></span><br><span class="line">注意:省略[INDEX]表示引用下标为0的元素</span><br></pre></td></tr></table></figure>

<p>引用数组所有元素:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`$&#123;ARRAY_NAME[\*]&#125;`</span><br><span class="line"></span><br><span class="line">`$&#123;ARRAY_NAME[@]&#125;`</span><br></pre></td></tr></table></figure>

<p>数组的长度(数组中元素的个数):</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`$&#123;#ARRAY_NAME[\*]&#125;`</span><br><span class="line"></span><br><span class="line">`$&#123;#ARRAY_NAME[@]&#125;`</span><br></pre></td></tr></table></figure>

<p>删除数组中的某元素:导致稀疏格式</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`unset ARRAY[INDEX]`</span><br></pre></td></tr></table></figure>

<p>删除整个数组:<br>​    <code>unset ARRAY</code></p>
<h4 id="数组数据处理"><a href="#数组数据处理" class="headerlink" title="数组数据处理"></a>数组数据处理</h4><p>引用数组中的元素:<br>​    数组切片:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">`$&#123;ARRAY[@]:offset:number&#125;`</span><br><span class="line"></span><br><span class="line">	offset: 要跳过的元素个数</span><br><span class="line"></span><br><span class="line">	number: 要取出的元素个数</span><br><span class="line"></span><br><span class="line">	取偏移量之后的所有元素</span><br><span class="line"></span><br><span class="line">`$&#123;ARRAY[@]:offset&#125;`</span><br></pre></td></tr></table></figure>

<p>向数组中追加元素:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`ARRAY[$&#123;#ARRAY[*]&#125;]=value`</span><br></pre></td></tr></table></figure>

<p>关联数组:<br>​    <code>declare -A ARRAY_NAME</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`ARRAY_NAME=([idx_name1]='val1' [idx_name2]='val2‘...)`</span><br><span class="line"></span><br><span class="line">注意:关联数组必须先声明再调用</span><br></pre></td></tr></table></figure>

<p>数组例程:</p>
<p>生成10个随机数保存于数组中,并找出其最大值和最小值</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">declare -i min max</span><br><span class="line">declare -a nums</span><br><span class="line">for ((i=0;i&lt;10;i++));do</span><br><span class="line"><span class="meta">	nums[$</span><span class="bash">i]=<span class="variable">$RANDOM</span></span></span><br><span class="line">	[ $i -eq 0 ] &amp;&amp; min=$&#123;nums[$i]&#125; &amp;&amp; max=$&#123;nums[$i]&#125;&amp;&amp; continue</span><br><span class="line">	[ $&#123;nums[$i]&#125; -gt $max ] &amp;&amp; max=$&#123;nums[$i]&#125;</span><br><span class="line">	[ $&#123;nums[$i]&#125; -lt $min ] &amp;&amp; min=$&#123;nums[$i]&#125;</span><br><span class="line">done</span><br><span class="line">echo “All numbers are $&#123;nums[*]&#125;”</span><br><span class="line">echo Max is $max</span><br><span class="line">echo Min is $min</span><br></pre></td></tr></table></figure>

<p>编写脚本,定义一个数组,数组中的元素是/var/log目录下所有以.log结尾的文件;统计出其下标为偶数的文件中的行数之和</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">declare -a files</span><br><span class="line">files=(/var/log/*.log)</span><br><span class="line">declare -i lines=0</span><br><span class="line">for i in $(seq 0 $[$&#123;#files[*]&#125;-1]); do</span><br><span class="line">	if [ $[$i%2] -eq 0 ];then</span><br><span class="line">		let lines+=$(wc -l $&#123;files[$i]&#125; | cut -d' ' -f1)</span><br><span class="line">	fi</span><br><span class="line">done</span><br><span class="line">echo "Lines: $lines."</span><br></pre></td></tr></table></figure>



<h3 id="shell中的字符串"><a href="#shell中的字符串" class="headerlink" title="shell中的字符串"></a>shell中的字符串</h3><h4 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;<span class="comment">#var&#125;:返回字符串变量var的长度</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;var:offset&#125;:返回字符串变量var中从第offset个字符后（不包括第offset个字符）的字</span></span><br><span class="line">符开始，到最后的部分，offset的取值在0 到 $&#123;#var&#125;-1 之间(bash4.2后，允许为负值)</span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;var:offset:number&#125;：返回字符串变量var中从第offset个字符后（不包括第offset个</span></span><br><span class="line">字符）的字符开始，长度为number的部分</span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;var: -length&#125;：取字符串的最右侧几个字符</span></span><br><span class="line">注意：冒号后必须有一空白字符</span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;var:offset:-length&#125;：从最左侧跳过offset字符，一直向右取到距离最右侧lengh个字</span></span><br><span class="line">符之前的内容</span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;var: -length:-offset&#125;：先从最右侧向左取到length个字符开始，再向右取到距离最</span></span><br><span class="line">右侧offset个字符之间的内容</span><br><span class="line">注意：-length前空格</span><br></pre></td></tr></table></figure>

<h4 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h4><p><strong>基于模式取子串</strong><br>​    ${var#*word}:其中word可以是指定的任意字符</p>
<p>功能:自左而右,查找var变量所存储的字符串中,第一次出现的word, 删除字符串开头至第一次出现word字符之间的所有字符</p>
<p>${var##*word}:同上,贪婪模式,不同的是,删除的是字符串开头至最后一次由word指定的字符之间的所有内容    </p>
<p>示例:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file=“var/log/messages”</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;file<span class="comment">#*/&#125;: log/messages</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;file<span class="comment">##*/&#125;: messages</span></span></span><br></pre></td></tr></table></figure>

<p><code>${var%word\*}</code>:其中word可以是指定的任意字符<br>​    功能:自右而左,查找var变量所存储的字符串中,第一次出现的word, 删除字符串最后一个字符向左至第一次出现word字符之间的所有字符<br>​    <code>file=&quot;/var/log/messages&quot;</code><br>​    <code>${file%/\*}: /var/log</code><br><code>${var%%word\*}</code>:同上,只不过删除字符串最右侧的字符向左至最后一次出现word字符之间的所有字符;<br>示例:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url=http://www.google.com:80</span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;url<span class="comment">##*:&#125; 80</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;url%%:*&#125; http</span></span><br></pre></td></tr></table></figure>



<p><strong>查找替换</strong><br>​    ${var/pattern/substr}:查找var所表示的字符串中,第一次被pattern所匹配到的字符串,以substr替换之<br>​    ${var//pattern/substr}: 查找var所表示的字符串中,所有能被pattern所匹配到的字符串,以substr替换之<br>​    ${var/#pattern/substr}:查找var所表示的字符串中,行首被pattern所匹配到的字符串,以substr替换之<br>​    ${var/%pattern/substr}:查找var所表示的字符串中,行尾被pattern所匹配到的字符串,以substr替换之</p>
<p><strong>查找并删除</strong><br>​    ${var/pattern}:删除var表示的字符串中第一次被pattern匹配到的字符串<br>​    ${var//pattern}:删除var表示的字符串中所有被pattern匹配到的字符串<br>​    ${var/#pattern}:删除var表示的字符串中所有以pattern为行首匹配到的字符串<br>​    ${var/%pattern}:删除var所表示的字符串中所有以pattern为行尾所匹配到的字符串</p>
<p><strong>字符大小写转换</strong><br>​    ${var^^}:把var中的所有小写字母转换为大写<br>​    ${var,,}:把var中的所有大写字母转换为小写</p>
<p><strong>变量赋值</strong></p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_shell_learning_01.png" alt=""></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6-%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mark_avatar.png">
      <meta itemprop="name" content="Mark">
      <meta itemprop="description" content="半吊子民工 英特纳雄耐尔就一定要实现">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mark blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6-%E4%BA%8C/" class="post-title-link" itemprop="url">Linux shell 脚本编程进阶(二)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-08-23 21:30:35" itemprop="dateCreated datePublished" datetime="2015-08-23T21:30:35+08:00">2015-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-02 23:33:11" itemprop="dateModified" datetime="2019-01-02T23:33:11+08:00">2019-01-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%B5%B7%E6%8B%BE%E8%B4%9D/" itemprop="url" rel="index"><span itemprop="name">学海拾贝</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="shell中的函数"><a href="#shell中的函数" class="headerlink" title="shell中的函数"></a>shell中的函数</h3><p>函数function是由若干条shell命令组成的语句块,实现代码重用和模块化编程<br>它与shell程序形式上是相似的,不同的是它不是一个单独的进程,不能独立运行,而是shell程序的一部分<br> 函数和shell程序比较相似,区别在于:<br>​    <strong>Shell程序在子Shell中运行</strong><br>​    <strong>而Shell函数在当前Shell中运行.因此在当前Shell中,函数可以对shell中变量进行修改</strong></p>
<h4 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h4><p> 函数由两部分组成:函数名和函数体<br><code>help function</code><br> 语法一:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f_name （）&#123;</span><br><span class="line">	...函数体...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 语法二:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function f_name &#123;</span><br><span class="line">	...函数体...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 语法三:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function f_name （） &#123;</span><br><span class="line">	...函数体...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="函数使用"><a href="#函数使用" class="headerlink" title="函数使用"></a>函数使用</h4><p>函数的定义和使用:<br>​    可在交互式环境下定义函数<br>​    可将函数放在脚本文件中作为它的一部分<br>​    可放在只包含函数的单独文件中<br>调用:函数只有被调用才会执行<br>​    调用:给定函数名<br>​    函数名出现的地方,会被自动替换为函数代码<br>函数的生命周期:被调用时创建,返回时终止</p>
<h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><p>函数有两种返回值:<br>函数的执行结果返回值:<br>​    (1) 使用echo等命令进行输出<br>​    (2) 函数体中调用命令的输出结果<br>函数的退出状态码:<br>​    (1) 默认取决于函数中执行的最后一条命令的退出状态码<br>​    (2) 自定义退出状态码,其格式为:<br>​    return 从函数中返回,用最后状态命令决定返回值<br>​    return 0 无错误返回.<br>​    return 1-255 有错误返回</p>
<h4 id="交互式环境下定义和使用函数"><a href="#交互式环境下定义和使用函数" class="headerlink" title="交互式环境下定义和使用函数"></a>交互式环境下定义和使用函数</h4><p>示例:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dir() &#123;</span><br><span class="line"><span class="meta"> &gt;</span><span class="bash"> ls -l</span></span><br><span class="line"><span class="meta"> &gt;</span><span class="bash"> &#125;</span></span><br></pre></td></tr></table></figure>

<p>定义该函数后,若在$后面键入dir,其显示结果同ls -l的作用相同<br><code>$ dir</code></p>
<p>该dir函数将一直保留到用户从系统退出,或执行了如下所示的unset命令<br><code>unset dir</code></p>
<h4 id="在脚本中定义及使用函数"><a href="#在脚本中定义及使用函数" class="headerlink" title="在脚本中定义及使用函数"></a>在脚本中定义及使用函数</h4><p>函数在使用前必须定义,因此应将函数定义放在脚本开始部分,直至shell首次发现它<br>后才能使用<br>调用函数仅使用其函数名即可<br>示例:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat func1</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> func1</span></span><br><span class="line">hello()</span><br><span class="line">&#123;</span><br><span class="line">	echo "Hello there today's date is `date +%F`"</span><br><span class="line">&#125;</span><br><span class="line">echo "now going to the function hello"</span><br><span class="line">hello</span><br><span class="line">echo “back from the function”</span><br></pre></td></tr></table></figure>



<h4 id="使用函数文件"><a href="#使用函数文件" class="headerlink" title="使用函数文件"></a>使用函数文件</h4><p>可以将经常使用的函数存入函数文件,然后将函数文件载入shell<br>文件名可任意选取,但最好与相关任务有某种联系.例如:functions.main<br>一旦函数文件载入shell,就可以在命令行或脚本中调用函数.可以使用set命<br>令查看所有定义的函数,其输出列表包括已经载入shell的所有函数<br>若要改动函数,首先用unset命令从shell中删除函数.改动完毕后,再重新载<br>入此文件</p>
<h4 id="创建函数文件"><a href="#创建函数文件" class="headerlink" title="创建函数文件"></a>创建函数文件</h4><p>函数文件示例:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat functions.main</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">functions.main</span></span><br><span class="line">findit()</span><br><span class="line">&#123;</span><br><span class="line"> 	if [ $# -lt 1 ] ; then</span><br><span class="line"> 		echo "Usage:findit file"</span><br><span class="line"> 		return 1</span><br><span class="line"> 	fi</span><br><span class="line"> 	find / -name $1 –print</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="载入函数"><a href="#载入函数" class="headerlink" title="载入函数"></a>载入函数</h4><p>函数文件已创建好后,要将它载入shell<br>定位函数文件并载入shell的格式<br>​    <code>. filename</code> 或 <code>source filename</code><br>注意:此即&lt;点&gt; &lt;空格&gt; &lt;文件名&gt;这里的文件名要带正确路径<br>示例:<br>​    上例中的函数,可使用如下命令:<br>​    <code>. functions.main</code>    </p>
<h4 id="检查载入函数"><a href="#检查载入函数" class="headerlink" title="检查载入函数"></a>检查载入函数</h4><p>使用set命令检查函数是否已载入.set命令将在shell中显示所有的载入函数<br>示例:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">set</span><br><span class="line"> findit=( )</span><br><span class="line"> &#123;</span><br><span class="line"> 	if [ $# -lt 1 ]; then</span><br><span class="line"> 	echo "usage :findit file";</span><br><span class="line"> 	return 1</span><br><span class="line"> 	fi</span><br><span class="line"> 	find / -name $1 -print</span><br><span class="line"> &#125;</span><br><span class="line"> …</span><br></pre></td></tr></table></figure>



<h4 id="执行shell函数"><a href="#执行shell函数" class="headerlink" title="执行shell函数"></a>执行shell函数</h4><p>要执行函数,简单地键入函数名即可<br>示例:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">findit groups</span><br><span class="line">/usr/bin/groups</span><br><span class="line">/usr/local/backups/groups.bak</span><br></pre></td></tr></table></figure>



<h4 id="删除shell函数"><a href="#删除shell函数" class="headerlink" title="删除shell函数"></a>删除shell函数</h4><p>现在对函数做一些改动后,需要先删除函数,使其对shell不可用.使用unset命<br>令完成删除函数<br>命令格式为:<br>​    <code>unset function_name</code><br>示例:<br>​    <code>unset findit</code><br>​    再键入set命令,函数将不再显示<br>环境函数<br>使子进程也可使用<br>声明:export -f function_name<br>查看:export -f 或 declare -xf</p>
<h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><p>函数可以接受参数:<br>​    传递参数给函数:调用函数时,在函数名后面以空白分隔给定参数列表即可;例如“testfunc arg1 arg2 …”<br>​    在函数体中当中,可使用$1, $2, …调用这些参数;还可以使用$@, $*, $#等特殊变量</p>
<h4 id="函数变量"><a href="#函数变量" class="headerlink" title="函数变量"></a>函数变量</h4><p>变量作用域:<br>​    环境变量:当前shell和子shell有效<br>​    本地变量:只在当前shell进程有效,为执行脚本会启动专用子shell进程;因此,本地变量的作用范围是当前shell脚本程序文件,包括脚本中的函数<br>​    局部变量:函数的生命周期;函数结束时变量被自动销毁<br>注意:如果函数中有局部变量,如果其名称同本地变量,使用局部变量<br>在函数中定义局部变量的方法<br>​    <code>local NAME=VALUE</code></p>
<h4 id="函数递归示例"><a href="#函数递归示例" class="headerlink" title="函数递归示例"></a>函数递归示例</h4><p>函数递归:<br>​    函数直接或间接调用自身<br>​    注意递归层数<br>递归实例:<br>阶乘是基斯顿·卡曼于 1808 年发明的运算符号,是数学术语<br>一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积,并且有0的阶乘为1,自然数n的阶乘写作n!<br>​    n!=1×2×3×…×n<br>​    阶乘亦可以递归方式定义:0!=1,n!=(n-1)!×n<br>​    n!=n(n-1)(n-2)…1<br>​    n(n-1)! = n(n-1)(n-2)!</p>
<p>例程:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">fact() &#123;</span><br><span class="line">	if [ $1 -eq 0 -o $1 -eq 1 ]; then</span><br><span class="line">		echo 1</span><br><span class="line">	else</span><br><span class="line">		echo $[$1*$(fact $[$1-1])]</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line">fact $1</span><br></pre></td></tr></table></figure>



<h4 id="fork炸弹"><a href="#fork炸弹" class="headerlink" title="fork炸弹"></a>fork炸弹</h4><p>fork炸弹是一种恶意程序,它的内部是一个不断在fork进程的无限循环,实质是一个简单的递归程序.由于程序是递归的,如果没有任何限制,这会导致这个简单的程序迅速耗尽系统里面的所有资源<br>函数实现<br><code>:(){ :|:&amp; };:</code></p>
<p><code>bomb() { bomb | bomb &amp; }; bomb</code></p>
<p>脚本实现</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat Bomb.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">./$0|./$0&amp;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6-%E4%B8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mark_avatar.png">
      <meta itemprop="name" content="Mark">
      <meta itemprop="description" content="半吊子民工 英特纳雄耐尔就一定要实现">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mark blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6-%E4%B8%80/" class="post-title-link" itemprop="url">Linux shell 脚本编程进阶(一)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-08-20 21:30:29" itemprop="dateCreated datePublished" datetime="2015-08-20T21:30:29+08:00">2015-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-02 23:32:55" itemprop="dateModified" datetime="2019-01-02T23:32:55+08:00">2019-01-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%B5%B7%E6%8B%BE%E8%B4%9D/" itemprop="url" rel="index"><span itemprop="name">学海拾贝</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Shell 脚本也是学习Linux中必须要掌握的基础之一,掌握了 Shell 脚本之后可以轻松控制自动化及重复的任务,大大减少重复的劳动.</p>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>过程式编程语言: </p>
<pre><code>顺序执行 </code></pre><p>​    选择执行 </p>
<pre><code>循环执行 </code></pre><h4 id="条件选择-if-语句"><a href="#条件选择-if-语句" class="headerlink" title="条件选择 if 语句"></a>条件选择 if 语句</h4><p>选择执行: </p>
<p>注意:if语句可嵌套 </p>
<p>单分支 </p>
<pre><code>if 判断条件;then 

    条件为真的分支代码 

fi </code></pre><p>双分支 </p>
<pre><code>if 判断条件; then 

    条件为真的分支代码 

else 

    条件为假的分支代码 

fi </code></pre><h5 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h5><p>多分支 </p>
<pre><code>if 判断条件1; then 

    条件1为真的分支代码 

elif 判断条件2; then 

    条件2为真的分支代码 </code></pre><p>​    elif 判断条件3; then </p>
<pre><code>    条件3为真的分支代码 

else 

    以上条件都为假的分支代码 

fi </code></pre><p>逐条件进行判断,第一次遇为“真”条件时,执行其分支,而后结束整个if语句 </p>
<h5 id="if示例"><a href="#if示例" class="headerlink" title="if示例"></a>if示例</h5><p>根据命令的退出状态来执行命令 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if ping -c1 -W2 station1 &amp;&gt; /dev/null; then </span><br><span class="line"></span><br><span class="line">	echo 'Station1 is UP' </span><br><span class="line"></span><br><span class="line">elif grep "station1" ~/maintenance.txt &amp;&gt; /dev/null; then </span><br><span class="line"></span><br><span class="line">	echo 'Station1 is undergoing maintenance‘ </span><br><span class="line"></span><br><span class="line">else </span><br><span class="line"></span><br><span class="line">	echo 'Station1 is unexpectedly DOWN!' </span><br><span class="line"></span><br><span class="line">	exit 1 </span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h4 id="条件判断-case-语句"><a href="#条件判断-case-语句" class="headerlink" title="条件判断 case 语句"></a>条件判断 case 语句</h4><p>case 变量引用 in </p>
<p>PAT1) </p>
<pre><code>分支1 

;; </code></pre><p>PAT2) </p>
<pre><code>分支2 

;; </code></pre><p>… </p>
<p>*) </p>
<pre><code>默认分支 

;; </code></pre><p>esac </p>
<p>case支持glob风格的通配符: </p>
<pre><code>*: 任意长度任意字符 </code></pre><p>​    ?: 任意单个字符 </p>
<pre><code>[]:指定范围内的任意单个字符 

a|b: a或b </code></pre><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>循环执行 </p>
<pre><code>将某代码段重复运行多次 

重复运行多少次 

    循环次数事先已知 

    循环次数事先未知 

有进入条件和退出条件 </code></pre><p>for, while, until </p>
<h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><p>for 变量名 in 列表;do </p>
<pre><code>循环体 </code></pre><p>done </p>
<p>执行机制: </p>
<pre><code>依次将列表中的元素赋值给“变量名”; 每次赋值后即执行一次循环体; 直 到列表中的元素耗尽,循环结束 </code></pre><p>列表生成方式: </p>
<pre><code>(1) 直接给出列表 

(2) 整数列表: 

    (a) {start..end} 

    (b) $(seq [start [step]] end) 

(3) 返回列表的命令 

    $(COMMAND) 

(4) 使用glob,如:*.sh</code></pre><p>​    (5) 变量引用; </p>
<p>​        $@, $* </p>
<h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><p>while CONDITION; do<br>​    循环体<br>done<br>CONDITION:循环控制条件;进入循环之前,先做一次判断;每一次循环之后会再次做判断;条件为“true”,则执行一次循环;直到条件测试状态为“false”终止循环<br>因此:CONDTION一般应该有循环控制变量;而此变量的值会在循环体不断地被修正<br>进入条件:CONDITION为true<br>退出条件:CONDITION为false</p>
<h5 id="until循环"><a href="#until循环" class="headerlink" title="until循环"></a>until循环</h5><p>until CONDITION; do<br>​    循环体<br>done<br>进入条件: CONDITION 为false<br>退出条件: CONDITION 为true</p>
<h5 id="循环控制语句continue"><a href="#循环控制语句continue" class="headerlink" title="循环控制语句continue"></a>循环控制语句continue</h5><p>用于循环体中<br>continue [N]:提前结束第N层的本轮循环,而直接进入下一轮判断;最内层为第1层</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while CONDTIITON1; do</span><br><span class="line">	CMD1</span><br><span class="line">	...</span><br><span class="line">	if CONDITION2; then</span><br><span class="line">		continue</span><br><span class="line">	fi</span><br><span class="line">	CMDn</span><br><span class="line">	...</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<h5 id="循环控制语句break"><a href="#循环控制语句break" class="headerlink" title="循环控制语句break"></a>循环控制语句break</h5><p>用于循环体中<br>break [N]:提前结束第N层循环,最内层为第1层</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while CONDTIITON1; do</span><br><span class="line">	CMD1</span><br><span class="line">	...</span><br><span class="line">	if CONDITION2; then</span><br><span class="line">		break</span><br><span class="line">	fi</span><br><span class="line">	CMDn</span><br><span class="line">	...</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<h5 id="循环控制shift命令"><a href="#循环控制shift命令" class="headerlink" title="循环控制shift命令"></a>循环控制shift命令</h5><p>shift [n]<br>用于将参量列表 list 左移指定次数,缺省为左移一次.<br>参量列表 list 一旦被移动,最左端的那个参数就从列表中删除.while 循环遍<br>历位置参量列表时,常用到 shift<br><code>./doit.sh a b c d e f g h</code></p>
<p><code>./shfit.sh a b c d e f g h</code></p>
<h5 id="命令示例"><a href="#命令示例" class="headerlink" title="命令示例"></a>命令示例</h5><p><strong>doit.sh</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Name: doit.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Purpose: <span class="built_in">shift</span> through <span class="built_in">command</span> line arguments</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Usage: doit.sh [args]</span></span><br><span class="line">while [ $# -gt 0 ] # or (( $# &gt; 0 ))</span><br><span class="line">do</span><br><span class="line">	echo $*</span><br><span class="line">	shift</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p><strong>shift.sh</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">step through all the positional parameters</span></span><br><span class="line">until [ -z "$1" ]</span><br><span class="line">do</span><br><span class="line"> 	echo "$1"</span><br><span class="line"> 	shift</span><br><span class="line">done</span><br><span class="line">echo</span><br></pre></td></tr></table></figure>

<h5 id="创建无限循环"><a href="#创建无限循环" class="headerlink" title="创建无限循环"></a>创建无限循环</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while true; do</span><br><span class="line">	循环体</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">until false; do</span><br><span class="line">	循环体</span><br><span class="line">Done</span><br></pre></td></tr></table></figure>



<h5 id="循环的特殊用法"><a href="#循环的特殊用法" class="headerlink" title="循环的特殊用法"></a>循环的特殊用法</h5><p>while循环的特殊用法（遍历文件的每一行）:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while read line; do</span><br><span class="line">	循环体</span><br><span class="line">done &lt; /PATH/FROM/SOMEFILE</span><br></pre></td></tr></table></figure>


<p>依次读取/PATH/FROM/SOMEFILE文件中的每一行,且将行赋值给变量line</p>
<p><strong>双小括号方法</strong>,即<code>((…))</code>格式,也可以用于算术运算<br>双小括号方法也可以使bash Shell实现C语言风格的变量操作<br>​    <code>I=10</code><br>​    <code>((I++))</code></p>
<p><strong>for循环的特殊格式:</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for ((控制变量初始化;条件判断表达式;控制变量的修正表达式))</span><br><span class="line">do	</span><br><span class="line">	循环体</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>控制变量初始化:仅在运行到循环代码段时执行一次<br>控制变量的修正表达式:每轮循环结束会先进行控制变量修正运算,而后再做条件判断</p>
<h5 id="select循环与菜单"><a href="#select循环与菜单" class="headerlink" title="select循环与菜单"></a>select循环与菜单</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select variable in list</span><br><span class="line">	do</span><br><span class="line">		循环体命令</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>

<p>select 循环主要用于创建菜单,按数字顺序排列的菜单项将显示在<br>标准错误上,并显示 PS3 提示符,等待用户输入<br> 用户输入菜单列表中的某个数字,执行相应的命令<br> 用户输入被保存在内置变量 REPLY 中</p>
<h5 id="select与case"><a href="#select与case" class="headerlink" title="select与case"></a>select与case</h5><p>select 是个无限循环,因此要记住用 break 命令退出循环,或用<br>exit 命令终止脚本.也可以按 ctrl+c 退出循环<br>select 经常和 case 联合使用<br>与 for 循环类似,可以省略 in list,此时使用位置参量</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/Linux-shell%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mark_avatar.png">
      <meta itemprop="name" content="Mark">
      <meta itemprop="description" content="半吊子民工 英特纳雄耐尔就一定要实现">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mark blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Linux-shell%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/" class="post-title-link" itemprop="url">Linux shell基础部分</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-08-19 20:41:26" itemprop="dateCreated datePublished" datetime="2015-08-19T20:41:26+08:00">2015-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-02 23:38:13" itemprop="dateModified" datetime="2019-01-02T23:38:13+08:00">2019-01-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%B5%B7%E6%8B%BE%E8%B4%9D/" itemprop="url" rel="index"><span itemprop="name">学海拾贝</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="编程基础"><a href="#编程基础" class="headerlink" title="编程基础"></a>编程基础</h4><p>程序:指令+数据 </p>
<p>程序编程风格: </p>
<p>​    过程式:以指令为中心,数据服务于指令 </p>
<p>​    对象式:以数据为中心,指令服务于数据 </p>
<p>shell程序:提供了编程能力,解释执行 </p>
<h4 id="程序的执行方式"><a href="#程序的执行方式" class="headerlink" title="程序的执行方式"></a>程序的执行方式</h4><p>编程逻辑处理方式: </p>
<p>​    顺序执行 </p>
<p>​    循环执行 </p>
<p>​    选择执行 </p>
<p>shell编程:过程式、解释执行 </p>
<p>​    编程语言的基本结构: </p>
<p>​        各种系统命令的组合 </p>
<p>​        数据存储:变量、数组 </p>
<p>​        表达式: a + b </p>
<p>​        语句:if  </p>
<h4 id="shell脚本基础"><a href="#shell脚本基础" class="headerlink" title="shell脚本基础"></a>shell脚本基础</h4><p>shell脚本: </p>
<p>​    包含一些命令或声明,并符合一定格式的文本文件 </p>
<p>格式要求:首行shebang机制 </p>
<p>​    #!/bin/bash </p>
<p>​    #!/usr/bin/python </p>
<p>​    #!/usr/bin/perl </p>
<p>shell脚本的用途有: </p>
<p>​     自动化常用命令 </p>
<p>​     执行系统管理和故障排除 </p>
<p>​     创建简单的应用程序 </p>
<p>​     处理文本或文件 </p>
<h4 id="创建shell脚本"><a href="#创建shell脚本" class="headerlink" title="创建shell脚本"></a>创建shell脚本</h4><p>第一步:使用文本编辑器来创建文本文件 </p>
<p>​    第一行必须包括shell声明序列:#! </p>
<p>​        #!/bin/bash </p>
<p>​    添加注释 </p>
<p>​        注释以#开头 </p>
<p>​    第二步:运行脚本 </p>
<p>​        给予执行权限,在命令行上指定脚本的绝对或相对路径 </p>
<p>​        直接运行解释器,将脚本作为解释器程序的参数运行 </p>
<h4 id="脚本规范"><a href="#脚本规范" class="headerlink" title="脚本规范"></a>脚本规范</h4><p>脚本代码开头约定 </p>
<p>​    1、第一行一般为调用使用的语言 </p>
<p>​    2、程序名,避免更改文件名为无法找到正确的文件 </p>
<p>​    3、版本号 </p>
<p>​    4、更改后的时间 </p>
<p>​    5、作者相关信息 </p>
<p>​    6、该程序的作用,及注意事项 </p>
<p>​    7、最后是各版本的更新简要说明</p>
<h4 id="脚本的基本结构"><a href="#脚本的基本结构" class="headerlink" title="脚本的基本结构"></a>脚本的基本结构</h4><p> #!SHEBANG </p>
<p>CONFIGURATION_VARIABLES </p>
<p>FUNCTION_DEFINITIONS </p>
<p>MAIN_CODE </p>
<h4 id="脚本调试"><a href="#脚本调试" class="headerlink" title="脚本调试"></a>脚本调试</h4><p>检测脚本中的语法错误 </p>
<p>​    bash -n /path/to/some_script </p>
<p>调试执行 </p>
<p>​    bash -x /path/to/some_script </p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>变量:命名的内存空间 </p>
<p>​    数据存储方式: </p>
<p>​        字符: </p>
<p>​        数值:整型,浮点型 </p>
<p>变量:变量类型 </p>
<p>​    作用: </p>
<p>​        1、数据存储格式 </p>
<p>​        2、参与的运算 </p>
<p>​        3、表示的数据范围 </p>
<p>​    类型: </p>
<p>​        字符 </p>
<p>​        数值:整型、浮点型 </p>
<p>强类型:变量不经过强制转换,它永远是这个数据类型,不允许隐式的类型转 换.一般定义变量时必须指定类型、参与运算必须符合类型要求;调用未声明 变量会产生错误 </p>
<p>​    如 java,c# </p>
<p>弱类型:语言的运行时会隐式做数据类型转换.无须指定类型,默认均为字符 型;参与运算会自动进行隐式类型转换;变量无须事先定义可直接调用 </p>
<p>​    如:bash 不支持浮点数,php </p>
<p>变量命名法则: </p>
<p>​    1、不能使程序中的保留字:例如if, for </p>
<p>​    2、只能使用数字、字母及下划线,且不能以数字开头 </p>
<p>​    3、见名知义 </p>
<p>​    4、统一命名规则:驼峰命名法 </p>
<h4 id="bash中变量的种类"><a href="#bash中变量的种类" class="headerlink" title="bash中变量的种类"></a>bash中变量的种类</h4><p>根据变量的生效范围等标准划分下面变量类型: </p>
<p>​    局部变量:生效范围为当前shell进程;对当前shell之外的其它shell进程,包括 当前shell的子shell进程均无效 </p>
<p>​    环境(全局)变量:生效范围为当前shell进程及其子进程 </p>
<p>​    本地变量:生效范围为当前shell进程中某代码片断,通常指函数 </p>
<p>​    位置变量:$1, $2, …来表示,用于让脚本在脚本代码中调用通过命令行传递给它 的参数 </p>
<p>​    特殊变量:$?, $0, $*, $@, $#,$$ </p>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>变量赋值:name=‘value’ </p>
<p>可以使用引用value: </p>
<p>​    (1) 可以是直接字串; name=“root” </p>
<p>​    (2) 变量引用:name=”$USER” </p>
<p>​    (3) 命令引用:name=`COMMAND` name=$(COMMAND) </p>
<p>变量引用:${name} $name</p>
<p>​     &quot;“:弱引用,其中的变量引用会被替换为变量值</p>
<p>​     &#39;‘:强引用,其中的变量引用不会被替换为变量值,而保持原字符串 </p>
<p>显示已定义的所有变量:set </p>
<p>删除变量:unset name </p>
<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>变量声明、赋值: </p>
<p>​    export name=VALUE </p>
<p>​    declare -x name=VALUE </p>
<p>变量引用:$name, ${name} </p>
<p>显示所有环境变量: </p>
<p>​    env </p>
<p>​    printenv </p>
<p>​    export </p>
<p>​    declare -x </p>
<p>删除变量: </p>
<p>​    unset name </p>
<p>bash内建的环境变量: </p>
<p>​    PATH </p>
<p>​    SHELL </p>
<p>​    USER </p>
<p>​    UID </p>
<p>​    HOME </p>
<p>​    PWD </p>
<p>​    SHLVL </p>
<p>​    LANG </p>
<p>​     MAIL </p>
<p>​    HOSTNAME </p>
<p>​    HISTSIZE </p>
<h4 id="只读和位置变量"><a href="#只读和位置变量" class="headerlink" title="只读和位置变量"></a>只读和位置变量</h4><p>只读变量:只能声明,但不能修改和删除 </p>
<p>​     声明只读变量: </p>
<p>​        readonly name </p>
<p>​        declare -r name </p>
<p>​     查看只读变量: </p>
<p>​        readonly –p </p>
<p> 位置变量:在脚本代码中调用通过命令行传递给脚本的参数 </p>
<p>​    $1, $2, …:对应第1、第2等参数,shift [n]换位置 </p>
<p>​    $0: 命令本身 </p>
<p>​    $*: 传递给脚本的所有参数,全部参数合为一个字符串 </p>
<p>​    $@: 传递给脚本的所有参数,每个参数为独立字符串 </p>
<p>​    $#: 传递给脚本的参数的个数 </p>
<p>​        $@ $* 只在被双引号包起来的时候才会有差异 </p>
<p>​    set – 清空所有位置变量 </p>
<h4 id="退出状态"><a href="#退出状态" class="headerlink" title="退出状态"></a>退出状态</h4><p>进程使用退出状态来报告成功或失败 </p>
<p>​    • 0 代表成功,1－255代表失败 </p>
<p>​    • $? 变量保存最近的命令退出状态 </p>
<p>例如: </p>
<p>​    ping -c1 -W1 hostdown &amp;&gt; /dev/null </p>
<p>​    echo $? </p>
<h4 id="退出状态码"><a href="#退出状态码" class="headerlink" title="退出状态码"></a>退出状态码</h4><p>bash自定义退出状态码 </p>
<p>​    exit [n]:自定义退出状态码 </p>
<p>注意:脚本中一旦遇到exit命令,脚本会立即终止;终止退出状态取决于exit命 令后面的数字                                                         注意:如果未给脚本指定退出状态码,整个脚本的退出状态码取决于脚本中执行 的最后一条命令的状态码 </p>
<h4 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h4><p>bash中的算术运算:help let </p>
<p>​    +, -, *, /, %取模(取余), **(乘方)</p>
<p>​    实现算术运算: </p>
<p>​    (1) let var=算术表达式 </p>
<p>​    (2) var=$[算术表达式] </p>
<p>​    (3) var=$((算术表达式)) </p>
<p>​    (4) var=$(expr arg1 arg2 arg3 …) </p>
<p>​    (5) declare –i var = 数值 </p>
<p>​    (6) echo ‘算术表达式’ | bc </p>
<p>乘法符号有些场景中需要转义,如* </p>
<p>bash有内建的随机数生成器:$RANDOM(0-32767) </p>
<p>​    echo $[$RANDOM%50] :0-49之间随机数 </p>
<h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>增强型赋值: </p>
<p>​    +=, -=, *=, /=, %= </p>
<p>let varOPERvalue </p>
<p>​    例如:let count+=3 自加3后自赋值 </p>
<p>自增,自减: </p>
<p>​    let var+=1 </p>
<p>​    let var++ let </p>
<p>​    var-=1 </p>
<p>​    let var– </p>
<h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><p>true, false </p>
<p>​    1, 0 </p>
<p>与(and): </p>
<p>​    1 与 1 = 1 </p>
<p>​    1 与 0 = 0 </p>
<p>​    0 与 1 = 0 </p>
<p>​    0 与 0 = 0 </p>
<p>或(or): </p>
<p>​    1 或 1 = 1 </p>
<p>​    1 或 0 = 1 </p>
<p>​    0 或 1 = 1 </p>
<p>​    0 或 0 = 0 </p>
<p>非(not):！ </p>
<p>​    ! 1 = 0 </p>
<p>​    ! 0 = 1 </p>
<p>短路运算 </p>
<p>​    短路与 </p>
<p>​    第一个为0,结果必定为0 </p>
<p>​    第一个为1,第二个必须要参与运算 </p>
<p>短路或 </p>
<p>​    第一个为1,结果必定为1 </p>
<p>​    第一个为0,第二个必须要参与运算 </p>
<p>异或:</p>
<p>​    ^ 异或的两个值,相同为假,不同为真 </p>
<h4 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h4><p>判断某需求是否满足,需要由测试机制来实现 </p>
<p>专用的测试表达式需要由测试命令辅助完成测试过程 </p>
<p>评估布尔声明,以便用在条件性执行中 </p>
<p>​    • 若真,则返回0 </p>
<p>​    • 若假,则返回1 </p>
<p>测试命令: </p>
<p>​    • test EXPRESSION </p>
<p>​    • [ EXPRESSION ] </p>
<p>​    • [[ EXPRESSION ]] </p>
<p>​    注意:EXPRESSION前后必须有空白字符 </p>
<h4 id="条件性的执行操作符"><a href="#条件性的执行操作符" class="headerlink" title="条件性的执行操作符"></a>条件性的执行操作符</h4><p>根据退出状态而定,命令可以有条件地运行 </p>
<p>​    • &amp;&amp; 代表条件性的AND THEN </p>
<p>​    • || 代表条件性的OR ELSE </p>
<p>例如:</p>
<p>grep -q no_such_user /etc/passwd \ </p>
<p>|| echo &#39;No such user&#39; </p>
<p>No such user </p>
<p>ping -c1 -W2 station1 &amp;&gt; /dev/null \ </p>
<p>&gt; &amp;&amp; echo “station1 is up&quot; \ </p>
<p>&gt; || (echo ‘station1 is unreachable’; exit 1) </p>
<p>station1 is up </p>
<h4 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a>test命令</h4><p>长格式的例子: </p>
<p>​    test “$A” = “$B” &amp;&amp; echo “Strings are equal” </p>
<p>​    test “$A”-eq “$B” &amp;&amp; echo “Integers are equal” </p>
<p> 简写格式的例子: </p>
<p>​    [ “$A” = “$B” ] &amp;&amp; echo “Strings are equal” </p>
<p>​    [ “$A” -eq “$B” ] &amp;&amp; echo “Integers are equal” </p>
<h4 id="bash的数值测试"><a href="#bash的数值测试" class="headerlink" title="bash的数值测试"></a>bash的数值测试</h4><p>-v VAR </p>
<p>​    变量VAR是否设置 </p>
<p>数值测试: </p>
<p>​    -gt 是否大于 </p>
<p>​    -ge 是否大于等于 </p>
<p>​    -eq 是否等于 </p>
<p>​    -ne 是否不等于 </p>
<p>​    -lt 是否小于 </p>
<p>​    -le 是否小于等于 </p>
<h4 id="bash-的字符串测试"><a href="#bash-的字符串测试" class="headerlink" title="bash 的字符串测试"></a>bash 的字符串测试</h4><p>字符串测试: </p>
<p>​    = 是否等于 </p>
<p>​    &gt; ascii码是否大于ascii码 </p>
<p>​    &lt; 是否小于 </p>
<p>​    != 是否不等于 </p>
<p>​    =~ 左侧字符串是否能够被右侧的PATTERN所匹配,注意: 此表达式一般用于[[ ]]中;扩展的正则表达式 </p>
<p>​    -z “STRING“ 字符串是否为空,空为真,不空为假 </p>
<p>​    -n “STRING“ 字符串是否不空,不空为真,空为假 </p>
<p> 注意:用于字符串比较时的用到的操作数都应该使用引号 </p>
<h4 id="bash的文件测试"><a href="#bash的文件测试" class="headerlink" title="bash的文件测试"></a>bash的文件测试</h4><p>存在性测试 </p>
<p>​    -a FILE:同-e </p>
<p>​    -e FILE: 文件存在性测试,存在为真,否则为假 </p>
<p>存在性及类别测试 </p>
<p>​    -b FILE:是否存在且为块设备文件 </p>
<p>​    -c FILE:是否存在且为字符设备文件 </p>
<p>​    -d FILE:是否存在且为目录文件 </p>
<p>​    -f FILE:是否存在且为普通文件 </p>
<p>​    -h FILE 或 -L FILE:存在且为符号链接文件 </p>
<p>​    -p FILE:是否存在且为命名管道文件 </p>
<p>​    -S FILE:是否存在且为套接字文件</p>
<h4 id="bash的文件权限测试"><a href="#bash的文件权限测试" class="headerlink" title="bash的文件权限测试"></a>bash的文件权限测试</h4><p>文件权限测试: </p>
<p>​    -r FILE:是否存在且可读 </p>
<p>​    -w FILE: 是否存在且可写 </p>
<p>​    -x FILE: 是否存在且可执行 </p>
<p>文件特殊权限测试: </p>
<p>​    -u FILE:是否存在且拥有suid权限 </p>
<p>​    -g FILE:是否存在且拥有sgid权限 </p>
<p>​    -k FILE:是否存在且拥有sticky权限 </p>
<h4 id="bash的文件属性测试"><a href="#bash的文件属性测试" class="headerlink" title="bash的文件属性测试"></a>bash的文件属性测试</h4><p>文件大小测试: </p>
<p>​    -s FILE: 是否存在且非空 </p>
<p>文件是否打开: </p>
<p>​    -t fd: fd 文件描述符是否在某终端已经打开 </p>
<p>​    -N FILE:文件自从上一次被读取之后是否被修改过 </p>
<p>​    -O FILE:当前有效用户是否为文件属主 </p>
<p>​    -G FILE:当前有效用户是否为文件属组</p>
<p>双目测试: </p>
<p>​    FILE1 -ef FILE2: FILE1是否是FILE2的硬链接 </p>
<p>​    FILE1 -nt FILE2: FILE1是否新于FILE2(mtime) </p>
<p>​    FILE1 -ot FILE2: FILE1是否旧于FILE2 </p>
<h4 id="bash的组合测试条件"><a href="#bash的组合测试条件" class="headerlink" title="bash的组合测试条件"></a>bash的组合测试条件</h4><p>第一种方式: </p>
<p>​    COMMAND1 &amp;&amp; COMMAND2 并且 </p>
<p>​    COMMAND1 || COMMAND2 或者 </p>
<p>​    ! COMMAND 非 </p>
<p>​    如:[[ -r FILE ]] &amp;&amp; [[ -w FILE ]] </p>
<p>第二种方式: </p>
<p>​    EXPRESSION1 -a EXPRESSION2 并且 </p>
<p>​    EXPRESSION1 -o EXPRESSION2 或者 </p>
<p>​    ! EXPRESSION </p>
<p>​    必须使用测试命令进行 </p>
<h4 id="使用read命令来接受输入"><a href="#使用read命令来接受输入" class="headerlink" title="使用read命令来接受输入"></a>使用read命令来接受输入</h4><p>使用read来把输入值分配给一个或多个shell变量 </p>
<p>​    -p 指定要显示的提示 </p>
<p>​    -s 静默输入,一般用于密码 </p>
<p>​    -n N 指定输入的字符长度N </p>
<p>​    -d ‘字符’ 输入结束符 </p>
<p>​    -t N TIMEOUT为N秒 </p>
<p>​    read 从标准输入中读取值,给每个单词分配一个变量 </p>
<p>​    所有剩余单词都被分配给最后一个变量 </p>
<p>​    read -p “Enter a filename: “ FILE </p>
<h4 id="bash展开命令行的顺序"><a href="#bash展开命令行的顺序" class="headerlink" title="bash展开命令行的顺序"></a>bash展开命令行的顺序</h4><p>把命令行分成单个命令词 </p>
<p>展开别名 </p>
<p>展开大括号的声明({}) </p>
<p>展开波浪符声明(~) </p>
<p>命令替换$() 和 (``) </p>
<p>再次把命令行分成命令词 </p>
<p>展开文件通配(* 、?、[abc]等等) </p>
<p>准备I/0重导向(&lt;、&gt;) </p>
<p>运行命令 </p>
<h4 id="防止扩展"><a href="#防止扩展" class="headerlink" title="防止扩展"></a>防止扩展</h4><p>反斜线()会使随后的字符按原意解释 </p>
<p>​    $ echo Your cost: \$5.00 </p>
<p>​    Your cost: $5.00 </p>
<p>加引号来防止扩展 </p>
<p>​    • 单引号(’)防止所有扩展 </p>
<p>​    • 双引号(”)也防止所有扩展,但是以下情况例外: </p>
<p>​        $(美元符号) － 变量扩展 </p>
<p>​        `(反引号) － 命令替换 </p>
<p>​        (反斜线) － 禁止单个字符扩展 </p>
<p>​        !(叹号) － 历史命令替换 </p>
<h4 id="bash的配置文件"><a href="#bash的配置文件" class="headerlink" title="bash的配置文件"></a>bash的配置文件</h4><p>按生效范围划分,存在两类: </p>
<p>全局配置: </p>
<p>​    /etc/profile </p>
<p>​    /etc/profile.d/*.sh </p>
<p>​    /etc/bashrc </p>
<p>个人配置: </p>
<p>​    ~/.bash_profile </p>
<p>​    ~/.bashrc </p>
<h4 id="Profile类"><a href="#Profile类" class="headerlink" title="Profile类"></a>Profile类</h4><p>按功能划分,存在两类: </p>
<p>​    profile类和bashrc类 </p>
<p>profile类:为交互式登录的shell提供配置 </p>
<p>​    全局:/etc/profile, /etc/profile.d/*.sh </p>
<p>​    个人:~/.bash_profile </p>
<p>​    功用: </p>
<p>​    (1) 用于定义环境变量 </p>
<p>​    (2) 运行命令或脚本 </p>
<h4 id="bashrc类"><a href="#bashrc类" class="headerlink" title="bashrc类"></a>bashrc类</h4><p>bashrc类:为非交互式和交互式登录的shell提供配置 </p>
<p>​    全局:/etc/bashrc </p>
<p>​    个人:~/.bashrc </p>
<p>​    功用: </p>
<p>​    (1) 定义命令别名和函数 </p>
<p>​    (2) 定义本地变量 </p>
<h4 id="编辑配置文件生效"><a href="#编辑配置文件生效" class="headerlink" title="编辑配置文件生效"></a>编辑配置文件生效</h4><p>修改profile和bashrc文件后需生效 </p>
<p>​    两种方法: </p>
<p>​    1重新启动shell进程 </p>
<p>​    2 . 或source </p>
<p>​    例: </p>
<p>​    . ~/.bashrc </p>
<h4 id="bash退出任务"><a href="#bash退出任务" class="headerlink" title="bash退出任务"></a>bash退出任务</h4><p>保存在~/.bash_logout文件中(用户) </p>
<p>在退出登录shell时运行 </p>
<p>用于 </p>
<p>​    • 创建自动备份 </p>
<p>​    • 清除临时文件 </p>
<h4 id="变量-1"><a href="#变量-1" class="headerlink" title="$-变量"></a>$-变量</h4><p>h:hashall,打开这个选项后,Shell 会将命令所在的路径hash下来,避免每次 都要查询.通过set +h将h选项关闭 </p>
<p>i:interactive-comments,包含这个选项说明当前的 shell 是一个交互式的 shell.所谓的交互式shell,在脚本中,i选项是关闭的. </p>
<p>m:monitor,打开监控模式,就可以通过Job control来控制进程的停止、继 续,后台或者前台执行等. </p>
<p>B:braceexpand,大括号扩展 </p>
<p>H:history,H选项打开,可以展开历史列表中的命令,可以通过!感叹号来完 成,例如“!!”返回上最近的一个历史命令,“!n”返回第 n 个历史命令 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/Linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7-%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mark_avatar.png">
      <meta itemprop="name" content="Mark">
      <meta itemprop="description" content="半吊子民工 英特纳雄耐尔就一定要实现">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mark blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7-%E4%BA%8C/" class="post-title-link" itemprop="url">Linux 文本处理工具(二)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-08-15 20:19:02" itemprop="dateCreated datePublished" datetime="2015-08-15T20:19:02+08:00">2015-08-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-02 23:27:56" itemprop="dateModified" datetime="2019-01-02T23:27:56+08:00">2019-01-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%B5%B7%E6%8B%BE%E8%B4%9D/" itemprop="url" rel="index"><span itemprop="name">学海拾贝</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="VIM简介"><a href="#VIM简介" class="headerlink" title="VIM简介"></a>VIM简介</h3><p>vi: Visual Interface,文本编辑器 </p>
<p>文本:ASCII, Unicode </p>
<p>文本编辑种类: </p>
<pre><code>行编辑器: sed 

全屏编辑器:nano, vi 

vim - Vi Improved </code></pre><p>其他编辑器: </p>
<pre><code>gedit 一个简单的图形编辑器 

gvim 一个Vim编辑器的图形版本 </code></pre><h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><p>vim [OPTION]… FILE…</p>
<pre><code>+#: 打开文件后,让光标处于第#行的行首,+默认行尾 

+/PATTERN:打开文件后,直接让光标处于第一个被PATTERN匹配到的行的行首 

–b file 二进制方式打开文件 

–d file1 file2… 比较多个文件 

-m file 只读打开文件 </code></pre><p>ex file 或 vim –e 直接进入ex模式 </p>
<p>如果该文件存在,文件被打开并显示内容 如果该文件不存在,当编辑后第一次存盘时创建它 </p>
<h4 id="vim-一个模式编辑器"><a href="#vim-一个模式编辑器" class="headerlink" title="vim: 一个模式编辑器"></a>vim: 一个模式编辑器</h4><p>击键行为是依赖于 vim的 的”模式” </p>
<p>三种主要模式: </p>
<pre><code>命令(Normal)模式:默认模式,移动光标,剪切/粘贴文本 

插入(Insert)或编辑模式: 修改文本 

扩展命令(extended command )模式: 保存,退出等 </code></pre><p>Esc键 退出当前模式 </p>
<p>Esc键 Esc键 总是返回到命令模式 </p>
<h4 id="模式转换"><a href="#模式转换" class="headerlink" title="模式转换"></a>模式转换</h4><p>命令模式 –&gt; 插入模式 </p>
<pre><code>i: insert, 在光标所在处输入 

I:在当前光标所在行的行首输入 

a: append, 在光标所在处后面输入 

A:在当前光标所在行的行尾输入 

o: 在当前光标所在行的下方打开一个新行 

O:在当前光标所在行的上方打开一个新行 </code></pre><p>插入模式 ——–&gt; 命令模式 </p>
<pre><code>ESC </code></pre><p>命令模式 ——–&gt; 扩展命令模式 </p>
<pre><code>: </code></pre><p>扩展命令模式 ——–&gt; 命令模式 </p>
<pre><code>ESC,enter </code></pre><h4 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h4><p>扩展模式: </p>
<pre><code>:q 退出 

:q! 强制退出,丢弃做出的修改 

:wq 保存退出 :x 保存退出 </code></pre><p>命令模式 </p>
<pre><code>ZZ: 保存退出 

ZQ:不保存退出 </code></pre><h4 id="扩展模式"><a href="#扩展模式" class="headerlink" title="扩展模式"></a>扩展模式</h4><p>按”:”进入Ex模式 </p>
<p>创建一个命令提示符: 处于底部的屏幕左侧 </p>
<p>命令: </p>
<pre><code>w     写(存)磁盘文件 

wq     写入并退出 

x     写入并退出 

q     退出 

q！     不存盘退出,即使更改都将丢失 

r filename     读文件内容到当前文件中 

w filename     将当前文件内容写入另一个文件 

!command     执行命令 

r!command     读入命令的输出 </code></pre><h4 id="命令模式光标跳转"><a href="#命令模式光标跳转" class="headerlink" title="命令模式光标跳转"></a>命令模式光标跳转</h4><p>字符间跳转: </p>
<pre><code>h: 左 l: 右 j: 下 k: 上 

#COMMAND:跳转由#指定的个数的字符 </code></pre><p>单词间跳转: </p>
<pre><code>w:下一个单词的词首 

e:当前或下一单词的词尾 

b:当前或前一个单词的词首 

#COMMAND:由#指定一次跳转的单词数 </code></pre><p>当前页跳转: </p>
<pre><code>H:页首 M:页中间行 L:页底 </code></pre><p>行首行尾跳转:</p>
<pre><code>^: 跳转至行首的第一个非空白字符 

0: 跳转至行首 

$: 跳转至行尾 </code></pre><p>行间移动: </p>
<pre><code>#G、扩展模式:# :跳转至由#指定行 

G:最后一行 

1G, gg: 第一行 </code></pre><p>句间移动: </p>
<pre><code>):下一句 (:上一句 </code></pre><p>段落间移动: </p>
<pre><code>}:下一段 {:上一段 </code></pre><h4 id="命令模式翻屏操作"><a href="#命令模式翻屏操作" class="headerlink" title="命令模式翻屏操作"></a>命令模式翻屏操作</h4><p>Ctrl+f: 向文件尾部翻一屏 </p>
<p>Ctrl+b: 向文件首部翻一屏 </p>
<p>Ctrl+d: 向文件尾部翻半屏 </p>
<p>Ctrl+u:向文件首部翻半屏 </p>
<h4 id="命令模式操作"><a href="#命令模式操作" class="headerlink" title="命令模式操作"></a>命令模式操作</h4><p>字符编辑: </p>
<pre><code>x: 删除光标处的字符 

#x: 删除光标处起始的#个字符 

xp: 交换光标所在处的字符及其后面字符的位置 

~:转换大小写 

J:删除当前行后的换行符 </code></pre><p>替换命令(r, replace) </p>
<pre><code>r: 替换光标所在处的字符 

R:切换成REPLACE模式 </code></pre><p>删除命令: </p>
<pre><code>d: 删除命令,可结合光标跳转字符,实现范围删除 

d$: 删除到行尾 

d^:删除到非空行首 

d0:删除到行首 

dw: 

de: 

db: 

#COMMAND </code></pre><p>dd: 删除光标所在的行 </p>
<pre><code>#dd:多行删除 </code></pre><p>D:从当前光标位置一直删除到行尾,留空行,等同于d$ </p>
<p>复制命令(y, yank): </p>
<pre><code>y: 复制,行为相似于d命令 

y$ 

y0 

y^ 

ye 

yw 

yb 

#COMMAND </code></pre><p>yy:复制行 </p>
<pre><code>#yy: 复制多行 </code></pre><p>Y: 复制整行 </p>
<p>粘贴命令(p, paste): </p>
<pre><code>p:缓冲区存的如果为整行,则粘贴当前光标所在行的下方;否则,则粘贴 至当前光标所在处的后面 

P:缓冲区存的如果为整行,则粘贴当前光标所在行的上方；否则,则粘贴 至当前光标所在处的前面 </code></pre><p> 改变命令(c, change) </p>
<pre><code>c: 修改后切换成插入模式 </code></pre><p> 命令模式 –&gt; 插入模式 </p>
<pre><code>c$ 

c^ 

c0 

cb 

ce 

cw 

#COMMAND </code></pre><p> cc:删除当前行并输入新内容,相当于S </p>
<pre><code>#cc: </code></pre><p> C:删除当前光标到行尾,并切换成插入模式 </p>
<h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p>100imark [ESC] 粘贴”mark”100次 </p>
<p>&lt;start position&gt;&lt;commend&gt;&lt;end position&gt; </p>
<p>Command: </p>
<pre><code>y 复制、d 删除、gU 变大写、gu 变小写 </code></pre><p>例如 0y$ 命令意味着: </p>
<pre><code>0 → 先到行头 

y → 从这里开始拷贝 

$ → 拷贝到本行最后一个字符 

ye 从当前位置拷贝到本单词的最后一个字符 </code></pre><h4 id="扩展命令模式-地址定界"><a href="#扩展命令模式-地址定界" class="headerlink" title="扩展命令模式:地址定界"></a>扩展命令模式:地址定界</h4><p>地址定界 </p>
<pre><code>:start_pos,end_pos 

\# 具体第#行,例如2表示第2行 

\#,# 从左侧#表示起始行,到右侧#表示结尾行 

\#,+# 从左侧#表示的起始行,加上右侧#表示的行数 

    :2,+3 表示2到5行

 . 当前行 

$ 最后一行 

    .,$-1 当前行到倒数第二行 

% 全文, 相当于1,$ </code></pre><p>/pat1/,/pat2/ </p>
<pre><code>从第一次被pat1模式匹配到的行开始,一直到第一次被pat2匹配到的行结 束 

#,/pat/ 

/pat/,$ </code></pre><p>使用方式:后跟一个编辑命令 </p>
<pre><code>d 

y 

w file: 将范围内的行另存至指定文件中 

r file:在指定位置插入指定文件中的所有内容 </code></pre><h4 id="扩展命令模式-查找"><a href="#扩展命令模式-查找" class="headerlink" title="扩展命令模式:查找"></a>扩展命令模式:查找</h4><p>查找 </p>
<pre><code>/PATTERN:从当前光标所在处向文件尾部查找 

?PATTERN:从当前光标所在处向文件首部查找 

n:与命令同方向 

N:与命令反方向 </code></pre><h4 id="扩展命令模式-查找并替换"><a href="#扩展命令模式-查找并替换" class="headerlink" title="扩展命令模式:查找并替换"></a>扩展命令模式:查找并替换</h4><p>s: 在扩展模式下完成查找替换操作 </p>
<pre><code>格式:s/要查找的内容/替换为的内容/修饰符 

要查找的内容:可使用模式 

替换为的内容:不能使用模式,但可以使用\1, \2, ...等后向引用符号；还可 以使用&quot;&amp;&quot;引用前面查找时查找到的整个内容 

修饰符: 

i: 忽略大小写 

g: 全局替换；默认情况下,每一行只替换第一次出现 

gc:全局替换,每次替换前询问 </code></pre><p>查找替换中的分隔符/可替换为其它字符,例如 </p>
<pre><code>s@/etc@/var@g 

s#/boot#/#i </code></pre><h4 id="命令模式-撤销更改"><a href="#命令模式-撤销更改" class="headerlink" title="命令模式:撤销更改"></a>命令模式:撤销更改</h4><p>u    撤销最近的更改 </p>
<p>#u    撤销之前多次更改 </p>
<p>U     撤消光标落在这行后所有此行的更改 </p>
<p>按Ctrl - r重做最后的”撤消”更改 </p>
<p>.     重复前一个操作 </p>
<p>n.    重复前一个操作n次 </p>
<h4 id="vim的寄存器"><a href="#vim的寄存器" class="headerlink" title="vim的寄存器"></a>vim的寄存器</h4><p>有26个命名寄存器和1个无命名寄存器,常存放不同的剪贴版内容,可以不同会话间共享 </p>
<p>寄存器名称a,b,…,z,格式:”寄存器 放在数字和命令之间 </p>
<pre><code>如:3&quot;tyy 表示复制3行到t寄存器中  

&quot;tp 表示将t寄存器内容粘贴 </code></pre><p>未指定,将使用无命名寄存器 </p>
<p>有10个数字寄存器,用0,1,…,9表示,0存放最近复制内容,1存放最近删除内容。当新的文本变更和删除时,1转存到2,2转存到3,以此类推。数字寄存器不能在不 同会话间共享 </p>
<h4 id="编辑二进制文件"><a href="#编辑二进制文件" class="headerlink" title="编辑二进制文件"></a>编辑二进制文件</h4><p>以二进制方式打开文件 </p>
<pre><code>vim –b binaryfile </code></pre><p>扩展命令模式下,利用xxd命令转换为可读的十六进制 </p>
<pre><code>:%!xxd </code></pre><p>编辑二进制文件 </p>
<p>扩展命令模式下,利用xxd命令转换回二进制 </p>
<pre><code>:%!xxd –r </code></pre><p>保存退出</p>
<h4 id="可视化模式"><a href="#可视化模式" class="headerlink" title="可视化模式"></a>可视化模式</h4><p>允许选择的文本块 </p>
<pre><code>v 面向字符 

V 面向行 

ctrl-v 面向块 </code></pre><p>可视化键可用于与移动键结合使用: </p>
<pre><code>w ) } 箭头等 </code></pre><p>突出显示的文字可被删除,复制,变更,过滤,搜索,替换等</p>
<h4 id="多文件模式"><a href="#多文件模式" class="headerlink" title="多文件模式"></a>多文件模式</h4><p>vim FILE1 FILE2 FILE3 … </p>
<pre><code>:next 下一个 

:prev 前一个 

:first 第一个 

:last 最后一个 

:wall 保存所有 

:qall 退出所有 

:wqall 保存退出所有</code></pre><h4 id="使用多个窗口"><a href="#使用多个窗口" class="headerlink" title="使用多个窗口"></a>使用多个窗口</h4><p>多文件分割 </p>
<pre><code>vim -o|-O FILE1 FILE2 ... 

-o: 水平分割 

-O: 垂直分割 

在窗口间切换:Ctrl+w, Arrow </code></pre><p>单文件窗口分割: </p>
<pre><code>Ctrl+w,s: split, 水平分割 

Ctrl+w,v: vertical, 垂直分割 

ctrl+w,q:取消相邻窗口 

ctrl+w,o:取消全部窗口 

:wqall 退出 </code></pre><h4 id="定制vim的工作特性"><a href="#定制vim的工作特性" class="headerlink" title="定制vim的工作特性"></a>定制vim的工作特性</h4><p>配置文件:永久有效 </p>
<pre><code>全局:/etc/vimrc 

个人:~/.vimrc </code></pre><p>扩展模式:当前vim进程有效 </p>
<p>(1) 行号 </p>
<pre><code>显示:set number, 简写为set nu 

取消显示:set nonumber, 简写为set nonu </code></pre><p>(2) 忽略字符的大小写 </p>
<pre><code>启用:set ic 

不忽略:set noic </code></pre><p>(3) 自动缩进 </p>
<pre><code>启用:set ai 

禁用:set noai</code></pre><p>(4) 智能缩进 </p>
<pre><code>启用:smartindent 简写 set si 

禁用:set nosi </code></pre><p>(5) 高亮搜索 </p>
<pre><code>启用:set hlsearch 

禁用:set nohlsearch </code></pre><p>(6) 语法高亮 </p>
<pre><code>启用:syntax on 

禁用:syntax off </code></pre><p>(7) 显示Tab和换行符 ^I 和$显示 </p>
<pre><code>启用:set list 

禁用:set nolist </code></pre><p>(8) 文件格式 </p>
<pre><code>启用windows格式:set fileformat=dos 

启用unix格式:set fileformat=unix 

简写: set ff=dos|unix </code></pre><p>(9) 设置文本宽度 </p>
<pre><code>启用: set textwidth=65 (vim only) 

禁用: set wrapmargin=15 </code></pre><p>(10) 设置光标所在行的标识线 </p>
<pre><code>启用:set cursorline,简写cul 

禁用:set no cursorline </code></pre><p>(11) 复制保留格式 </p>
<pre><code>启用: set paste 

禁用: set nopaste </code></pre><h4 id="了解更多"><a href="#了解更多" class="headerlink" title="了解更多"></a>了解更多</h4><p>Set 帮助 </p>
<pre><code>:help option-list 

:set or :set all </code></pre><p>vi/vim内置帮助 </p>
<pre><code>:help 

:help topic 

Use :q to exit help </code></pre><p>vimtutor </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/Linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7-%E4%B8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mark_avatar.png">
      <meta itemprop="name" content="Mark">
      <meta itemprop="description" content="半吊子民工 英特纳雄耐尔就一定要实现">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mark blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7-%E4%B8%80/" class="post-title-link" itemprop="url">Linux 文本处理工具(一)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-08-10 20:18:34" itemprop="dateCreated datePublished" datetime="2015-08-10T20:18:34+08:00">2015-08-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-02 23:27:42" itemprop="dateModified" datetime="2019-01-02T23:27:42+08:00">2019-01-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%B5%B7%E6%8B%BE%E8%B4%9D/" itemprop="url" rel="index"><span itemprop="name">学海拾贝</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="抽取文本的工具"><a href="#抽取文本的工具" class="headerlink" title="抽取文本的工具"></a>抽取文本的工具</h3><p>文件内容:less和 cat</p>
<p>文件截取:head和tail </p>
<p>按列抽取:cut </p>
<p>按关键字抽取:grep</p>
<h4 id="文件查看"><a href="#文件查看" class="headerlink" title="文件查看"></a>文件查看</h4><p>文件查看命令 : </p>
<p>cat ,tac ,rev </p>
<p>cat [OPTION]… [FILE]… </p>
<pre><code>-E: 显示行结束符$ 

-n: 对显示出的每一行进行编号 

-A:显示所有控制符 

-b:非空行编号 

-s:压缩连续的空行成一行 </code></pre><p>tac </p>
<p>rev </p>
<h4 id="分页查看文件内容"><a href="#分页查看文件内容" class="headerlink" title="分页查看文件内容"></a>分页查看文件内容</h4><p>more: 分页查看文件 </p>
<p>more [OPTIONS…] FILE… </p>
<pre><code>-d: 显示翻页及退出提示 </code></pre><p>less:一页一页地查看文件或STDIN输出 </p>
<p>查看时有用的命令包括: </p>
<pre><code>/文本 搜索 文本 

n/N 跳到下一个 或 上一个匹配 </code></pre><p>less 命令是man命令使用的分页器 </p>
<h4 id="显示文本前或后行内容"><a href="#显示文本前或后行内容" class="headerlink" title="显示文本前或后行内容"></a>显示文本前或后行内容</h4><p>head [OPTION]… [FILE]… </p>
<pre><code>-c #: 指定获取前#字节 

-n #: 指定获取前#行 

-#: 指定行数 </code></pre><p>tail [OPTION]… [FILE]… </p>
<pre><code>-c #: 指定获取后#字节 </code></pre><p>​    -n #: 指定获取后#行 </p>
<pre><code>-f: 跟踪显示文件fd新追加的内容,常用日志监控 

相当于 --follow=descriptor 

-F: 跟踪文件名,相当于—follow=name --retry     </code></pre><p>tailf 类似tail –f,当文件不增长时并不访问文件 </p>
<h4 id="按列抽取文本cut和合并文件paste"><a href="#按列抽取文本cut和合并文件paste" class="headerlink" title="按列抽取文本cut和合并文件paste"></a>按列抽取文本cut和合并文件paste</h4><p>cut [OPTION]… [FILE]… </p>
<pre><code>-d DELIMITER: 指明分隔符,默认tab </code></pre><p>​    -f FILEDS:     </p>
<p>​        #: 第#个字段 </p>
<p>​        #,#[,#]:离散的多个字段,例如1,3,6     </p>
<pre><code>#-#:连续的多个字段, 例如1-6 </code></pre><p>混合使用:1-3,7 </p>
<p>-c 按字符切割 </p>
<p>–output-delimiter=STRING指定输出分隔符 </p>
<h4 id="cut和paste"><a href="#cut和paste" class="headerlink" title="cut和paste"></a>cut和paste</h4><p>显示文件或STDIN数据的指定列 </p>
<p>​    cut -d: -f1 /etc/passwd        //以 : 为分隔符取出第一个参数</p>
<pre><code>cat /etc/passwd | cut -d: -f7 </code></pre><p>​    cut -c2-5 /usr/share/dict/words </p>
<p>paste 合并两个文件同行号的列到一行 </p>
<pre><code>paste [OPTION]... [FILE]... </code></pre><p>​    -d 分隔符:指定分隔符,默认用TAB </p>
<p>​    -s : 所有行合成一行显示 </p>
<p>​    paste f1 f2 </p>
<p>​    paste -s f1 f2         </p>
<h3 id="分析文本的工具"><a href="#分析文本的工具" class="headerlink" title="分析文本的工具"></a>分析文本的工具</h3><p>文本数据统计:wc </p>
<p>整理文本:sort </p>
<p>比较文件:diff和patch </p>
<h4 id="收集文本统计数据wc"><a href="#收集文本统计数据wc" class="headerlink" title="收集文本统计数据wc"></a>收集文本统计数据wc</h4><p>计数单词总数、行总数、字节总数和字符总数 </p>
<p>可以对文件或STDIN中的数据运行 </p>
<pre><code>wc story.txt 

39     237 1901     story.txt 

行数 字数 字节数  文件名</code></pre><p>常用选项 </p>
<p>​    -l    只计数行数 </p>
<p>​    -w     只计数单词总数 </p>
<p>​    -c     只计数字节总数 </p>
<p>​    -m     只计数字符总数 </p>
<p>​    -L     显示文件中最长行的长度     </p>
<h4 id="文本排序sort"><a href="#文本排序sort" class="headerlink" title="文本排序sort"></a>文本排序sort</h4><p>把整理过的文本显示在STDOUT,不改变原始文件 </p>
<pre><code>sort [options] file(s) </code></pre><p>常用选项 </p>
<p>​    -r     执行反方向(由上至下)整理 </p>
<p>​    -R     随机排序 </p>
<p>​    -n     执行按数字大小整理 </p>
<p>​    -f     选项忽略(fold)字符串中的字符大小写 </p>
<p>​    -u     选项(独特,unique)删除输出中的重复行 </p>
<p>​    -t c     选项使用c做为字段界定符 </p>
<p>​    -k X 选项按照使用c字符分隔的X列来整理能够使用多次     </p>
<h4 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h4><p>uniq命令:从输入中删除前后相接的重复的行 </p>
<p>uniq [OPTION]… [FILE]… </p>
<p>​    -c:     显示每行重复出现的次数 </p>
<p>​    -d:     仅显示重复过的行 </p>
<p>​    -u:     仅显示不曾重复的行 </p>
<p>​    注:连续且完全相同方为重复     </p>
<p>常和sort 命令一起配合使用: </p>
<pre><code>sort userlist.txt | uniq -c </code></pre><h4 id="比较文件"><a href="#比较文件" class="headerlink" title="比较文件"></a>比较文件</h4><p>比较两个文件之间的区别 </p>
<pre><code>diff foo.conf foo2.conf 

5c5 

&lt; use_widgets = no 

--- 

&gt; use_widgets = yes </code></pre><p>注明第5行有区别(改变) </p>
<h4 id="复制对文件改变patch"><a href="#复制对文件改变patch" class="headerlink" title="复制对文件改变patch"></a>复制对文件改变patch</h4><p>diff 命令的输出被保存在一种叫做”补丁”的文件中 </p>
<pre><code>使用 -u 选项来输出&quot;统一的(unified)&quot;diff格式文件,最适用于补丁文件 </code></pre><p>patch 复制在其它文件中进行的改变(要谨慎使用) </p>
<pre><code>适用 -b 选项来自动备份改变了的文件 

$ diff -u foo.conf foo2.conf &gt; foo.patch 

$ patch -b foo.conf foo.patch </code></pre><h3 id="Linux文本处理三剑客"><a href="#Linux文本处理三剑客" class="headerlink" title="Linux文本处理三剑客"></a>Linux文本处理三剑客</h3><p>grep:文本过滤(模式:pattern)工具 </p>
<pre><code>grep, egrep, fgrep(不支持正则表达式搜索) </code></pre><p>sed:stream editor,文本编辑工具 </p>
<p>awk:Linux上的实现gawk,文本报告生成器 </p>
<h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p>grep: Global search REgular expression and Print out the line </p>
<p>作用:文本搜索工具,根据用户指定的”模式”对目标文本逐行进行匹配检 查；打印匹配到的行 </p>
<p>模式:由正则表达式字符及文本字符所编写的过滤条件     </p>
<p>grep [OPTIONS] PATTERN [FILE…] </p>
<pre><code>grep root /etc/passwd 

grep &quot;$USER&quot; /etc/passwd 

grep &apos;$USER&apos; /etc/passwd 

grep \`whoami` /etc/passwd </code></pre><h4 id="grep命令选项"><a href="#grep命令选项" class="headerlink" title="grep命令选项"></a>grep命令选项</h4><pre><code>--color=auto: 对匹配到的文本着色显示 

-v: 显示不被pattern匹配到的行 

-i: 忽略字符大小写 

-n:显示匹配的行号 

-c: 统计匹配的行数 

-o: 仅显示匹配到的字符串 

-q: 静默模式,不输出任何信息 

-A #: after, 后#行 

-B #: before, 前#行 

-C #:context, 前后各#行 

-e:实现多个选项间的逻辑or关系 

   grep –e ‘cat ’ -e ‘dog’ file 

-w:匹配整个单词 

-E:使用ERE 

   使用正则表达式

-F:相当于fgrep,不支持正则表达式 

   可以测试文件1和文件2的包含关系</code></pre><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>REGEXP:由一类特殊字符及文本字符所编写的模式,其中有些字符(元字符)不表示字符字面意义,而表示控制或通配的功能 </p>
<p>程序支持:grep,sed,awk,vim, less,nginx,varnish等 </p>
<p>分两类: </p>
<p>基本正则表达式:BRE </p>
<p>扩展正则表达式:ERE </p>
<pre><code>grep -E, egrep </code></pre><p>正则表达式引擎: </p>
<p>采用不同算法,检查处理正则表达式的软件模块 </p>
<p>PCRE(Perl Compatible Regular Expressions) </p>
<p>元字符分类:字符匹配、匹配次数、位置锚定、分组 </p>
<p>man 7 regex </p>
<h4 id="基本正则表达式元字符"><a href="#基本正则表达式元字符" class="headerlink" title="基本正则表达式元字符"></a>基本正则表达式元字符</h4><p> 字符匹配:<br>​    . 匹配任意单个字符<br>​    [] 匹配指定范围内的任意单个字符<br>​    [^] 匹配指定范围外的任意单个字符<br>​    [:alnum:] 字母和数字<br>​    [:alpha:] 代表任何英文大小写字符,亦即 A-Z, a-z<br>​    [:lower:] 小写字母 [:upper:] 大写字母<br>​    [:blank:] 空白字符(空格和制表符)<br>​    [:space:] 水平和垂直的空白字符(比[:blank:]包含的范围广)<br>​    [:cntrl:] 不可打印的控制字符(退格、删除、警铃…)<br>​    [:digit:] 十进制数字 [:xdigit:]十六进制数字<br>​    [:graph:] 可打印的非空白字符<br>​    [:print:] 可打印字符<br>​    [:punct:] 标点符号</p>
<h4 id="正则表达式-1"><a href="#正则表达式-1" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>匹配次数:用在要指定次数的字符后面,用于指定前面的字符要出现的次数 </p>
<p>位置锚定:定位出现的位置 </p>
<p>^                 行首锚定,用于模式的最左侧 </p>
<p>$                行尾锚定,用于模式的最右侧 </p>
<p>^PATTERN$         用于模式匹配整行 </p>
<p>^$                 空行 </p>
<p>^[[:space:]]*$     空白行 </p>
<p>&lt; 或 \b             词首锚定,用于单词模式的左侧 </p>
<p>&gt; 或 \b             词尾锚定；用于单词模式的右侧 </p>
<p>&lt;PATTERN\&gt;         匹配整个单词 </p>
<p>分组:\(\)             将一个或多个字符捆绑在一起,当作一个整体进行处理,如: \(root\)\+ </p>
<p>分组括号中的模式匹配到的内容会被正则表达式引擎记录于内部的变量中,这 些变量的命名方式为: \1, \2, \3, … </p>
<p>\1 表示从左侧起第一个左括号以及与之匹配右括号之间的模式所匹配到的字符 </p>
<p>示例: \(string1\+\(string2\)*\) </p>
<pre><code>\1 :string1\\+\\(string2\\)* 

\2 :string2 </code></pre><p>后向引用:引用前面的分组括号中的模式所匹配字符,而非模式本身 </p>
<p>或者:\| </p>
<pre><code>示例:a\\|b: a或b C\\|cat: C或cat \\(C\\|c\\)at:Cat或cat </code></pre><table>
<thead>
<tr>
<th>元字符</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>行首</td>
</tr>
<tr>
<td>$</td>
<td>行尾</td>
</tr>
<tr>
<td>.</td>
<td>任意单一字符</td>
</tr>
<tr>
<td>[]</td>
<td>[]内任意单一字符</td>
</tr>
<tr>
<td>[^]</td>
<td>除[]内任意单一字符</td>
</tr>
<tr>
<td>*</td>
<td>*前面字符重复不确定次数</td>
</tr>
<tr>
<td>\+</td>
<td>\+前面字符重复一次以上不确定次数</td>
</tr>
<tr>
<td>?</td>
<td>? 前面字符重复0或1次</td>
</tr>
<tr>
<td>\</td>
<td>转义符</td>
</tr>
<tr>
<td>.*</td>
<td>任意长度字符</td>
</tr>
<tr>
<td>\{n\}</td>
<td>前面字符重复n次</td>
</tr>
<tr>
<td>\{n,\}</td>
<td>前面字符重复n次以上</td>
</tr>
<tr>
<td>\{m,n\}</td>
<td>前面字符重复m次和n次之间</td>
</tr>
<tr>
<td>[:alnum:]</td>
<td>字母和数字</td>
</tr>
<tr>
<td>[:alpha:]</td>
<td>代表任何英文大小写字符,即 A-Z,a-z</td>
</tr>
<tr>
<td>[:lower:]</td>
<td>小写字母</td>
</tr>
<tr>
<td>[:upper:]</td>
<td>大写字母</td>
</tr>
<tr>
<td>[:blank:]</td>
<td>水平空白字符(空格和制表符)</td>
</tr>
<tr>
<td>[:space:]</td>
<td>所有水平和垂直的空白字符(比[:blank:]包含的范围广)</td>
</tr>
<tr>
<td>[:cntrl:]</td>
<td>不可打印的控制字符(退格,删除,警铃)</td>
</tr>
<tr>
<td>[:digit:]</td>
<td>十进制数字</td>
</tr>
<tr>
<td>[:graph:]</td>
<td>可打印的非空白字符</td>
</tr>
<tr>
<td>[:punct:]</td>
<td>标点符号</td>
</tr>
<tr>
<td>[:xdigit:]</td>
<td>十六进制数字</td>
</tr>
</tbody></table>
<h4 id="egrep及扩展的正则表达式"><a href="#egrep及扩展的正则表达式" class="headerlink" title="egrep及扩展的正则表达式"></a>egrep及扩展的正则表达式</h4><p>egrep = grep -E </p>
<p>egrep [OPTIONS] PATTERN [FILE…] </p>
<p>扩展正则表达式的元字符: </p>
<p>字符匹配: </p>
<pre><code>. 任意单个字符 

[] 指定范围的字符 

[^] 不在指定范围的字符     </code></pre><h4 id="扩展正则表达式"><a href="#扩展正则表达式" class="headerlink" title="扩展正则表达式"></a>扩展正则表达式</h4><p>次数匹配:</p>
<pre><code> *:匹配前面字符任意次 

?: 0或1次 

+:1次或多次 

{m}:匹配m次 

{m,n}:至少m,至多n次     </code></pre><p>位置锚定:</p>
<pre><code> ^ :行首 

$ :行尾 

\&lt;, \b :语首 

\&gt;, \b :语尾     </code></pre><p>分组: </p>
<pre><code>() 

后向引用:\1, \2, ...     </code></pre><p>或者: </p>
<pre><code>a|b: a或b 

C|cat: C或cat 

(C|c)at:Cat或cat    </code></pre><h4 id="sed工具"><a href="#sed工具" class="headerlink" title="sed工具"></a>sed工具</h4><p>用法: </p>
<pre><code>sed [option]... &apos;script&apos; inputfile... </code></pre><p>常用选项: </p>
<pre><code>-n:不输出模式空间内容到屏幕,即不自动打印 

-e: 多点编辑 

-f:/PATH/SCRIPT_FILE: 从指定文件中读取编辑脚本 

-r: 支持使用扩展正则表达式 

-i.bak: 备份文件并原处编辑     </code></pre><p>script: </p>
<pre><code>&apos;地址命令&apos; </code></pre><p>地址定界:<br>(1) 不给地址:对全文进行处理<br>(2) 单地址:<br>​    #: 指定的行,$:最后一行<br>​    /pattern/:被此处模式所能够匹配到的每一行<br>(3) 地址范围:<br>​    #,#<br>​    #,+#<br>​    /pat1/,/pat2/<br>​    #,/pat1/<br>(4) <del>:步进<br>​    1</del>2 奇数行<br>​    2~2 偶数行</p>
<p>编辑命令: </p>
<pre><code>d             删除模式空间匹配的行,并立即启用下一轮循环 

p             打印当前模式空间内容,追加到默认输出之后 

a [\\]text         在指定行后面追加文本,支持使用\n实现多行追加 

i [\\\]text         在行前面插入文本 

c [\]text         替换行为单行或多行文本 

w /path/file     保存模式匹配的行至指定文件 

r /path/file     读取指定文件的文本至模式空间中匹配到的行后 

=             为模式空间中的行打印行号 

!             模式空间中匹配行取反处理     </code></pre><p>s/// 查找替换,支持使用其它分隔符,s@@@,s### </p>
<p>替换标记: </p>
<pre><code>g         行内全局替换 

p         显示替换成功的行 

w         /PATH/FILE 将替换成功的行保存至文件中     </code></pre><h4 id="高级编辑命令"><a href="#高级编辑命令" class="headerlink" title="高级编辑命令"></a>高级编辑命令</h4><pre><code>P: 打印模式空间开端至\n内容,并追加到默认输出之前 

h: 把模式空间中的内容覆盖至保持空间中 

H:把模式空间中的内容追加至保持空间中 

g: 从保持空间取出数据覆盖至模式空间 

G:从保持空间取出内容追加至模式空间 

x: 把模式空间中的内容与保持空间中的内容进行互换 

n: 读取匹配到的行的下一行覆盖至模式空间 

N:读取匹配到的行的下一行追加至模式空间 

d: 删除模式空间中的行 

D:如果模式空间包含换行符,则删除直到第一个换行符的模式空间中的文本, 并不会读取新的输入行,而使用合成的模式空间重新启动循环。如果模式空间 不包含换行符,则会像发出d命令那样启动正常的新循环 </code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/Linux-%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mark_avatar.png">
      <meta itemprop="name" content="Mark">
      <meta itemprop="description" content="半吊子民工 英特纳雄耐尔就一定要实现">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mark blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Linux-%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84/" class="post-title-link" itemprop="url">Linux 用户和组</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-08-04 20:04:56" itemprop="dateCreated datePublished" datetime="2015-08-04T20:04:56+08:00">2015-08-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-02 23:27:00" itemprop="dateModified" datetime="2019-01-02T23:27:00+08:00">2019-01-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%B5%B7%E6%8B%BE%E8%B4%9D/" itemprop="url" rel="index"><span itemprop="name">学海拾贝</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="用户user"><a href="#用户user" class="headerlink" title="用户user"></a>用户user</h4><p>令牌token,identity </p>
<p>Linux用户:Username/UID </p>
<p>管理员:root, 0 </p>
<p>普通用户:1-60000 自动分配 </p>
<p>系统用户:1-499, 1-999 (CentOS7) </p>
<p>对守护进程获取资源进行权限分配 </p>
<p>登录用户:500+, 1000+(CentOS7) </p>
<p>交互式登录 </p>
<h4 id="组group"><a href="#组group" class="headerlink" title="组group"></a>组group</h4><p>Linux组:Groupname/GID </p>
<p>管理员组:root, 0 </p>
<p>普通组: </p>
<p>系统组:1-499, 1-999(CENTOS7) </p>
<p>普通组:500+, 1000+(CENTOS7)</p>
<h4 id="安全上下文"><a href="#安全上下文" class="headerlink" title="安全上下文"></a>安全上下文</h4><p> Linux安全上下文 </p>
<p>运行中的程序:进程 (process) </p>
<p>以进程发起者的身份运行: </p>
<pre><code>root: /bin/cat 

mark: /bin/cat </code></pre><p>进程所能够访问资源的权限取决于进程的运行者的身份 </p>
<h4 id="组的类别"><a href="#组的类别" class="headerlink" title="组的类别"></a>组的类别</h4><p>Linux组的类别 </p>
<p>用户的主要组(primary group) </p>
<pre><code>用户必须属于一个且只有一个主组 

组名同用户名,且仅包含一个用户,私有组    </code></pre><p>用户的附加组(supplementary group) </p>
<pre><code>一个用户可以属于零个或多个辅助组 </code></pre><h4 id="用户和组的配置文件"><a href="#用户和组的配置文件" class="headerlink" title="用户和组的配置文件"></a>用户和组的配置文件</h4><p>Linux用户和组的主要配置文件: </p>
<pre><code>/etc/passwd:        

    名称,密码,UID,GID,描述信息,用户家目录,shell类型 

/etc/group:        

    组及其属性信息

/etc/shadow:        

    用户名:加密字段:上一次口令更改的时间:最小的口令有效期:最大的口令有效期:口令过期时间:口令过期宽限时间:账户有效期:最后一位是保留位

/etc/gshadow:    

    组密码及其相关属性 </code></pre><h4 id="passwd文件格式"><a href="#passwd文件格式" class="headerlink" title="passwd文件格式"></a>passwd文件格式</h4><p>login name:登录用名(mark) </p>
<p>passwd:密码 (x) </p>
<p>UID:用户身份编号 (1000) </p>
<p>GID:登录默认所在组编号 (1000) </p>
<p>GECOS:用户全名或注释 </p>
<p>home directory:用户主目录 (/home/mark) </p>
<p>shell:用户默认使用shell (/bin/bash) </p>
<p>账户中为!代表账户被锁定,虽然被锁定账户了,但是还是能够通过 su - username 来切换用户,但是如果将用户的 shell 类型设置为 nologin的话 再次切用户的时候是不能够输入命令的.</p>
<p>新建用户的时候如果不设置密码是无法登录的,会在shadow文件中出现!!,centOS7中会提示用户登录不需要密码.</p>
<p>使用 usermod -U username 来解锁</p>
<p>可以使用 chage username 来修改用户的账户时间</p>
<h4 id="shadow文件格式"><a href="#shadow文件格式" class="headerlink" title="shadow文件格式"></a>shadow文件格式</h4><p>登录用名 </p>
<p>用户密码:一般用sha512加密 </p>
<p>从1970年1月1日起到密码最近一次被更改的时间 </p>
<p>密码再过几天可以被变更(0表示随时可被变更) </p>
<p>密码再过几天必须被变更(99999表示永不过期) </p>
<p>密码过期前几天系统提醒用户(默认为一周) </p>
<p>密码过期几天后帐号会被锁定 </p>
<p>从1970年1月1日算起,多少天后帐号失效 </p>
<h4 id="密码加密"><a href="#密码加密" class="headerlink" title="密码加密"></a>密码加密</h4><p>加密机制: </p>
<pre><code>加密:明文--&gt; 密文 

解密:密文--&gt; 明文 </code></pre><p>单向加密:哈希算法,原文不同,密文必不同 </p>
<p>相同算法定长输出,获得密文不可逆推出原始数据 </p>
<p>雪崩效应:初始条件的微小改变,引起结果的巨大改变 </p>
<p>md5: message digest, 128bits </p>
<p>sha1: secure hash algorithm, 160bits </p>
<p>sha224: 224bits </p>
<p>sha256: 256bits </p>
<p>sha384: 384bits </p>
<p>sha512: 512bits </p>
<p> 更改加密算法: </p>
<pre><code>authconfig --passalgo=sha256 --update</code></pre><h4 id="密码的复杂性策略"><a href="#密码的复杂性策略" class="headerlink" title="密码的复杂性策略"></a>密码的复杂性策略</h4><p>使用数字、大写字母、小写字母及特殊字符中至少3种 </p>
<p>足够长 </p>
<p>使用随机密码 </p>
<p>定期更换,不要使用最近曾经使用过的密码 </p>
<h4 id="group文件格式"><a href="#group文件格式" class="headerlink" title="group文件格式"></a>group文件格式</h4><p>群组名称:就是群组名称 </p>
<p>群组密码:通常不需要设定,密码是被记录在 /etc/gshadow </p>
<p>GID:就是群组的 ID </p>
<p>以当前组为附加组的用户列表</p>
<p>(分隔符为逗号) </p>
<h4 id="gshdow文件格式"><a href="#gshdow文件格式" class="headerlink" title="gshdow文件格式"></a>gshdow文件格式</h4><p>群组名称:就是群组名称 </p>
<p>群组密码: </p>
<p>组管理员列表:组管理员的列表,更改组密码和成员 </p>
<p>以当前组为附加组的用户列表</p>
<p>(分隔符为逗号) </p>
<h4 id="用户和组管理命令"><a href="#用户和组管理命令" class="headerlink" title="用户和组管理命令"></a>用户和组管理命令</h4><p>用户管理命令 </p>
<pre><code>useradd 

usermod 

userdel </code></pre><p>组帐号维护命令 </p>
<pre><code>groupadd 

groupmod 

groupdel</code></pre><h4 id="用户创建-useradd"><a href="#用户创建-useradd" class="headerlink" title="用户创建:useradd"></a>用户创建:useradd</h4><p>useradd [options] LOGIN </p>
<pre><code>-u UID 

-o 配合-u 选项,不检查UID的唯一性 

-g GID:指明用户所属基本组,可为组名,也可以GID 

-c &quot;COMMENT&quot;:用户的注释信息 

-d HOME_DIR: 以指定的路径(不存在)为家目录 

-s SHELL: 指明用户的默认shell程序,可用列表在/etc/shells文件中 

-G GROUP1[,GROUP2,...]:为用户指明附加组,组须事先存在 

-N 不创建私用组做主组,使用users组做主组 </code></pre><p>​    -r: 创建系统用户 CentOS 6: ID&lt;500, CentOS 7: ID&lt;1000 </p>
<pre><code>-m 创建家目录,用于系统用户 </code></pre><p>​    -M 不创建家目录,用于非系统用户</p>
<p>使用 -r 选项创建系统用户的时候会默认不创建用户家目录,</p>
<p>默认值设定:/etc/default/useradd文件中 </p>
<p>显示或更改默认设置 </p>
<pre><code>useradd -D 

useradd –D -s SHELL 

useradd –D –b BASE_DIR </code></pre><p>​    useradd –D –g GROUP </p>
<h4 id="新建用户的相关文件和命令"><a href="#新建用户的相关文件和命令" class="headerlink" title="新建用户的相关文件和命令"></a>新建用户的相关文件和命令</h4><p>/etc/default/useradd </p>
<p>/etc/skel/*                 创建用户的时候默认的文件夹</p>
<p>/etc/login.defs            创建用户的时候默认的加密策略</p>
<p>newusers passwd        格式文件 批量创建用户 </p>
<p>chpasswd                 批量修改用户口令 </p>
<h4 id="用户属性修改"><a href="#用户属性修改" class="headerlink" title="用户属性修改"></a>用户属性修改</h4><p>usermod [OPTION] login </p>
<pre><code>-u UID: 新UID 

-g GID: 新主组 

-G GROUP1[,GROUP2,...[,GROUPN]]:新附加组,原来的附加组将会被 覆盖；若保留原有,则要同时使用-a选项 

-s SHELL:新的默认SHELL 

-c &apos;COMMENT&apos;:新的注释信息 

-d HOME: 新家目录不会自动创建；若要创建新家目录并移动原家数据, 同时使用-m选项 

-l login_name: 新的名字； 

-L: lock指定用户,在/etc/shadow 密码栏的增加 ! 

-U: unlock指定用户,将 /etc/shadow 密码栏的 ! 拿掉 

-e YYYY-MM-DD: 指明用户账号过期日期 </code></pre><p>​    -f INACTIVE: 设定非活动期限 </p>
<p>删除所有的附加组 usermod -G “” apache</p>
<h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><p>userdel [OPTION]… login </p>
<pre><code>-r: 删除用户家目录 </code></pre><h4 id="查看用户相关的ID信息"><a href="#查看用户相关的ID信息" class="headerlink" title="查看用户相关的ID信息"></a>查看用户相关的ID信息</h4><pre><code>id [OPTION]... [USER] 

-u: 显示UID 

-g: 显示GID 

-G: 显示用户所属的组的ID </code></pre><p>​    -n: 显示名称,需配合ugG使用 </p>
<p>可以用id来判断用户是否存在</p>
<h4 id="切换用户或以其它用户身份执行命令"><a href="#切换用户或以其它用户身份执行命令" class="headerlink" title="切换用户或以其它用户身份执行命令"></a>切换用户或以其它用户身份执行命令</h4><p>su [options…][-][user [args…]] </p>
<p>切换用户的方式: </p>
<p>​    su UserName:非登录式切换,即不会读取目标用户的配置文件,不改变 当前工作目录 </p>
<p>​    su - UserName:登录式切换,会读取目标用户的配置文件,切换至家目 录,完全切换 </p>
<p>​    root su至其他用户无须密码；非root用户切换时需要密码 </p>
<p>换个身份执行命令: </p>
<p>​    su [-] UserName -c ‘COMMAND’ </p>
<p>选项:-l –login </p>
<p>​    su -l UserName 相当于 su - UserName </p>
<h4 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h4><p>passwd [OPTIONS] UserName: 修改指定用户的密码 </p>
<p>常用选项: </p>
<pre><code>-d:删除指定用户密码 

-l:锁定指定用户 

-u:解锁指定用户 

-e:强制用户下次登录修改密码 

-f:强制操作 

-n mindays:指定最短使用期限 

-x maxdays:最大使用期限 

-w warndays:提前多少天开始警告 </code></pre><p>​    -i inactivedays:非活动期限     </p>
<p>​    –stdin:从标准输入接收用户密码 </p>
<p>示例:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "PASSWORD" | passwd --stdin USERNAME &gt;/dev/null</span><br></pre></td></tr></table></figure>

<h4 id="修改用户密码策略"><a href="#修改用户密码策略" class="headerlink" title="修改用户密码策略"></a>修改用户密码策略</h4><p>chage [OPTION]… LOGIN </p>
<pre><code>-d LAST_DAY 

-E --expiredate EXPIRE_DATE 

-I --inactive INACTIVE 

-m --mindays MIN_DAYS 

-M --maxdays MAX_DAYS 

-W --warndays WARN_DAYS 

–l 显示密码策略     </code></pre><p>示例: </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chage -d 0 USERNAME  	//下一次登录强制重设密码 </span><br><span class="line"></span><br><span class="line">chage -m 0 –M 42 –W 14 –I 7 USERNAME </span><br><span class="line"></span><br><span class="line">chage -E 2016-09-10 USERNAME</span><br></pre></td></tr></table></figure>

<h4 id="创建组"><a href="#创建组" class="headerlink" title="创建组"></a>创建组</h4><p>groupadd [OPTION]… group_name </p>
<p>​    -g GID: 指明GID号；[GID_MIN, GID_MAX] </p>
<p>​    -r: 创建系统组 </p>
<p>​        CentOS 6: ID&lt;500     </p>
<p>​        CentOS 7: ID&lt;1000</p>
<h4 id="修改和删除组"><a href="#修改和删除组" class="headerlink" title="修改和删除组"></a>修改和删除组</h4><p>组属性修改:groupmod </p>
<p>groupmod [OPTION]… group </p>
<p>​    -n group_name: 新名字 </p>
<p>​    -g GID: 新的GID </p>
<p>组删除:groupdel </p>
<p>​    groupdel GROUP </p>
<h4 id="更改组密码"><a href="#更改组密码" class="headerlink" title="更改组密码"></a>更改组密码</h4><p>组密码:gpasswd </p>
<p>gpasswd [OPTION] GROUP </p>
<p>​    -a user 将user添加至指定组中 </p>
<p>​    -d user 从指定组中移除用户user </p>
<p>​    -A user1,user2,… 设置有管理权限的用户列表 </p>
<p>newgrp命令:临时切换主组 </p>
<p>如果用户本不属于此组,则需要组密码 </p>
<h4 id="更改和查看组成员"><a href="#更改和查看组成员" class="headerlink" title="更改和查看组成员"></a>更改和查看组成员</h4><p>groupmems [options][action] </p>
<p>options: </p>
<p>​    -g, –group groupname 更改为指定组 (只有root) </p>
<p>Actions:</p>
<p>​    -a, –add username 指定用户加入组 </p>
<p>​    -d, –delete username 从组中删除用户 </p>
<p>​    -p, –purge 从组中清除所有成员 </p>
<p>​    -l, –list 显示组成员列表     </p>
<p>groups [USERNAME]… 查看用户所属组列表 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Mark"
      src="/images/mark_avatar.png">
  <p class="site-author-name" itemprop="name">Mark</p>
  <div class="site-description" itemprop="description">半吊子民工 英特纳雄耐尔就一定要实现</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:markupzh@gmail.com" title="E-Mail → mailto:markupzh@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mark</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
