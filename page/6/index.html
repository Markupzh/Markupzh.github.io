<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/M_32px.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/M_16px.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":7,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="半吊子民工 英特纳雄耐尔就一定要实现">
<meta property="og:type" content="website">
<meta property="og:title" content="Mark blog">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="Mark blog">
<meta property="og:description" content="半吊子民工 英特纳雄耐尔就一定要实现">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Mark">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Mark blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Mark blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">知行合一 划水归档</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86-%E4%B8%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mark_avatar.png">
      <meta itemprop="name" content="Mark">
      <meta itemprop="description" content="半吊子民工 英特纳雄耐尔就一定要实现">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mark blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86-%E4%B8%89/" class="post-title-link" itemprop="url">Linux 网络管理(三)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-11-15 20:33:53" itemprop="dateCreated datePublished" datetime="2015-11-15T20:33:53+08:00">2015-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-03 09:51:27" itemprop="dateModified" datetime="2019-01-03T09:51:27+08:00">2019-01-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%B5%B7%E6%8B%BE%E8%B4%9D/" itemprop="url" rel="index"><span itemprop="name">学海拾贝</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="互联网协议入门"><a href="#互联网协议入门" class="headerlink" title="互联网协议入门"></a>互联网协议入门</h3><h4 id="物理拓扑分类"><a href="#物理拓扑分类" class="headerlink" title="物理拓扑分类"></a>物理拓扑分类</h4><p><strong>1.总线拓扑</strong></p>
<p>总线拓扑结构是将网络中的所有设备通过相应的硬件接口直接连接到公共总线上，结点之间按广播方式通信，一个结点发出的信息，总线上的其它结点均可“收听”到。优点：结构简单、布线容易、可靠性较高，易于扩充，是局域网常采用的拓扑结构。缺点：所有的数据都需经过总线传送，总线成为整个网络的瓶颈；出现故障诊断较为困难。最著名的总线拓扑结构是以太网(Ethernet)。</p>
<p><strong>2.星型拓扑</strong></p>
<p>每个结点都由一条单独的通信线路与中心结点连结。优点：结构简单、容易实现、便于管理，连接点的故障容易监测和排除。缺点：中心结点是全网络的可靠瓶颈，中心结点出现故障会导致网络的瘫痪。</p>
<p><strong>3.环形拓扑</strong></p>
<p>各结点通过通信线路组成闭合回路，环中数据只能单向传输。优点：结构简单、容易实现，适合使用光纤，传输距离远，传输延迟确定。缺点：环网中的每个结点均成为网络可靠性的瓶颈，任意结点出现故障都会造成网络瘫痪，另外故障诊断也较困难。最著名的环形拓扑结构网络是令牌环网(Token Ring)</p>
<p><strong>4.树型拓扑</strong></p>
<p>是一种层次结构，结点按层次连结，信息交换主要在上下结点之间进行，相邻结点或同层结点之间一般不进行数据交换。优点：连结简单，维护方便，适用于汇集信息的应用要求。缺点：资源共享能力较低，可靠性不高，任何一个工作站或链路的故障都会影响整个网络的运行。</p>
<p><strong>5.网状拓扑</strong></p>
<p>又称作无规则结构，结点之间的联结是任意的，没有规律。优点：系统可靠性高，比较容易扩展，但是结构复杂，每一结点都与多点进行连结，因此必须采用路由算法和流量控制方法。目前广域网基本上采用网状拓扑结构。</p>
<h3 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h3><p><strong>开放式系统互联通信参考模型</strong>（英语：Open System Interconnection Reference Model，缩写为 OSI），简称为<strong>OSI模型</strong> </p>
<h4 id="层次划分"><a href="#层次划分" class="headerlink" title="层次划分"></a>层次划分</h4><p>根据建议X.200，OSI将计算机网络体系结构划分为以下七层，标有1～7，第1层在底部。 现“OSI/RM”是“Open Systems Interconnection Reference Model”的缩写。 </p>
<h5 id="第7层-应用层"><a href="#第7层-应用层" class="headerlink" title="第7层 应用层"></a>第7层 应用层</h5><h5 id="主条目：应用层"><a href="#主条目：应用层" class="headerlink" title="主条目：应用层"></a>主条目：<a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E5%B1%82" target="_blank" rel="noopener">应用层</a></h5><p>应用层（Application Layer）提供为应用软件而设的接口，以设置与另一应用软件之间的通信。例如: HTTP，HTTPS，FTP，TELNET，SSH，SMTP，POP3等。</p>
<h5 id="第6层-表达层"><a href="#第6层-表达层" class="headerlink" title="第6层 表达层"></a>第6层 表达层</h5><h5 id="主条目：表达层"><a href="#主条目：表达层" class="headerlink" title="主条目：表达层"></a>主条目：<a href="https://zh.wikipedia.org/wiki/%E8%A1%A8%E9%81%94%E5%B1%82" target="_blank" rel="noopener">表达层</a></h5><p>表达层（Presentation Layer）把数据转换为能与接收者的系统格式兼容并适合传输的格式。</p>
<h5 id="第5层-会话层"><a href="#第5层-会话层" class="headerlink" title="第5层 会话层"></a>第5层 会话层</h5><p>主条目：<a href="https://zh.wikipedia.org/wiki/%E4%BC%9A%E8%AF%9D%E5%B1%82" target="_blank" rel="noopener">会话层</a></p>
<p>会话层（Session Layer）负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接。</p>
<h5 id="第4层-传输层"><a href="#第4层-传输层" class="headerlink" title="第4层 传输层"></a>第4层 传输层</h5><p>主条目：<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82" target="_blank" rel="noopener">传输层</a></p>
<p>传输层（Transport Layer）把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如:传输控制协议（TCP）等。</p>
<h5 id="第3层-网络层"><a href="#第3层-网络层" class="headerlink" title="第3层 网络层"></a>第3层 网络层</h5><p>主条目：<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%B1%82" target="_blank" rel="noopener">网络层</a></p>
<p>网络层（Network Layer）决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组。网络表头包含了网络数据。例如:互联网协议（IP）等。</p>
<h5 id="第2层-数据链路层"><a href="#第2层-数据链路层" class="headerlink" title="第2层 数据链路层"></a>第2层 数据链路层</h5><p>主条目：<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82" target="_blank" rel="noopener">数据链路层</a></p>
<p>数据链路层（Data Link Layer）负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成帧。数据链表头（DLH）是包含了物理地址和错误侦测及改错的方法。数据链表尾（DLT）是一串指示数据包末端的字符串。例如以太网、无线局域网（Wi-Fi）和通用分组无线服务（GPRS）等。</p>
<p>分为两个子层：逻辑链路控制（logic link control，LLC）子层和介质访问控制（media access control，MAC）子层。</p>
<h5 id="第1层-物理层"><a href="#第1层-物理层" class="headerlink" title="第1层 物理层"></a>第1层 物理层</h5><p>主条目：<a href="https://zh.wikipedia.org/wiki/%E7%89%A9%E7%90%86%E5%B1%82" target="_blank" rel="noopener">物理层</a></p>
<p>物理层（Physical Layer）在局部局域网上传送数据帧（data frame），它负责管理计算机通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机适配器等。</p>
<h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h3><p>OSI的核心思想:</p>
<p><strong>1) 通信两端的主机能够理解对方的语言</strong></p>
<p>这是要求主机使用相同协议格式来发送数据</p>
<p><strong>2) 希望通信系统模块化，每个模块提供标准接口</strong></p>
<p>每个模块给和直接耦合的模块提供标准化的流程接口，每个模块内部无论怎样实现没有硬性规定，但外在的接口一定是标准件，这样耦合的模块可以无缝对接起来。</p>
<p>这样做的好处有：<br>(1) 由于使用标准接口，每个通信模块可以独立开发，增加自由度，提高生产效率<br>(2) 增加代码的重复利用率，由于通信模块的标准化的外在接口，应用程序可以直接使用现成的通信模块，而无需重新编码，这大大减轻了开发者的负担，间接地提供了生产效率。</p>
<table>
<thead>
<tr>
<th>OSI参考模型</th>
<th>各层的解释</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>为应用程序提供服务</td>
</tr>
<tr>
<td>表示层</td>
<td>数据格式转化,数据加密</td>
</tr>
<tr>
<td>会话层</td>
<td>建立,管理和维护回话</td>
</tr>
<tr>
<td>传输层</td>
<td>建立,管理和维护端到端的连接</td>
</tr>
<tr>
<td>网络层</td>
<td>IP选址及路由选择</td>
</tr>
<tr>
<td>数据链路层</td>
<td>提供介质访问和链路管理</td>
</tr>
<tr>
<td>物理层</td>
<td>物理层</td>
</tr>
</tbody></table>
<p> 以上七道工序最终产生了二进制流，除了物理层之外，每道工序都会在原始数据前添加一串属于自己的协议头，每个协议头有源主机的每层工序产生，自然有理解这些协议头的对端，举例来说：</p>
<p><strong>链路层协议头</strong>，这个协议头只有源主机、端接路由器可以理解，只会存活在源主机与其端接的中继路由器，换句话说，其生命周期只限于一根链路，只要端接路由器能顺利接收，其使命就算完成了，那路由器会将其从二进制流剥离掉，剩下打头阵的就是网络层的协议头。</p>
<p><strong>网络层协议头</strong>，其中包含了目的地网络地址，用于指示沿途的路由器，这一串二进制流的目的地是哪里，路由器查询自己的网络地址表，决定再发给更靠近目的地的下一跳路由器。假如找到了一个出接口与下一跳路由器直连，则又要考虑如何添加链路层的协议头了，依据不同的接口类型，添加了适合此链路的链路层协议头，然后再依据物理层介质的不同，物理层将其以光、电、电磁波的信号发送出去。</p>
<p>依照上面类似的步骤，一串二进制流每经过沿途一跳路由器，变换一次链路特有的协议头，但网络层协议头一直不会变，最终这一串二进制流到达了终点。</p>
<p>至此，网络层协议头也完成了其使命，剥离掉网络层协议头，剥离掉之前，先读出网络层协议头的传输层协议代码，把这一串二进制流发给传输层，剩下打头阵的就是传输层的协议头。</p>
<p><strong>传输层协议</strong>，依据传输层协议头里会话层协议代码，先剥离掉传输层协议头，把这一串二进制流发给会话层，剩下打头阵的就是会话层协议头。</p>
<p><strong>会话层协议</strong>，依据会话层议头里表示层协议代码，先剥离掉会话层协议头，把这一串二进制流发给表示层，剩下的头阵的就是表示层协议头。</p>
<p><strong>表示层协议</strong>，依据表示层议头里应用层协议代码，先剥离掉表示层协议头，把这一串二进制流发给应用层，剩下的头阵的就是应用层协议头。</p>
<p><strong>应用层协议</strong>，经过以上一跳一跳路由器的中继、终点主机的一层层协议头的剥离，源主机发给终点主机的数据终于到达终点了，至于数据是文字、图片、音频、视频，则由应用层协议来最终解释。 </p>
<p><strong>PUD</strong> :</p>
<p>PDU: Protocol Data Unit,协议数据单元是指对等层次之间传递的数据单位 </p>
<p>物理层的 PDU是数据位 bit </p>
<p>数据链路层的 PDU是数据帧 frame </p>
<p>网络层的PDU是数据包 packet </p>
<p>传输层的 PDU是数据段 segment </p>
<p>其他更高层次的PDU是消息 message </p>
<p><strong>三种通讯模式</strong></p>
<p>单播:一对一</p>
<p>广播:一对多</p>
<p>组播:多对多</p>
<h3 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a>网络设备</h3><h4 id="Hub集线器"><a href="#Hub集线器" class="headerlink" title="Hub集线器"></a>Hub集线器</h4><p>Hub：多端口中继器 </p>
<p>Hub并不记忆该信息包是由哪个MAC地址发 出，哪个MAC地址在Hub的哪个端口 </p>
<p>Hub的特点： </p>
<p>​    共享带宽 </p>
<p>​    半双工 </p>
<h4 id="以太网桥"><a href="#以太网桥" class="headerlink" title="以太网桥"></a>以太网桥</h4><p>交换式以太网的优势 </p>
<p>• 扩展了网络带宽 </p>
<p>• 分割了网络冲突域，使网络冲突被限制在最小的范围内 </p>
<p>• 交换机作为更加智能的交换设备，能够提供更多用户所要求的功能：优先级、 虚拟网、远程检测…… </p>
<h4 id="以太网桥工作原理"><a href="#以太网桥工作原理" class="headerlink" title="以太网桥工作原理"></a>以太网桥工作原理</h4><p>以太网桥监听数据帧中源MAC地址，学习MAC，建立MAC表 </p>
<p>对于未知MAC地址，网桥将转发到除接收该帧的端口之外的所有端口 </p>
<p>当网桥接到一个数据帧时，如果该帧的目的位于接收端口所在网段上，它就过 滤掉该数据帧；如果目的MAC地址在位于另外一个端口，网桥就将该帧转发到 该端口 </p>
<p>当网桥接到广播帧时候，它立即转发到除接收端口之外的所有其他端口 </p>
<h4 id="HUB和交换机"><a href="#HUB和交换机" class="headerlink" title="HUB和交换机"></a>HUB和交换机</h4><p> 集线器属于OSI的第一层物理层设备，而网桥属于OSI的第二层数据链路层设备 </p>
<p> 从工作方式来看，集线器是一种广播模式，所有端口在一个冲突域里面。网桥 的可以通过端口隔离冲突 </p>
<p> Hub是所有共享总线和共享带宽。网桥每个端口占一个带宽 </p>
<h4 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h4><p>为了实现路由,路由器需要做下列事情: </p>
<p>分隔广播域 </p>
<p>选择路由表中到达目标最好的路径 </p>
<p>维护和检查路由信息 </p>
<p>连接广域网 </p>
<h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><p>把一个数据包从一个设备发送到不同网络里的另一个设备上去。这些工 作依靠路由器来完成。路由器只关心网络的状态和决定网络中的最佳路径。 路由的实现依靠路由器中的路由表来完成 </p>
<h4 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h4><p>• 分隔广播域 </p>
<p>• 安全 </p>
<p>• 灵活管理</p>
<p>资料来源:</p>
<p>[1] 拓扑</p>
<p> <a href="https://baike.baidu.com/item/%E6%8B%93%E6%89%91" target="_blank" rel="noopener">https://baike.baidu.com/item/%E6%8B%93%E6%89%91</a></p>
<p>[2]OSI模型</p>
<p> <a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B</a></p>
<p>[3] 如何生动形象、切中要点地讲解 OSI 七层模型和两主机传输过程? - 车小胖的回答 - 知乎</p>
<p> <a href="https://www.zhihu.com/question/24002080/answer/150830722" target="_blank" rel="noopener">https://www.zhihu.com/question/24002080/answer/150830722</a> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86-%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mark_avatar.png">
      <meta itemprop="name" content="Mark">
      <meta itemprop="description" content="半吊子民工 英特纳雄耐尔就一定要实现">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mark blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86-%E4%BA%8C/" class="post-title-link" itemprop="url">Linux-网络管理(二)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-11-10 13:59:32" itemprop="dateCreated datePublished" datetime="2015-11-10T13:59:32+08:00">2015-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-02 23:43:28" itemprop="dateModified" datetime="2019-01-02T23:43:28+08:00">2019-01-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%B5%B7%E6%8B%BE%E8%B4%9D/" itemprop="url" rel="index"><span itemprop="name">学海拾贝</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一篇文章分析了互联网的总体构思,从下至上,每一层协议的设计思想.</p>
<p>这是从设计者的角度看问题,今天我想切换到用户的角度,看看用户是如何从上至下,与这些协议互动的.</p>
<hr>
<h3 id="前文小结"><a href="#前文小结" class="headerlink" title="前文小结"></a>前文小结</h3><p>先对前面的内容,做一个小结.</p>
<p>我们已经知道,网络通信就是交换数据包.电脑A向电脑B发送一个数据包,后者收到了,回复一个数据包,从而实现两台电脑之间的通信.数据包的结构,基本上是下面这样:</p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_12.png" alt=""></p>
<p>发送这个包,需要知道两个地址: </p>
<blockquote>
<ul>
<li><p>对方的MAC地址</p>
</li>
<li><p>对方的IP地址</p>
</li>
</ul>
</blockquote>
<p>有了这两个地址,数据包才能准确送到接收者手中.但是,前面说过,MAC地址有局限性,如果两台电脑不在同一个子网络,就无法知道对方的MAC地址,必须通过网关(gateway)转发. </p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_13.jpg" alt=""></p>
<p>上图中,1号电脑要向4号电脑发送一个数据包.它先判断4号电脑是否在同一个子网络,结果发现不是(后文介绍判断方法),于是就把这个数据包发到网关A.网关A通过路由协议,发现4号电脑位于子网络B,又把数据包发给网关B,网关B再转发到4号电脑.</p>
<p>1号电脑把数据包发到网关A,必须知道网关A的MAC地址.所以,数据包的目标地址,实际上分成两种情况:</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>数据包地址</th>
</tr>
</thead>
<tbody><tr>
<td>同一个子网络</td>
<td>对方的MAC地址,对方的IP地址</td>
</tr>
<tr>
<td>非同一个子网络</td>
<td>网关的MAC地址,对方的IP地址</td>
</tr>
</tbody></table>
<p>发送数据包之前,电脑必须判断对方是否在同一个子网络,然后选择相应的MAC地址.接下来,我们就来看,实际使用中,这个过程是怎么完成的. </p>
<h3 id="用户的上网设置"><a href="#用户的上网设置" class="headerlink" title="用户的上网设置"></a>用户的上网设置</h3><h4 id="静态IP地址"><a href="#静态IP地址" class="headerlink" title="静态IP地址"></a>静态IP地址</h4><p>你买了一台新电脑,插上网线,开机,这时电脑能够上网吗？ </p>
<p>通常你必须做一些设置.有时,管理员(或者ISP)会告诉你下面四个参数,你把它们填入操作系统,计算机就能连上网了: </p>
<blockquote>
<ul>
<li>本机的IP地址 　　</li>
<li>子网掩码 　　</li>
<li>网关的IP地址 　　</li>
<li>DNS的IP地址 </li>
</ul>
</blockquote>
<p>这四个参数缺一不可,后文会解释为什么需要知道它们才能上网.由于它们是给定的,计算机每次开机,都会分到同样的IP地址,所以这种情况被称作”静态IP地址上网”.</p>
<p>但是,这样的设置很专业,普通用户望而生畏,而且如果一台电脑的IP地址保持不变,其他电脑就不能使用这个地址,不够灵活.出于这两个原因,大多数用户使用”动态IP地址上网”.</p>
<h4 id="动态IP地址"><a href="#动态IP地址" class="headerlink" title="动态IP地址"></a>动态IP地址</h4><p>所谓”动态IP地址”,指计算机开机后,会自动分配到一个IP地址,不用人为设定.它使用的协议叫做<a href="http://zh.wikipedia.org/zh/DHCP" target="_blank" rel="noopener">DHCP协议</a>.</p>
<p>这个协议规定,每一个子网络中,有一台计算机负责管理本网络的所有IP地址,它叫做”DHCP服务器”.新的计算机加入网络,必须向”DHCP服务器”发送一个”DHCP请求”数据包,申请IP地址和相关的网络参数.</p>
<p>前面说过,如果两台计算机在同一个子网络,必须知道对方的MAC地址和IP地址,才能发送数据包.但是,新加入的计算机不知道这两个地址,怎么发送数据包呢？</p>
<p>DHCP协议做了一些巧妙的规定.</p>
<h4 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h4><p>首先,它是一种应用层协议,建立在UDP协议之上,所以整个数据包是这样的:</p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_14.png" alt=""></p>
<p>(1)最前面的”以太网标头”,设置发出方(本机)的MAC地址和接收方(DHCP服务器)的MAC地址.前者就是本机网卡的MAC地址,后者这时不知道,就填入一个广播地址:FF-FF-FF-FF-FF-FF.</p>
<p>(2)后面的”IP标头”,设置发出方的IP地址和接收方的IP地址.这时,对于这两者,本机都不知道.于是,发出方的IP地址就设为0.0.0.0,接收方的IP地址设为255.255.255.255.</p>
<p>(3)最后的”UDP标头”,设置发出方的端口和接收方的端口.这一部分是DHCP协议规定好的,发出方是68端口,接收方是67端口.</p>
<p>这个数据包构造完成后,就可以发出了.以太网是广播发送,同一个子网络的每台计算机都收到了这个包.因为接收方的MAC地址是FF-FF-FF-FF-FF-FF,看不出是发给谁的,所以每台收到这个包的计算机,还必须分析这个包的IP地址,才能确定是不是发给自己的.当看到发出方IP地址是0.0.0.0,接收方是255.255.255.255,于是DHCP服务器知道”这个包是发给我的”,而其他计算机就可以丢弃这个包.</p>
<p>接下来,DHCP服务器读出这个包的数据内容,分配好IP地址,发送回去一个”DHCP响应”数据包.这个响应包的结构也是类似的,以太网标头的MAC地址是双方的网卡地址,IP标头的IP地址是DHCP服务器的IP地址(发出方)和255.255.255.255(接收方),UDP标头的端口是67(发出方)和68(接收方),分配给请求端的IP地址和本网络的具体参数则包含在Data部分.</p>
<p>新加入的计算机收到这个响应包,于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数.</p>
<h4 id="上网设置-小结"><a href="#上网设置-小结" class="headerlink" title="上网设置:小结"></a>上网设置:小结</h4><p>这个部分,需要记住的就是一点:不管是”静态IP地址”还是”动态IP地址”,电脑上网的首要步骤,是确定四个参数.这四个值很重要,值得重复一遍: </p>
<blockquote>
<ul>
<li>本机的IP地址 　　</li>
<li>子网掩码 　　</li>
<li>网关的IP地址 　　</li>
<li>DNS的IP地址 </li>
</ul>
</blockquote>
<p>有了这几个数值,电脑就可以上网”冲浪”了.接下来,我们来看一个实例,当用户访问网页的时候,互联网协议是怎么运作的.</p>
<h3 id="一个实例-访问网页"><a href="#一个实例-访问网页" class="headerlink" title="一个实例:访问网页"></a>一个实例:访问网页</h3><h4 id="本机参数"><a href="#本机参数" class="headerlink" title="本机参数"></a>本机参数</h4><p>我们假定,经过上一节的步骤,用户设置好了自己的网络参数:</p>
<blockquote>
<ul>
<li>本机的IP地址:192.168.1.100</li>
<li>子网掩码:255.255.255.0</li>
<li>网关的IP地址:192.168.1.1</li>
<li>DNS的IP地址:8.8.8.8</li>
</ul>
</blockquote>
<p>然后他打开浏览器,想要访问Google,在地址栏输入了网址:<a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a>.</p>
<p>这意味着,浏览器要向google发送一个网页请求的数据包.</p>
<h4 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h4><p>我们知道,发送数据包,必须要知道对方的IP地址.但是,现在,我们只知道网址<a href="http://www.google.com,不知道它的IP地址" target="_blank" rel="noopener">www.google.com,不知道它的IP地址</a>.</p>
<p><a href="http://en.wikipedia.org/wiki/Domain_Name_System" target="_blank" rel="noopener">DNS协议</a>可以帮助我们,将这个网址转换成IP地址.已知DNS服务器为8.8.8.8,于是我们向这个地址发送一个DNS数据包(53端口).</p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_15.png" alt=""></p>
<p>然后,DNS服务器做出响应,告诉我们google的IP地址是172.194.72.105.于是,我们知道了对方的IP地址.</p>
<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>接下来,我们要判断,这个IP地址是不是在同一个子网络,这就要用到子网掩码.</p>
<p>已知子网掩码是255.255.255.0,本机用它对自己的IP地址192.168.1.100,做一个二进制的AND运算(两个数位都为1,结果为1,否则为0),计算结果为192.168.1.0；然后对Google的IP地址172.194.72.105也做一个AND运算,计算结果为172.194.72.0.这两个结果不相等,所以结论是,Google与本机不在同一个子网络.</p>
<p>因此,我们要向Google发送数据包,必须通过网关192.168.1.1转发,也就是说,接收方的MAC地址将是网关的MAC地址.</p>
<h4 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h4><p>浏览网页用的是HTTP协议,它的整个数据包构造是这样的:</p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_16.png" alt=""></p>
<p>HTTP部分的内容,类似于下面这样:</p>
<blockquote>
<p>　　GET / HTTP/1.1<br>　　Host: <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a><br>　　Connection: keep-alive<br>　　User-Agent: Mozilla/5.0 (Windows NT 6.1) ……<br>　　Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8<br>　　Accept-Encoding: gzip,deflate,sdch<br>　　Accept-Language: zh-CN,zh;q=0.8<br>　　Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3<br>　　Cookie: … …</p>
</blockquote>
<p>我们假定这个部分的长度为4960字节,它会被嵌在TCP数据包之中.</p>
<h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><p>TCP数据包需要设置端口,接收方(Google)的HTTP端口默认是80,发送方(本机)的端口是一个随机生成的1024-65535之间的整数,假定为51775.</p>
<p>TCP数据包的标头长度为20字节,加上嵌入HTTP的数据包,总长度变为4980字节.</p>
<h4 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h4><p>然后,TCP数据包再嵌入IP数据包.IP数据包需要设置双方的IP地址,这是已知的,发送方是192.168.1.100(本机),接收方是172.194.72.105(Google).</p>
<p>IP数据包的标头长度为20字节,加上嵌入的TCP数据包,总长度变为5000字节.</p>
<h4 id="以太网协议"><a href="#以太网协议" class="headerlink" title="以太网协议"></a>以太网协议</h4><p>最后,IP数据包嵌入以太网数据包.以太网数据包需要设置双方的MAC地址,发送方为本机的网卡MAC地址,接收方为网关192.168.1.1的MAC地址(通过ARP协议得到).</p>
<p>以太网数据包的数据部分,最大长度为1500字节,而现在的IP数据包长度为5000字节.因此,IP数据包必须分割成四个包.因为每个包都有自己的IP标头(20字节),所以四个包的IP数据包的长度分别为1500、1500、1500、560. </p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_17.png" alt=""></p>
<h4 id="服务器端响应"><a href="#服务器端响应" class="headerlink" title="服务器端响应"></a>服务器端响应</h4><p>经过多个网关的转发,Google的服务器172.194.72.105,收到了这四个以太网数据包.</p>
<p>根据IP标头的序号,Google将四个包拼起来,取出完整的TCP数据包,然后读出里面的”HTTP请求”,接着做出”HTTP响应”,再用TCP协议发回来.</p>
<p>本机收到HTTP响应以后,就可以将网页显示出来,完成一次网络通信.</p>
<p>资料参考:<br>[1] 互联网协议入门</p>
<p><a href="http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86-%E4%B8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mark_avatar.png">
      <meta itemprop="name" content="Mark">
      <meta itemprop="description" content="半吊子民工 英特纳雄耐尔就一定要实现">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mark blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86-%E4%B8%80/" class="post-title-link" itemprop="url">Linux 网络管理(一)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-11-07 20:58:05" itemprop="dateCreated datePublished" datetime="2015-11-07T20:58:05+08:00">2015-11-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-03 09:54:04" itemprop="dateModified" datetime="2019-01-03T09:54:04+08:00">2019-01-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%B5%B7%E6%8B%BE%E8%B4%9D/" itemprop="url" rel="index"><span itemprop="name">学海拾贝</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>信息化社会中每个人都和网络息息相关,大家都能享受到网络带来的快捷和便利.关于网络连接这其实是一个很复杂的事情,学习了很多资料,看过了很多博客之后终于找到阮老师关于互联网原理的讲解.有种恍然大悟的感觉,我转载了文章,希望可以帮助更多的人了解网络的基本原理.</p>
<hr>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="五层模型"><a href="#五层模型" class="headerlink" title="五层模型"></a>五层模型</h4><p>互联网的实现,分成好几层.每一层都有自己的功能,就像建筑物一样,每一层都靠下一层支持.</p>
<p>用户接触到的,只是最上面的一层,根本没有感觉到下面的层.要理解互联网,必须从最下层开始,自下而上理解每一层的功能.</p>
<p>如何分层有不同的模型,有的模型分七层,有的分四层.我觉得,把互联网分成五层,比较容易解释.</p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_1.png" alt=""></p>
<p>如上图所示,最底下的一层叫做”实体层”(Physical Layer),最上面的一层叫做”应用层”(Application Layer),中间的三层(自下而上)分别是”链接层”(Link Layer)、”网络层”(Network Layer)和”传输层”(Transport Layer).越下面的层,越靠近硬件:越上面的层,越靠近用户.</p>
<p>它们叫什么名字,其实并不重要.只需要知道,互联网分成若干层就可以了.</p>
<h4 id="层与协议"><a href="#层与协议" class="headerlink" title="层与协议"></a>层与协议</h4><p>每一层都是为了完成一种功能.为了实现这些功能,就需要大家都遵守共同的规则.</p>
<p>大家都遵守的规则,就叫做”协议”(protocol).</p>
<p>互联网的每一层,都定义了很多协议.这些协议的总称,就叫做”互联网协议”(Internet Protocol Suite).它们是互联网的核心,下面介绍每一层的功能,主要就是介绍每一层的主要协议.</p>
<h3 id="实体层"><a href="#实体层" class="headerlink" title="实体层"></a>实体层</h3><p>我们从最底下的一层开始.</p>
<p>电脑要组网,第一件事要干什么？当然是先把电脑连起来,可以用光缆、电缆、双绞线、无线电波等方式.</p>
<p><strong>这就叫做”实体层”,它就是把电脑连接起来的物理手段.它主要规定了网络的一些电气特性,作用是负责传送0和1的电信号.</strong> </p>
<h3 id="链接层"><a href="#链接层" class="headerlink" title="链接层"></a>链接层</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>单纯的0和1没有任何意义,必须规定解读方式：多少个电信号算一组？每个信号位有何意义？</p>
<p><strong>这就是”链接层”的功能,它在”实体层”的上方,确定了0和1的分组方式.</strong></p>
<h4 id="以太网协议"><a href="#以太网协议" class="headerlink" title="以太网协议"></a>以太网协议</h4><p>早期的时候,每家公司都有自己的电信号分组方式.逐渐地,一种叫做<a href="http://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E7%BD%91" target="_blank" rel="noopener">“以太网”</a>(Ethernet)的协议,占据了主导地位.</p>
<p>以太网规定,一组电信号构成一个数据包,叫做”帧”(Frame).每一帧分成两个部分：标头(Head)和数据(Data).</p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_2.png" alt=""></p>
<p>“标头”包含数据包的一些说明项,比如发送者、接受者、数据类型等等:”数据”则是数据包的具体内容.</p>
<p>“标头”的长度,固定为18字节.”数据”的长度,最短为46字节,最长为1500字节.因此,整个”帧”最短为64字节,最长为1518字节.如果数据很长,就必须分割成多个帧进行发送.</p>
<h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p>上面提到,以太网数据包的”标头”,包含了发送者和接受者的信息.那么,发送者和接受者是如何标识呢？</p>
<p>以太网规定,连入网络的所有设备,都必须具有”网卡”接口.数据包必须是从一块网卡,传送到另一块网卡.网卡的地址,就是数据包的发送地址和接收地址,这叫做MAC地址.</p>
<p>每块网卡出厂的时候,都有一个全世界独一无二的MAC地址,长度是48个二进制位,通常用12个十六进制数表示. </p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_3.png" alt=""></p>
<p>前6个十六进制数是厂商编号,后6个是该厂商的网卡流水号.有了MAC地址,就可以定位网卡和数据包的路径了. </p>
<h4 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h4><p>定义地址只是第一步,后面还有更多的步骤.</p>
<p>首先,一块网卡怎么会知道另一块网卡的MAC地址？</p>
<p>回答是有一种ARP协议,可以解决这个问题.这个留到后面介绍,这里只需要知道,以太网数据包必须知道接收方的MAC地址,然后才能发送.</p>
<p>其次,就算有了MAC地址,系统怎样才能把数据包准确送到接收方？</p>
<p>回答是以太网采用了一种很”原始”的方式,它不是把数据包准确送到接收方,而是向本网络内所有计算机发送,让每台计算机自己判断,是否为接收方.</p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_4.png" alt=""></p>
<p>上图中,1号计算机向2号计算机发送一个数据包,同一个子网络的3号、4号、5号计算机都会收到这个包.它们读取这个包的”标头”,找到接收方的MAC地址,然后与自身的MAC地址相比较,如果两者相同,就接受这个包,做进一步处理,否则就丢弃这个包.这种发送方式就叫做”广播”(broadcasting).</p>
<p>有了数据包的定义、网卡的MAC地址、广播的发送方式,”链接层”就可以在多台计算机之间传送数据了.</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h4 id="网络层的由来"><a href="#网络层的由来" class="headerlink" title="网络层的由来"></a>网络层的由来</h4><p>以太网协议,依靠MAC地址发送数据.理论上,单单依靠MAC地址,上海的网卡就可以找到洛杉矶的网卡了,技术上是可以实现的.</p>
<p>但是,这样做有一个重大的缺点.以太网采用广播方式发送数据包,所有成员人手一”包”,不仅效率低,而且局限在发送者所在的子网络.也就是说,如果两台计算机不在同一个子网络,广播是传不过去的.这种设计是合理的,否则互联网上每一台计算机都会收到所有包,那会引起灾难.</p>
<p>互联网是无数子网络共同组成的一个巨型网络,很像想象上海和洛杉矶的电脑会在同一个子网络,这几乎是不可能的.</p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_5.png" alt=""></p>
<p>因此,必须找到一种方法,能够区分哪些MAC地址属于同一个子网络,哪些不是.如果是同一个子网络,就采用广播方式发送,否则就采用”路由”方式发送.(“路由”的意思,就是指如何向不同的子网络分发数据包,这是一个很大的主题,本文不涉及.)遗憾的是,MAC地址本身无法做到这一点.它只与厂商有关,与所处网络无关.</p>
<p><strong>这就导致了”网络层”的诞生.它的作用是引进一套新的地址,使得我们能够区分不同的计算机是否属于同一个子网络.这套地址就叫做”网络地址”,简称”网址”.</strong></p>
<p>于是,”网络层”出现以后,每台计算机有了两种地址,一种是MAC地址,另一种是网络地址.两种地址之间没有任何联系,MAC地址是绑定在网卡上的,网络地址则是管理员分配的,它们只是随机组合在一起.</p>
<p>网络地址帮助我们确定计算机所在的子网络,MAC地址则将数据包送到该子网络中的目标网卡.因此,从逻辑上可以推断,必定是先处理网络地址,然后再处理MAC地址.</p>
<h4 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h4><p>规定网络地址的协议,叫做IP协议.它所定义的地址,就被称为IP地址.</p>
<p>目前,广泛采用的是IP协议第四版,简称IPv4.这个版本规定,网络地址由32个二进制位组成.</p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_6.png" alt=""></p>
<p>习惯上,我们用分成四段的十进制数表示IP地址,从0.0.0.0一直到255.255.255.255.</p>
<p>互联网上的每一台计算机,都会分配到一个IP地址.这个地址分成两个部分,前一部分代表网络,后一部分代表主机.比如,IP地址172.16.254.1,这是一个32位的地址,假定它的网络部分是前24位(172.16.254),那么主机部分就是后8位(最后的那个1).处于同一个子网络的电脑,它们IP地址的网络部分必定是相同的,也就是说172.16.254.2应该与172.16.254.1处在同一个子网络.</p>
<p>但是,问题在于单单从IP地址,我们无法判断网络部分.还是以172.16.254.1为例,它的网络部分,到底是前24位,还是前16位,甚至前28位,从IP地址上是看不出来的.</p>
<p>那么,怎样才能从IP地址,判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数”子网掩码”(subnet mask).</p>
<p>所谓”子网掩码”,就是表示子网络特征的一个参数.它在形式上等同于IP地址,也是一个32位二进制数字,它的网络部分全部为1,主机部分全部为0.比如,IP地址172.16.254.1,如果已知网络部分是前24位,主机部分是后8位,那么子网络掩码就是11111111.11111111.11111111.00000000,写成十进制就是255.255.255.0.</p>
<p>知道”子网掩码”,我们就能判断,任意两个IP地址是否处在同一个子网络.方法是将两个IP地址与子网掩码分别进行AND运算(两个数位都为1,运算结果为1,否则为0),然后比较结果是否相同,如果是的话,就表明它们在同一个子网络中,否则就不是.</p>
<p>比如,已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0,请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算,结果都是172.16.254.0,因此它们在同一个子网络.</p>
<p>总结一下,IP协议的作用主要有两个,一个是为每一台计算机分配IP地址,另一个是确定哪些地址在同一个子网络.</p>
<h4 id="IP数据包"><a href="#IP数据包" class="headerlink" title="IP数据包"></a>IP数据包</h4><p>根据IP协议发送的数据,就叫做IP数据包.不难想象,其中必定包括IP地址信息.</p>
<p>但是前面说过,以太网数据包只包含MAC地址,并没有IP地址的栏位.那么是否需要修改数据定义,再添加一个栏位呢？</p>
<p>回答是不需要,我们可以把IP数据包直接放进以太网数据包的”数据”部分,因此完全不用修改以太网的规格.这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构.</p>
<p>具体来说,IP数据包也分为”标头”和”数据”两个部分.</p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_7.png" alt=""></p>
<p>“标头”部分主要包括版本、长度、IP地址等信息,”数据”部分则是IP数据包的具体内容.它放进以太网数据包后,以太网数据包就变成了下面这样. </p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_8.png" alt=""></p>
<p>IP数据包的”标头”部分的长度为20到60字节,整个数据包的总长度最大为65,535字节.因此,理论上,一个IP数据包的”数据”部分,最长为65,515字节.前面说过,以太网数据包的”数据”部分,最长只有1500字节.因此,如果IP数据包超过了1500字节,它就需要分割成几个以太网数据包,分开发送了.</p>
<h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><p>关于”网络层”,还有最后一点需要说明.</p>
<p>因为IP数据包是放在以太网数据包里发送的,所以我们必须同时知道两个地址,一个是对方的MAC地址,另一个是对方的IP地址.通常情况下,对方的IP地址是已知的(后文会解释),但是我们不知道它的MAC地址.</p>
<p>所以,我们需要一种机制,能够从IP地址得到MAC地址.</p>
<p>这里又可以分成两种情况.第一种情况,如果两台主机不在同一个子网络,那么事实上没有办法得到对方的MAC地址,只能把数据包传送到两个子网络连接处的”网关”(gateway),让网关去处理.</p>
<p>第二种情况,如果两台主机在同一个子网络,那么我们可以用ARP协议,得到对方的MAC地址.ARP协议也是发出一个数据包(包含在以太网数据包中),其中包含它所要查询主机的IP地址,在对方的MAC地址这一栏,填的是FF:FF:FF:FF:FF:FF,表示这是一个”广播”地址.它所在子网络的每一台主机,都会收到这个数据包,从中取出IP地址,与自身的IP地址进行比较.如果两者相同,都做出回复,向对方报告自己的MAC地址,否则就丢弃这个包.</p>
<p>总之,有了ARP协议之后,我们就可以得到同一个子网络内的主机MAC地址,可以把数据包发送到任意一台主机之上了.</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><h4 id="输层的由来"><a href="#输层的由来" class="headerlink" title="输层的由来"></a>输层的由来</h4><p>有了MAC地址和IP地址,我们已经可以在互联网上任意两台主机上建立通信.</p>
<p>接下来的问题是,同一台主机上有许多程序都需要用到网络,比如,你一边浏览网页,一边与朋友在线聊天.当一个数据包从互联网上发来的时候,你怎么知道,它是表示网页的内容,还是表示在线聊天的内容？</p>
<p>也就是说,我们还需要一个参数,表示这个数据包到底供哪个程序(进程)使用.这个参数就叫做”端口”(port),它其实是每一个使用网卡的程序的编号.每个数据包都发到主机的特定端口,所以不同的程序就能取到自己所需要的数据.</p>
<p>“端口”是0到65535之间的一个整数,正好16个二进制位.0到1023的端口被系统占用,用户只能选用大于1023的端口.不管是浏览网页还是在线聊天,应用程序会随机选用一个端口,然后与服务器的相应端口联系.</p>
<p><strong>“传输层”的功能,就是建立”端口到端口”的通信.相比之下,”网络层”的功能是建立”主机到主机”的通信.只要确定主机和端口,我们就能实现程序之间的交流.</strong>因此,Unix系统就把主机+端口,叫做”套接字”(socket).有了它,就可以进行网络应用程序开发了.</p>
<h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><p>现在,我们必须在数据包中加入端口信息,这就需要新的协议.最简单的实现叫做UDP协议,它的格式几乎就是在数据前面,加上端口号.</p>
<p>UDP数据包,也是由”标头”和”数据”两部分组成.</p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_9.png" alt=""></p>
<p>“标头”部分主要定义了发出端口和接收端口,”数据”部分就是具体的内容.然后,把整个UDP数据包放入IP数据包的”数据”部分,而前面说过,IP数据包又是放在以太网数据包之中的,所以整个以太网数据包现在变成了下面这样： </p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_10.png" alt=""></p>
<p>UDP数据包非常简单,”标头”部分一共只有8个字节,总长度不超过65,535字节,正好放进一个IP数据包.</p>
<h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><p>UDP协议的优点是比较简单,容易实现,但是缺点是可靠性较差,一旦数据包发出,无法知道对方是否收到.</p>
<p>为了解决这个问题,提高网络可靠性,TCP协议就诞生了.这个协议非常复杂,但可以近似认为,它就是有确认机制的UDP协议,每发出一个数据包都要求确认.如果有一个数据包遗失,就收不到确认,发出方就知道有必要重发这个数据包了.</p>
<p>因此,TCP协议能够确保数据不会遗失.它的缺点是过程复杂、实现困难、消耗较多的资源.</p>
<p>TCP数据包和UDP数据包一样,都是内嵌在IP数据包的”数据”部分.TCP数据包没有长度限制,理论上可以无限长,但是为了保证网络的效率,通常TCP数据包的长度不会超过IP数据包的长度,以确保单个TCP数据包不必再分割.</p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用程序收到”传输层”的数据,接下来就要进行解读.由于互联网是开放架构,数据来源五花八门,必须事先规定好格式,否则根本无法解读.</p>
<p><strong>“应用层”的作用,就是规定应用程序的数据格式.</strong></p>
<p>举例来说,TCP协议可以为各种各样的程序传递数据,比如Email、WWW、FTP等等.那么,必须有不同协议规定电子邮件、网页、FTP数据的格式,这些应用程序协议就构成了”应用层”.</p>
<p>这是最高的一层,直接面对用户.它的数据就放在TCP数据包的”数据”部分.因此,现在的以太网的数据包就变成下面这样.</p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_11.png" alt=""></p>
<p>至此,整个互联网的五层结构,自下而上全部讲完了.这是从系统的角度,解释互联网是如何构成的. 下一篇反过来,从用户的角度,自上而下看看这个结构是如何发挥作用,完成一次网络数据交换的. </p>
<p>原文:</p>
<p>[1]  互联网协议入门</p>
<p><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/Linux-%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1-%E4%B8%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mark_avatar.png">
      <meta itemprop="name" content="Mark">
      <meta itemprop="description" content="半吊子民工 英特纳雄耐尔就一定要实现">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mark blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Linux-%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1-%E4%B8%89/" class="post-title-link" itemprop="url">Linux 中的进程和计划任务(三)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-11-03 21:40:53" itemprop="dateCreated datePublished" datetime="2015-11-03T21:40:53+08:00">2015-11-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-02 23:54:50" itemprop="dateModified" datetime="2019-01-02T23:54:50+08:00">2019-01-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%B5%B7%E6%8B%BE%E8%B4%9D/" itemprop="url" rel="index"><span itemprop="name">学海拾贝</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Linux-中进程的管理"><a href="#Linux-中进程的管理" class="headerlink" title="Linux 中进程的管理"></a>Linux 中进程的管理</h2><h3 id="进程管理工具-kill"><a href="#进程管理工具-kill" class="headerlink" title="进程管理工具 kill"></a>进程管理工具 kill</h3><p><strong>kill命令:</strong> </p>
<pre><code>向进程发送控制信号,以实现对进程管理,每个信号对应一个数字,信号名称以SIG开头 (可省略),不区分大小写 

显示当前系统可用信号: kill –l,trap -l </code></pre><p>​    常用信号:man 7 signal </p>
<p>​    1) SIGHUP: 无须关闭进程而让其重读配置文件 </p>
<p>​    2) SIGINT: 中止正在运行的进程;相当于Ctrl+c </p>
<p>​    3) SIGQUIT:相当于ctrl+\ </p>
<pre><code>9) SIGKILL: 强制杀死正在运行的进程 </code></pre><p>​    15) SIGTERM:终止正在运行的进程 </p>
<p>​    18) SIGCONT:继续运行 </p>
<p>​    19) SIGSTOP:后台休眠 </p>
<pre><code>指定信号的方法: 

(1) 信号的数字标识:1, 2, 9 

(2) 信号完整名称:SIGHUP 

(3) 信号的简写名称:HUP </code></pre><p>按PID:kill [-SIGNAL] pid … </p>
<pre><code>kill –n SIGNAL pid;kill –s SIGNAL pid </code></pre><p>按名称:killall [-SIGNAL] comm… </p>
<p>按模式:pkill [options] pattern </p>
<pre><code>-SIGNAL </code></pre><p>​    -u uid: effective user,生效者 </p>
<pre><code>-U uid: real user,真正发起运行命令者 </code></pre><p>​    -t terminal: 与指定终端相关的进程 </p>
<pre><code>-l: 显示进程名(pgrep可用) 

-a: 显示完整格式的进程名(pgrep可用) </code></pre><p>​    -P pid: 显示指定进程的子进程 </p>
<h3 id="作业管理"><a href="#作业管理" class="headerlink" title="作业管理"></a>作业管理</h3><p> Linux的作业控制 </p>
<pre><code>前台作业:通过终端启动,且启动后一直占据终端 

后台作业:可通过终端启动,但启动后即转入后台运行(释放终端) </code></pre><p> 让作业运行于后台 </p>
<pre><code>(1) 运行中的作业: Ctrl+z 

(2) 尚未启动的作业: COMMAND &amp; </code></pre><p> 后台作业虽然被送往后台运行,但其依然与终端相关;退出终端,将关闭后台作业。如果希望 送往后台后,剥离与终端的关系 </p>
<pre><code>nohup COMMAND &amp;&gt;/dev/null &amp; 

screen;COMMAND </code></pre><p> 查看当前终端所有作业:jobs </p>
<p> 作业控制: </p>
<pre><code>fg [[%]JOB_NUM]:把指定的后台作业调回前台 

bg [[%]JOB_NUM]:让送往后台的作业在后台继续运行 

kill [%JOB_NUM]: 终止指定的作业 </code></pre><h3 id="并行运行"><a href="#并行运行" class="headerlink" title="并行运行"></a>并行运行</h3><p>同时运行多个进程,提高效率 </p>
<p>方法1 </p>
<pre><code>vi all.sh 

f1.sh&amp; 

f2.sh&amp; 

f3.sh&amp; </code></pre><p>方法2 </p>
<pre><code>(f1.sh&amp;);(f2.sh&amp;);(f3.sh&amp;) </code></pre><p>方法3 </p>
<pre><code>{ f1.sh&amp; f2.sh&amp; f3.sh&amp; } </code></pre><h3 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h3><p>Linux任务计划、周期性任务执行 </p>
<pre><code>• 未来的某时间点执行一次任务 

    at 

    batch:系统自行选择空闲时间去执行此处指定的任务 

• 周期性运行某任务 

    cron </code></pre><h4 id="at任务"><a href="#at任务" class="headerlink" title="at任务"></a>at任务</h4><p>包:at </p>
<p> at命令:at [option] TIME </p>
<p> 常用选项: </p>
<pre><code>-V 显示版本信息: 

-l 列出指定队列中等待运行的作业;相当于atq 

-d 删除指定的作业;相当于atrm 

-c 查看具体作业任务 

-f /path/file 指定的文件中读取任务 

-m 当任务被完成之后,将给用户发送邮件,即使没有标准输出 </code></pre><p> 注意:作业执行命令的结果中的标准输出和错误以邮件通知给相关用户 </p>
<p> TIME:定义出什么时候进行 at 这项任务的时间 </p>
<pre><code>HH:MM [YYYY-mm-dd] 

noon, midnight, teatime(4pm) 

tomorrow 

now+#{minutes,hours,days, OR weeks} </code></pre><h4 id="at时间格式"><a href="#at时间格式" class="headerlink" title="at时间格式"></a>at时间格式</h4><p>HH:MM 02:00 </p>
<pre><code>在今日的 HH:MM 进行,若该时刻已过,则明天此时执行任务 </code></pre><p>HH:MM YYYY-MM-DD 02:00 2016-09-20 </p>
<pre><code>规定在某年某月的某一天的特殊时刻进行该项任务 HH:MM[am|pm]/[Month]/[Date] 0

4pm March 17 

17:20 tomorrow </code></pre><p>HH:MM[am|pm] + number [minutes|hours|days|weeks]</p>
<pre><code>在某个时间点再加几个时间后才进行该项任务 

now + 5 min 

02pm + 3 days </code></pre><h4 id="at任务-1"><a href="#at任务-1" class="headerlink" title="at任务"></a>at任务</h4><p>执行方式: </p>
<pre><code>1)交互式 2)输入重定向 3)at –f 文件 </code></pre><p>依赖与atd服务,需要启动才能实现at任务 </p>
<p>at队列存放在/var/spool/at目录中 </p>
<p>/etc/at.{allow,deny}控制用户是否能执行at任务 </p>
<pre><code>白名单:/etc/at.allow 默认不存在,只有该文件中的用户才能执行at命令 

黑名单:/etc/at.deny 默认存在,拒绝该文件中用户执行at命令,而没有在 at.deny 文件中的使用者则可执行 

如果两个文件都不存在,只有 root 可以执行 at 命令 </code></pre><hr>
<h4 id="周期性任务计划-cron"><a href="#周期性任务计划-cron" class="headerlink" title="周期性任务计划 cron"></a>周期性任务计划 cron</h4><p>相关的程序包: </p>
<pre><code>cronie: 主程序包,提供crond守护进程及相关辅助工具 

cronie-anacron:cronie的补充程序,用于监控cronie任务执行状况,如 cronie中的任务在过去该运行的时间点未能正常运行,则anacron会随后启动一次 此任务 

crontabs:包含CentOS提供系统维护任务 </code></pre><h4 id="计划任务-1"><a href="#计划任务-1" class="headerlink" title="计划任务"></a>计划任务</h4><p>确保crond守护处于运行状态: </p>
<pre><code>CentOS 7: 

    systemctl status crond 

CentOS 6: 

    service crond status </code></pre><p>计划周期性执行的任务提交给crond,到指定时间会自动运行 </p>
<pre><code>系统cron任务:系统维护作业 

    /etc/crontab 

用户cron任务: 

    crontab命令 </code></pre><p>日志:/var/log/cron </p>
<p>系统cron任务:/etc/crontab<br>注释行以 # 开头<br>详情参见 man 5 crontab</p>
<p>#Example of job definition:</p>
<p>#.—————- minute (0 - 59)</p>
<p>#| .————- hour (0 - 23)</p>
<p>#| | .———- day of month (1 - 31)</p>
<p>#| | | .——- month (1 - 12) OR jan,feb,mar,apr …</p>
<p>#| | | | .—- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</p>
<p>#| | | | |</p>
<p>#* * * * * user-name command to be executed</p>
<p>例如:晚上9点10分运行echo命令<br>10 21 * * * wang /bin/echo “Howdy!”</p>
<p>时间表示法: </p>
<pre><code>(1) 特定值 给定时间点有效取值范围内的值 

(2) 给定时间点上有效取值范围内的所有值 表示“每...” 

(3) 离散取值 

   #,#,# 

(4) 连续取值 

   #-# 

(5) 在指定时间范围上,定义步长 

   /#: #即为步长 </code></pre><h4 id="时间格式"><a href="#时间格式" class="headerlink" title="时间格式"></a>时间格式</h4><p>@reboot         Run once after reboot </p>
<p>@yearly         0 0 1 1 * </p>
<p>@annually         0 0 1 1 * </p>
<p>@monthly         0 0 1 * * </p>
<p>@weekly         0 0 * * 0 </p>
<p>@daily         0 0 * * * </p>
<p>@hourly         0 * * * * </p>
<p>示例:每3小时echo和wall命令 </p>
<pre><code>0 */3 * * * centos /bin/echo “howdy”;/usr/bin/wall “show time!” </code></pre><p><strong>系统的计划任务</strong></p>
<p>/etc/crontab             配置文件 </p>
<p>/etc/cron.d/             配置文件 </p>
<p>/etc/cron.hourly/         脚本 </p>
<p>/etc/cron.daily/         脚本 </p>
<p>/etc/cron.weekly/     脚本 </p>
<p>/etc/cron.monthly/     脚本 </p>
<h4 id="anacron-系统"><a href="#anacron-系统" class="headerlink" title="anacron 系统"></a>anacron 系统</h4><p>运行计算机关机时cron不运行的任务,CentOS6以后版本取消anacron服务,由 crond服务管理 </p>
<p>对笔记本电脑、台式机、工作站、偶尔要关机的服务器及其它不一直开机的系统 很重要对很有用 </p>
<p>配置文件:/etc/anacrontab,负责执行/etc/ cron.daily /etc/cron.weekly /etc/cron.monthly中系统任务 </p>
<pre><code>• 字段1:如果在这些日子里没有运行这些任务…… 

• 字段2:在重新引导后等待这么多分钟后运行它 

• 字段3:任务识别器,在日志文件中标识 

• 字段4:要执行的任务 </code></pre><p>由/etc/cron.hourly/0anacron执行 </p>
<p>当执行任务时,更新/var/spool/anacron/cron.daily 文件的时间戳 </p>
<h4 id="管理临时文件"><a href="#管理临时文件" class="headerlink" title="管理临时文件"></a>管理临时文件</h4><p>CentOS6使用</p>
<pre><code>/etc/cron.daily/tmpwatch定时清除临时文件 </code></pre><p>CentOS7使用</p>
<pre><code>systemd-tmpfiles-setup服务实现 </code></pre><p>配置文件: </p>
<pre><code>/etc/tmpfiles.d/*.conf *

/run/tmpfiles.d/*.conf *

/usr/lib/tmpfiles/*.conf </code></pre><p>/usr/lib/tmpfiles.d/tmp.conf </p>
<pre><code>d /tmp 1777 root root 10d 

d /var/tmp 1777 root root 30d </code></pre><p>命令: </p>
<pre><code>systemd-tmpfiles –clean|remove|create configfile </code></pre><h4 id="用户计划任务"><a href="#用户计划任务" class="headerlink" title="用户计划任务"></a>用户计划任务</h4><p>crontab命令定义 </p>
<pre><code>每个用户都有专用的cron任务文件: 

    /var/spool/cron/USERNAME </code></pre><p>crontab命令: </p>
<pre><code>crontab [-u user]/[-l | -r | -e]/[-i] 

-l: 列出所有任务 

-e: 编辑任务 

-r: 移除所有任务 

-i:同-r一同使用,以交互式模式移除指定任务 

-u user: 仅root可运行,指定用户管理cron任务 </code></pre><p>控制用户执行计划任务: </p>
<pre><code>/etc/cron.{allow,deny} </code></pre><p><strong>at和crontab</strong></p>
<p>一次性作业使用 at </p>
<p>重复性作业使用crontab </p>
<p>Create         at time             crontab -e </p>
<p>List             at -l             crontab -l </p>
<p>Details         at -c jobnum     N/A </p>
<p>Remove         at -d jobnum     crontab -r </p>
<p>Edit         N/A             crontab -e </p>
<p>没有被重定向的输出会被邮寄给用户 </p>
<p>root能够修改其它用户的作业 </p>
<p>注意:运行结果的标准输出和错误以邮件通知给相关用户 </p>
<pre><code>(1) COMMAND &gt; /dev/null 

(2) COMMAND &amp;&gt; /dev/null </code></pre><p>对于cron任务来讲,%有特殊用途;如果在命令中要使用%,则需要转义,将% 放置于单引号中,则可不用转义 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/Linux-%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1-%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mark_avatar.png">
      <meta itemprop="name" content="Mark">
      <meta itemprop="description" content="半吊子民工 英特纳雄耐尔就一定要实现">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mark blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Linux-%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1-%E4%BA%8C/" class="post-title-link" itemprop="url">Linux 中的进程和计划任务(二)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-10-31 21:40:47" itemprop="dateCreated datePublished" datetime="2015-10-31T21:40:47+08:00">2015-10-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-02 23:46:24" itemprop="dateModified" datetime="2019-01-02T23:46:24+08:00">2019-01-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%B5%B7%E6%8B%BE%E8%B4%9D/" itemprop="url" rel="index"><span itemprop="name">学海拾贝</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Linux-中系统资源的管理"><a href="#Linux-中系统资源的管理" class="headerlink" title="Linux 中系统资源的管理"></a>Linux 中系统资源的管理</h2><h3 id="进程管理工具"><a href="#进程管理工具" class="headerlink" title="进程管理工具"></a>进程管理工具</h3><h4 id="top-命令"><a href="#top-命令" class="headerlink" title="top 命令"></a>top 命令</h4><p>top:有许多内置命令 </p>
<p>​    排序: </p>
<p>​        P:以占据的CPU百分比,%CPU </p>
<p>​        M:占据内存百分比,%MEM </p>
<p>​        T:累积占据CPU时长,TIME+ </p>
<p>​    首部信息显示: </p>
<p>​        uptime信息:l命令 </p>
<p>​        tasks及cpu信息:t命令 </p>
<p>​        cpu分别显示:1 (数字) </p>
<p>​        memory信息:m命令 </p>
<p>​    退出命令:q </p>
<p>​    修改刷新时间间隔:s </p>
<p>​    终止指定进程:k </p>
<p>​    保存文件:W </p>
<h4 id="top-命令栏位简介"><a href="#top-命令栏位简介" class="headerlink" title="top 命令栏位简介"></a>top 命令栏位简介</h4><p>​    us:用户空间 </p>
<p>​    sy:内核空间 </p>
<p>​    ni:调整nice时间 </p>
<p>​    id:空闲 </p>
<p>​    wa:等待IO时间 </p>
<p>​    hi:硬中断 </p>
<p>​    si:软中断(模式切换) </p>
<p>​    st:虚拟机偷走的时间 </p>
<h4 id="top命令扩展"><a href="#top命令扩展" class="headerlink" title="top命令扩展"></a>top命令扩展</h4><p>选项: </p>
<p>​    -d # 指定刷新时间间隔，默认为3秒 </p>
<p>​    -b 全部显示所有进程 </p>
<p>​    -n # 刷新多少次后退出 </p>
<p>​    -H 线程模式，示例:top -H -p `pidof mysqld`</p>
<p>htop命令:EPEL源 </p>
<p>​    选项: </p>
<p>​        -d #: 指定延迟时间；</p>
<p>​        -u UserName: 仅显示指定用户的进程 </p>
<p>​        -s COLUME: 以指定字段进行排序 </p>
<p>​    子命令: </p>
<p>​        s:跟踪选定进程的系统调用 </p>
<p>​        l:显示选定进程打开的文件列表 </p>
<p>​        a:将选定的进程绑定至某指定CPU核心 </p>
<p>​        t:显示进程树 </p>
<hr>
<h3 id="内存空间管理"><a href="#内存空间管理" class="headerlink" title="内存空间管理"></a>内存空间管理</h3><h4 id="查看内存空间的使用状态"><a href="#查看内存空间的使用状态" class="headerlink" title="查看内存空间的使用状态:"></a>查看内存空间的使用状态:</h4><p>free [OPTION] </p>
<p>​    -b 以字节为单位 </p>
<p>​    -m 以MB为单位 </p>
<p>​    -g 以GB为单位 </p>
<p>​    -h 易读格式 </p>
<p>​    -o 不显示-/+buffers/cache行 </p>
<p>​    -t 显示RAM + swap的总和 </p>
<p>​    -s n 刷新间隔为n秒 </p>
<p>​    -c n 刷新n次后即退出 </p>
<p>free命令中参数的意义:</p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/images/post_Linux_Network_1.png" alt=""></p>
<hr>
<h3 id="内存工具"><a href="#内存工具" class="headerlink" title="内存工具"></a>内存工具</h3><h4 id="vmstat命令"><a href="#vmstat命令" class="headerlink" title="vmstat命令"></a>vmstat命令</h4><p>vmstat命令:</p>
<p>​    查看虚拟内存信息 </p>
<p>​    vmstat [options]/[delay [count]] </p>
<p>​    vmstat 2 5  </p>
<p><strong>vmstat参数:</strong></p>
<p>procs: </p>
<p>​    r:可运行(正运行或等待运行)进程的个数，和核心数有关 </p>
<p>​    b:处于不可中断睡眠态的进程个数(被阻塞的队列的长度) </p>
<p>memory: </p>
<p>​    swpd: 交换内存的使用总量 </p>
<p>​    free:空闲物理内存总量 </p>
<p>​    buffer:用于buffer的内存总量 </p>
<p>​    cache:用于cache的内存总量 </p>
<p>swap: </p>
<p>​    si:从磁盘交换进内存的数据速率(kb/s) </p>
<p>​    so:从内存交换至磁盘的数据速率(kb/s) 内存工具 </p>
<p>io: </p>
<p>​    bi:从块设备读入数据到系统的速率(kb/s) </p>
<p>​    bo: 保存数据至块设备的速率 </p>
<p>system: </p>
<p>​    in: interrupts 中断速率，包括时钟 </p>
<p>​    cs: context switch 进程切换速率 </p>
<p>cpu: </p>
<p>​    us:Time spent running non-kernel code </p>
<p>​    sy: Time spent running kernel code </p>
<p>​    id: Time spent idle. Linux 2.5.41前,包括IO-wait time. </p>
<p>​    wa: Time spent waiting for IO. 2.5.41前，包括in idle. </p>
<p>​    st: Time stolen from a virtual machine. 2.6.11前, unknown. </p>
<p>选项:</p>
<p>​     -s: 显示内存的统计数据 </p>
<h4 id="其他内存工具"><a href="#其他内存工具" class="headerlink" title="其他内存工具"></a>其他内存工具</h4><p>iostat:统计CPU和设备IO信息 </p>
<p>​    示例:iostat 1 10 </p>
<p>pmap命令:进程对应的内存映射 </p>
<p>pmap [options] pid […] </p>
<p>​    -x: 显示详细格式的信息 </p>
<p>​    示例:pmap 1 </p>
<p>另外一种实现: </p>
<p>​    cat /proc/PID/maps </p>
<hr>
<h3 id="系统监控工具"><a href="#系统监控工具" class="headerlink" title="系统监控工具"></a>系统监控工具</h3><h4 id="glances-命令"><a href="#glances-命令" class="headerlink" title="glances 命令"></a>glances 命令</h4><p>glances属于第三方EPEL源中的工具</p>
<p>glances [-bdehmnrsvyz1]/[-B bind]/[-c server]/[-C conffile]/[-p port]/[-P password]/[– password]/[-t refresh]/[-f file]/[-o output]</p>
<p>内建命令: </p>
<p>a Sort processes automatically        l Show/hide logs </p>
<p>c Sort processes by CPU%             b Bytes or bits for network I/O </p>
<p>m Sort processes by MEM%         w Delete warning logs </p>
<p>p Sort processes by name             x Delete warning and critical logs </p>
<p>i Sort processes by I/O rate         1 Global CPU or per-CPU stats </p>
<p>d Show/hide disk I/O stats         h Show/hide this help screen </p>
<p>f Show/hide file system stats         t View network I/O as combination </p>
<p>n Show/hide network stats         u View cumulative network I/O </p>
<p>s Show/hide sensors stats             q Quit (Esc and Ctrl-C also work) </p>
<p>y Show/hide hddtemp stats </p>
<p>部分选项解释:</p>
<p>​    -b: 以Byte为单位显示网卡数据速率 </p>
<p>​    -d: 关闭磁盘I/O模块 </p>
<p>​    -f /path/to/somefile: 设定输入文件位置 </p>
<p>​    -o {HTML|CSV}:输出格式 </p>
<p>​    -m: 禁用mount模块 </p>
<p>​    -n: 禁用网络模块 </p>
<p>​    -t #: 延迟时间间隔 </p>
<p>​    -1:每个CPU的相关数据单独显示 </p>
<p>*<em>C/S模式下运行glances命令 *</em></p>
<p>服务器模式: </p>
<p>​    glances -s -B IPADDR </p>
<p>​    IPADDR: 指明监听的本机哪个地址 </p>
<p>客户端模式: </p>
<p>​    glances -c IPADDR </p>
<p>​    IPADDR:要连入的服务器端地址 </p>
<h4 id="dstat-命令"><a href="#dstat-命令" class="headerlink" title="dstat 命令"></a>dstat 命令</h4><p>dstat命令:系统资源统计,代替vmstat,iostat,需要使用yum安装 </p>
<p>dstat [-afv]/[options..]/[delay [count]] </p>
<p>​    -c 显示cpu相关信息 </p>
<p>​    -C #,#,…,total </p>
<p>​    -d 显示disk相关信息 </p>
<p>​    -D total,sda,sdb,… </p>
<p>​    -g 显示page相关统计数据 </p>
<p>​    -m 显示memory相关统计数据 </p>
<p>​    -n 显示network相关统计数据 </p>
<p>​    -p 显示process相关统计数据 </p>
<p>​    -r 显示io请求相关的统计数据 </p>
<p>​    -s 显示swapped相关的统计数据 </p>
<p>​    –tcp </p>
<p>​    –udp </p>
<p>​    –unix </p>
<p>​    –raw </p>
<p>​    –socket </p>
<p>​    –ipc </p>
<p>​    –top-cpu:显示最占用CPU的进程 </p>
<p>​    –top-io: 显示最占用io的进程 </p>
<p>​    –top-mem: 显示最占用内存的进程 </p>
<p>​    –top-latency: 显示延迟最大的进程 </p>
<h4 id="iotop"><a href="#iotop" class="headerlink" title="iotop"></a>iotop</h4><p>iotop命令是一个用来监视磁盘I/O使用状况的top类工具iotop具有与top相似的UI，其中包括 PID、用户、I/O、进程等相关信息，可查看每个进程是如何使用IO </p>
<p>iotop输出 </p>
<p>​    第一行:Read和Write速率总计 </p>
<p>​    第二行:实际的Read和Write速率 </p>
<p>​    第三行:</p>
<p>​        参数如下: </p>
<p>​            线程ID(按p切换为进程ID) </p>
<p>​            优先级 </p>
<p>​            用户 </p>
<p>​            磁盘读速率 </p>
<p>​            磁盘写速率 </p>
<p>​            swap交换百分比 </p>
<p>​            IO等待所占的百分比 </p>
<p>​            线程/进程命令 </p>
<p><strong>iotop 常用参数</strong></p>
<p>​    -o, –only只显示正在产生I/O的进程或线程，除了传参，可以在运行过程中按o 生效 </p>
<p>​    -b, –batch非交互模式，一般用来记录日志 </p>
<p>​    -n NUM, –iter=NUM设置监测的次数，默认无限。在非交互模式下很有用 </p>
<p>​    -d SEC, –delay=SEC设置每次监测的间隔，默认1秒，接受非整形数据例如1.1 </p>
<p>​    -p PID, –pid=PID指定监测的进程/线程 </p>
<p>​    -u USER, –user=USER指定监测某个用户产生的I/O </p>
<p>​    -P, –processes仅显示进程，默认iotop显示所有线程 </p>
<p>​    -a, –accumulated显示累积的I/O，而不是带宽 </p>
<p>​    -k, –kilobytes使用kB单位，而不是对人友好的单位。在非交互模式下，脚本 编程有用 </p>
<p>​    -t, –time 加上时间戳，非交互非模式 </p>
<p>​    -q, –quiet 禁止头几行，非交互模式，有三种指定方式 </p>
<p>​    -q 只在第一次监测时显示列名 </p>
<p>​    -qq 永远不显示列名 </p>
<p>​    -qqq 永远不显示I/O汇总 </p>
<p><strong>iotop 交互按键</strong></p>
<p>​    left和right方向键:改变排序 </p>
<p>​    r:反向排序 </p>
<p>​    o:切换至选项–only </p>
<p>​    p:切换至–processes选项 </p>
<p>​    a:切换至–accumulated选项 </p>
<p>​    q:退出 </p>
<p>​    i:改变线程的优先级 </p>
<h4 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h4><p>Lsof:list open files查看当前系统文件的工具。在linux环境下，一切皆文件，用户通 过文件不仅可以访问常规数据，还可以访问网络连接和硬件如传输控制协议 (TCP) 和 用户数据报协议 (UDP)套接字等，系统在后台都为该应用程序分配了一个文件描述符</p>
<p><strong>命令参数</strong> </p>
<p>​    -a:列出打开文件存在的进程 </p>
<p>​    -c&lt;进程名&gt;:列出指定进程所打开的文件 </p>
<p>​    -g:列出GID号进程详情 </p>
<p>​    -d&lt;文件号&gt;:列出占用该文件号的进程 </p>
<p>​    +d&lt;目录&gt;:列出目录下被打开的文件 </p>
<p>​    +D&lt;目录&gt;:递归列出目录下被打开的文件 </p>
<p>​    -n&lt;目录&gt;:列出使用NFS的文件 </p>
<p>​    -i&lt;条件&gt;:列出符合条件的进程(4、6、协议、:端口、 @ip ) </p>
<p>​    -p&lt;进程号&gt;:列出指定进程号所打开的文件 </p>
<p>​    -u:列出UID号进程详情 </p>
<p>​    -h:显示帮助信息 </p>
<p>​    -v:显示版本信息。 </p>
<p>​    -n: 不反向解析网络名字 </p>
<p><strong>进程管理</strong></p>
<p>查看由登陆用户启动而非系统启动的进程 </p>
<p>​    lsof /dev/pts1 </p>
<p>指定进程号，可以查看该进程打开的文件 </p>
<p>​    lsof -p 9527 </p>
<p><strong>文件管理</strong> </p>
<p>查看指定程序打开的文件 </p>
<p>​    lsof -c httpd </p>
<p>查看指定用户打开的文件 </p>
<p>​    lsof -u root | more </p>
<p>查看指定目录下被打开的文件 </p>
<p>​    lsof +D /var/log/ </p>
<p>​    lsof +d /var/log/ </p>
<p>​    参数+D为递归列出目录下被打开的文件，参数+d为列出目录下被打开的文件 </p>
<p><strong>网络管理</strong> </p>
<p>查看所有网络连接 </p>
<p>​    lsof -i –n lsof <a href="mailto:-i@127.0.0.1">-i@127.0.0.1</a> </p>
<p>​    通过参数-i查看网络连接的情况，包括连接的ip、端口等以及一些服务的连接情况，例如: sshd等。也可以通过指定ip查看该ip的网络连接情况 </p>
<p>查看端口连接情况 </p>
<p>​    lsof -i :80 -n </p>
<p>​    通过参数-i:端口可以查看端口的占用情况，-i参数还有查看协议，ip的连接情况等 </p>
<p>查看指定进程打开的网络连接 </p>
<p>​    lsof -i –n -a -p 9527 </p>
<p>​    参数-i、-a、-p等，-i查看网络连接情况，-a查看存在的进程，-p指定进程 </p>
<p>查看指定状态的网络连接 </p>
<p>​    lsof -n -P -i TCP -s TCP:ESTABLISHED </p>
<p>​    -n:no host names, -P:no port names,-i TCP指定协议，-s指定协议状态通过多个参数可以 清晰的查看网络连接情况、协议连接情况等 </p>
<p><strong>恢复删除文件</strong> </p>
<p>​    lsof |grep /var/log/messages </p>
<p>​    rm -f /var/log/messages </p>
<p>​    lsof |grep /var/log/messages </p>
<p>​    cat /proc/653/fd/6 </p>
<p>​    cat /proc/653/fd/6 &gt; /var/log/messages </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/Linux-%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1-%E4%B8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mark_avatar.png">
      <meta itemprop="name" content="Mark">
      <meta itemprop="description" content="半吊子民工 英特纳雄耐尔就一定要实现">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mark blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Linux-%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1-%E4%B8%80/" class="post-title-link" itemprop="url">Linux 中的进程和计划任务(一)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-10-28 20:05:09" itemprop="dateCreated datePublished" datetime="2015-10-28T20:05:09+08:00">2015-10-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-02 23:53:28" itemprop="dateModified" datetime="2019-01-02T23:53:28+08:00">2019-01-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%B5%B7%E6%8B%BE%E8%B4%9D/" itemprop="url" rel="index"><span itemprop="name">学海拾贝</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Linux-中进程的查看"><a href="#Linux-中进程的查看" class="headerlink" title="Linux 中进程的查看"></a>Linux 中进程的查看</h2><h3 id="进程的相关概念"><a href="#进程的相关概念" class="headerlink" title="进程的相关概念"></a>进程的相关概念</h3><p>内核的功用:进程管理、文件系统、网络功能、内存管理、驱动程序、安全功能等 </p>
<p>Process: 运行中的程序的一个副本,是被载入内存的一个指令集合 </p>
<p>​    进程ID(Process ID,PID)号码被用来标记各个进程UID、GID、和SELinux语境决定对文件系统的存取和访问权限,通常从执行进程的用户来继承存在生命周期 </p>
<p>task struct:Linux内核存储进程信息的数据结构格式 </p>
<p>task list:多个任务的的task struct组成的链表 </p>
<p>进程创建: </p>
<p>​    init:第一个进程 </p>
<p>​    进程:都由其父进程创建,父子关系,CoW fork(), clone() </p>
<h4 id="进程的基本状态和转换"><a href="#进程的基本状态和转换" class="headerlink" title="进程的基本状态和转换"></a>进程的基本状态和转换</h4><p><strong>创建状态:</strong></p>
<p>​    进程在创建时需要申请一个空白PCB(process control block进程控 制块),向其中填写控制和管理进程的信息,完成资源分配.如果创建工作无法完 成,比如资源无法满足,就无法被调度运行,把此时进程所处状态称为创建状态 </p>
<p><strong>就绪状态:</strong></p>
<p>​    进程已准备好,已分配到所需资源,只要分配到CPU就能够立即运行 </p>
<p><strong>执行状态:</strong></p>
<p>​    进程处于就绪状态被调度后,进程进入执行状态 </p>
<p><strong>阻塞状态:</strong></p>
<p>​    正在执行的进程由于某些事件(I/O请求,申请缓存区失败)而暂时 无法运行,进程受到阻塞.在满足请求时进入就绪状态等待系统调用 </p>
<p><strong>终止状态:</strong></p>
<p>​    进程结束,或出现错误,或被系统终止,进入终止状态.无法再执行 </p>
<h4 id="进程之间转换六种情况"><a href="#进程之间转换六种情况" class="headerlink" title="进程之间转换六种情况"></a>进程之间转换六种情况</h4><p>运行——&gt;就绪:</p>
<p>​    1,主要是进程占用CPU的时间过长,而系统分配给该进程占 用CPU的时间是有限的:</p>
<p>​    2,在采用抢先式优先级调度算法的系统中,当有更高 优先级的进程要运行时,该进程就被迫让出CPU,该进程便由执行状态转变为 就绪状态 </p>
<p>就绪——&gt;运行:运行的进程的时间片用完,调度就转到就绪队列中选择合适 的进程分配CPU </p>
<p>运行——&gt;阻塞:正在执行的进程因发生某等待事件而无法执行,则进程由执 行状态变为阻塞状态,如发生了I/O请求 </p>
<p>阻塞——&gt;就绪:进程所等待的事件已经发生,就进入就绪队列 </p>
<p>以下两种状态是不可能发生的: </p>
<p>​    阻塞——&gt;运行:即使给阻塞进程分配CPU,也无法执行,操作系统在进行调 度时不会从阻塞队列进行挑选,而是从就绪队列中选取 </p>
<p>​    就绪——&gt;阻塞:就绪态根本就没有执行,谈不上进入阻塞态 </p>
<h4 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h4><p>进程优先级: </p>
<p>​    系统优先级:数字越小,优先级越高 </p>
<p>​        0-139(CentOS4,5) </p>
<p>​            各有140个运行队列和过期队列 </p>
<p>​        0-98,99(CentOS6) </p>
<p>​    实时优先级: 99-0 值最大优先级最高 </p>
<p>​    nice值:-20到19,对应系统优先级100-139或99 </p>
<p>Big O:时间复杂度,用时和规模的关系 </p>
<p>​    O(1), O(logn), O(n)线性, O(n^2)抛物线, O(2^n) </p>
<h4 id="进程相关概念"><a href="#进程相关概念" class="headerlink" title="进程相关概念"></a>进程相关概念</h4><p>进程内存: </p>
<p>​    Page Frame: 页框,用存储页面数据,存储Page 4k </p>
<p>​    LRU:Least Recently Used 近期最少使用算法,释放内存物理地址空间和线性地址空间 </p>
<p>​    MMU:Memory Management Unit负责转换线性和物理地址 </p>
<p>​    TLB:Translation Lookaside Buffer 翻译后备缓冲器,用于保存虚拟地址和物理地址映射关系的缓存 </p>
<p>IPC: Inter Process Communication </p>
<p>​    同一主机:</p>
<p>​        signal:信号 </p>
<p>​        shm: shared memory </p>
<p>​        semaphore:信号量,一种计数器 </p>
<p>​    不同主机:</p>
<p>​        socket: IP和端口号 </p>
<p>​        RPC: remote procedure call </p>
<p>​        MQ:消息队列,Kafka,ActiveMQ </p>
<h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p>Linux内核:抢占式多任务 </p>
<p>进程类型: </p>
<p>​    守护进程: daemon,在系统引导过程中启动的进程,和终端无关进程 </p>
<p>​    前台进程:跟终端相关,通过终端启动的进程 </p>
<p>​    注意:两者可相互转化 </p>
<p>进程状态: </p>
<p>​    运行态:running </p>
<p>​    就绪态:ready </p>
<p>​    睡眠态: </p>
<p>​        可中断:interruptable </p>
<p>​        不可中断:uninterruptable </p>
<p>​    停止态:stopped,暂停于内存,但不会被调度,除非手动启动 </p>
<p>​    僵死态:zombie,结束进程,父进程结束前,子进程不关闭 </p>
<hr>
<h3 id="系统管理工具"><a href="#系统管理工具" class="headerlink" title="系统管理工具"></a>系统管理工具</h3><p>进程的分类: </p>
<p>​    CPU-Bound:CPU密集型,非交互 </p>
<p>​    IO-Bound:IO密集型,交互 </p>
<p>Linux系统状态的查看及管理工具:pstree, ps, pidof, pgrep, top, htop, glance, pmap, vmstat, dstat, kill, pkill, job, bg, fg, nohup </p>
<p>pstree命令: </p>
<p>​    pstree - display a tree of processes </p>
<p>ps: process state </p>
<p>​    ps - report a snapshot of the current processes </p>
<p>​    Linux系统各进程的相关信息均保存在/proc/PID目录下的各文件中 </p>
<h4 id="查看系统进程-ps"><a href="#查看系统进程-ps" class="headerlink" title="查看系统进程 ps"></a>查看系统进程 ps</h4><p>ps [OPTION]… </p>
<p>支持三种选项: </p>
<p>​    UNIX选项 如-A -e </p>
<p>​    BSD选项 如a </p>
<p>​    GNU选项 如–help </p>
<p>• 选项:默认显示当前终端中的进程 </p>
<p>• a 选项包括所有终端中的进程 </p>
<p>• x 选项包括不链接终端的进程 </p>
<p>• u 选项显示进程所有者的信息 </p>
<p>• f 选项显示进程树,相当于 –forest </p>
<p>• k|–sort 属性 对属性排序,属性前加- 表示倒序 </p>
<p>• o 属性… 选项显示定制的信息 pid、cmd、%cpu、%mem </p>
<p>• L 显示支持的属性列表 </p>
<h5 id="ps常见选项"><a href="#ps常见选项" class="headerlink" title="ps常见选项"></a>ps常见选项</h5><p>-C cmdlist 指定命令,多个命令用,分隔 </p>
<p>-L 显示线程 </p>
<p>-e: 显示所有进程,相当于-A </p>
<p>-f: 显示完整格式程序信息 </p>
<p>-F: 显示更完整格式的进程信息 </p>
<p>-H: 以进程层级格式显示进程相关信息 </p>
<p>-u userlist 指定有效的用户ID或名称 </p>
<p>-U userlist 指定真正的用户ID或名称 </p>
<p>-g gid或groupname 指定有效的gid或组名称 </p>
<p>-G gid或groupname 指定真正的gid或组名称 </p>
<p>-p pid 显示指pid的进程 </p>
<p>–ppid pid 显示属于pid的子进程 </p>
<p>-M 显示SELinux信息,相当于Z </p>
<h5 id="ps输出属性"><a href="#ps输出属性" class="headerlink" title="ps输出属性"></a>ps输出属性</h5><p>VSZ: Virtual memory SiZe,虚拟内存集,线性内存 </p>
<p>RSS: ReSident Size, 常驻内存集 </p>
<p>STAT:进程状态 </p>
<p>​    R:running </p>
<p>​    S: interruptable sleeping </p>
<p>​    D: uninterruptable sleeping </p>
<p>​    T: stopped </p>
<p>​    Z: zombie </p>
<p>​    +: 前台进程 </p>
<p>​    l: 多线程进程 </p>
<p>​    L:内存分页并带锁 </p>
<p>​    N:低优先级进程 </p>
<p>​    &lt;: 高优先级进程 </p>
<p>​    s: session leader,会话(子进程)发起者 </p>
<h4 id="ps-输出及常见示例"><a href="#ps-输出及常见示例" class="headerlink" title="ps 输出及常见示例"></a>ps 输出及常见示例</h4><p>ni: nice值 </p>
<p>pri: priority 优先级 </p>
<p>psr: processor CPU编号 </p>
<p>rtprio: 实时优先级 </p>
<p>示例: </p>
<p>​    ps axo pid,cmd,psr,ni,pri,rtprio </p>
<p>常用组合: </p>
<p>​    aux </p>
<p>​    -ef </p>
<p>​    -eFH </p>
<p>​    -eo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,comm </p>
<p>​    axo stat,euid,ruid,tty,tpgid,sess,pgrp,ppid,pid,pcpu,comm </p>
<h5 id="ps示例"><a href="#ps示例" class="headerlink" title="ps示例"></a>ps示例</h5><p>查询你拥有的所有进程: </p>
<p>​    ps -x </p>
<p>显示指定用户名(RUID)或用户ID的进程: </p>
<p>​    ps -fU apache </p>
<p>​    ps -fu 48 </p>
<p>显示指定用户名(EUID)或用户ID的进程: </p>
<p>​    ps -fu mark </p>
<p>​    ps -fu 1000 </p>
<p>查看以root用户权限(实际和有效ID)运行的每个进程: </p>
<p>​    ps -U root -u root </p>
<p>列出某个组拥有的所有进程(实际组ID,RGID或名称): </p>
<p>​    ps -fG nginx </p>
<p>列出有效组名称(或会话)所拥有的所有进程: </p>
<p>​    ps -fg mysql </p>
<p>​    ps -fG 27 </p>
<p>通过进程ID来显示所属的进程: </p>
<p>​    ps -fp 1234 </p>
<p>以父进程ID来显示其下所有的进程,如显示父进程为1154的所有进程: </p>
<p>​    ps -f –ppid 1234 </p>
<p>显示指定PID的多个进程: </p>
<p>​    ps -fp 1204,1239,1263 </p>
<p>要按tty显示所属进程: </p>
<p>​    ps -ft pst/0 </p>
<p>以进程树显示系统中的进程如何相互链接: </p>
<p>​    ps -e –forest </p>
<p>以进程树显示指定的进程 </p>
<p>​    ps -f –forest -C sshd </p>
<p>​    ps -ef –forest | grep -v grep | grep sshd </p>
<p>要显示一个进程的所有线程,将显示LWP(轻量级进程)以及NLWP(轻量级进 程数)列: </p>
<p>​    ps -fL -C nginx </p>
<p>要列出所有格式说明符: </p>
<p>​    ps L </p>
<p>查看进程的PID,PPID,用户名和命令: </p>
<p>​    ps -eo pid,ppid,user,cmd </p>
<p>自定义格式显示文件系统组,ni值开始时间和进程的时间: </p>
<p>​    ps -p 1234 -o pid,ppid,fgroup,ni,lstart,etime </p>
<p>使用其PID查找进程名称: </p>
<p>​    ps -p 1244 -o comm= </p>
<p>要以其名称选择特定进程,显示其所有子进程 </p>
<p>​    ps -C sshd,bash </p>
<p>查找指定进程名所有的所属PID,在编写需要从std输出或文件读取PID的脚本时 这个参数很有用: </p>
<p>​    ps -C httpd,sshd -o pid= </p>
<p>检查一个进程的执行时间 </p>
<p>​    ps -eo comm,etime,user | grep nginx </p>
<p>查找占用最多内存和CPU的进程: </p>
<p>​    ps -eo pid,ppid,cmd,%mem,%cpu –sort=-%mem | head</p>
<p>​    ps -eo pid,ppid,cmd,%mem,%cpu –sort=-%cpu | head </p>
<p>显示安全信息: </p>
<p>​    ps -eM </p>
<p>​    ps –context </p>
<p>使用以下命令以用户定义的格式显示安全信息. </p>
<p>​    ps -eo euser,ruser,suser,fuser,f,comm,label </p>
<p>使用watch实用程序执行重复的输出以实现对就程进行实时的监视,如下面的命 令显示每秒钟的监视: </p>
<p>​    watch -n 1 ‘ps -eo pid,ppid,cmd,%mem,%cpu –sort=-%mem | head’ </p>
<hr>
<h3 id="进程优先级-1"><a href="#进程优先级-1" class="headerlink" title="进程优先级"></a>进程优先级</h3><p>进程优先级调整: </p>
<p>​    静态优先级:100-139 </p>
<p>​    进程默认启动时的nice值为0,优先级为120 </p>
<p>​    只有根用户才能降低nice值(提高优先性) </p>
<p>nice命令: </p>
<p>​    nice [OPTION]/[COMMAND /[ARG]…] </p>
<p>renice命令: </p>
<p>​    renice [-n] priority pid… </p>
<p>查看: </p>
<p>​    ps axo pid,comm,ni </p>
<h4 id="搜索进程"><a href="#搜索进程" class="headerlink" title="搜索进程"></a>搜索进程</h4><p>最灵活:</p>
<p>​    ps 选项 | 其它命令 </p>
<p>按预定义的模式:pgrep </p>
<p>​    pgrep [options] pattern </p>
<p>​    -u uid: effective user,生效者 </p>
<p>​    -U uid: real user,真正发起运行命令者 </p>
<p>​    -t terminal: 与指定终端相关的进程 </p>
<p>​    -l: 显示进程名 </p>
<p>​    -a: 显示完整格式的进程名 </p>
<p>​    -P pid: 显示指定进程的子进程 </p>
<p>按确切的程序名称:/sbin/pidof </p>
<p>​    pidof bash </p>
<h4 id="系统工具"><a href="#系统工具" class="headerlink" title="系统工具"></a>系统工具</h4><p><strong>uptime</strong></p>
<p>显示当前时间,系统已启动的时间、当前上线人数,系统平均负载(1、5、10 分钟的平均负载,一般不会超过1) </p>
<p>系统平均负载: </p>
<p>指在特定时间间隔内运行队列中的平均进程数 </p>
<p>通常每个CPU内核的当前活动进程数不大于3,那么系统的性能良好.如果每 个CPU内核的任务数大于5,那么此主机的性能有严重问题 </p>
<p>如果linux主机是1个双核CPU,当Load Average 为6的时候说明机器已经被 充分使用 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/Linux-%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E4%B8%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mark_avatar.png">
      <meta itemprop="name" content="Mark">
      <meta itemprop="description" content="半吊子民工 英特纳雄耐尔就一定要实现">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mark blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Linux-%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E4%B8%89/" class="post-title-link" itemprop="url">Linux 磁盘存储和文件系统(三)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-10-25 20:56:34" itemprop="dateCreated datePublished" datetime="2015-10-25T20:56:34+08:00">2015-10-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-02 23:53:03" itemprop="dateModified" datetime="2019-01-02T23:53:03+08:00">2019-01-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%B5%B7%E6%8B%BE%E8%B4%9D/" itemprop="url" rel="index"><span itemprop="name">学海拾贝</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="LVM"><a href="#LVM" class="headerlink" title="LVM"></a>LVM</h3><p>允许对卷进行方便操作的抽象层,包括重新设定文件系统的大小 </p>
<p>允许在多个物理设备间重新组织文件系统 </p>
<p>​    • 将设备指定为物理卷 </p>
<p>​    • 用一个或者多个物理卷来创建一个卷组 </p>
<p>​    • 物理卷是用固定大小的物理区域(Physical Extent,PE)来定义的 </p>
<p>​    • 在物理卷上创建的逻辑卷 是由物理区域(PE)组成 </p>
<p>​    • 可以在逻辑卷上创建文件系统 </p>
<h4 id="LVM介绍"><a href="#LVM介绍" class="headerlink" title="LVM介绍"></a>LVM介绍</h4><p>LVM: Logical Volume Manager, Version: 2 </p>
<p>dm: device mapper:将一个或多个底层块设备组织成一个逻辑设备的模块 </p>
<p>设备名:/dev/dm-# </p>
<p>软链接: </p>
<p>​    /dev/mapper/VG_NAME-LV_NAME </p>
<p>​        /dev/mapper/vol0-root </p>
<p>​    /dev/VG_NAME/LV_NAME </p>
<p>​        /dev/vol0/root </p>
<h4 id="pv管理工具"><a href="#pv管理工具" class="headerlink" title="pv管理工具"></a>pv管理工具</h4><p>显示pv信息 </p>
<p>​    pvs:简要pv信息显示 </p>
<p>​    pvdisplay </p>
<p>创建pv </p>
<p>​    pvcreate </p>
<p>​    /dev/DEVICE </p>
<h4 id="vg管理工具"><a href="#vg管理工具" class="headerlink" title="vg管理工具"></a>vg管理工具</h4><p>显示卷组 </p>
<p>​    vgs </p>
<p>​    vgdisplay </p>
<p>创建卷组 </p>
<p>​    vgcreate [-s #[kKmMgGtTpPeE]] VolumeGroupName </p>
<p>​    PhysicalDevicePath [PhysicalDevicePath…] </p>
<p>管理卷组 </p>
<p>​    vgextend VolumeGroupName PhysicalDevicePath [PhysicalDevicePath…] </p>
<p>​    vgreduce VolumeGroupName PhysicalDevicePath [PhysicalDevicePath…] </p>
<p>删除卷组 </p>
<p>​    先做pvmove,</p>
<p>​    再做vgremove </p>
<h4 id="lv管理工具"><a href="#lv管理工具" class="headerlink" title="lv管理工具"></a>lv管理工具</h4><p>显示逻辑卷 </p>
<p>​    lvs </p>
<p>​    Lvdisplay </p>
<p>创建逻辑卷 </p>
<p>​    lvcreate -L #[mMgGtT] -n NAME VolumeGroup </p>
<p>​    lvcreate -l 60%VG -n mylv testvg </p>
<p>​    lvcreate -l 100%FREE -n yourlv testvg </p>
<p>删除逻辑卷 </p>
<p>​    lvremove /dev/VG_NAME/LV_NAME </p>
<p>重设文件系统大小 </p>
<p>​    fsadm [options] resize device [new_size[BKMGTEP]] </p>
<p>​    resize2fs [-f]/[-F]/[-M]/[-P]/[-p] device [new_size]</p>
<h4 id="扩展和缩减逻辑卷"><a href="#扩展和缩减逻辑卷" class="headerlink" title="扩展和缩减逻辑卷"></a>扩展和缩减逻辑卷</h4><p>扩展逻辑卷: </p>
<p>​    lvextend -L [+]#[mMgGtT] /dev/VG_NAME/LV_NAME </p>
<p>​    resize2fs /dev/VG_NAME/LV_NAME </p>
<p>​    lvresize -r -l +100%FREE /dev/VG_NAME/LV_NAME </p>
<p>缩减逻辑卷: </p>
<p>​    umount /dev/VG_NAME/LV_NAME </p>
<p>​    e2fsck -f /dev/VG_NAME/LV_NAME </p>
<p>​    resize2fs /dev/VG_NAME/LV_NAME #[mMgGtT] </p>
<p>​    lvreduce -L [-]#[mMgGtT] /dev/VG_NAME/LV_NAME </p>
<p>​    mount </p>
<h4 id="跨主机迁移卷组"><a href="#跨主机迁移卷组" class="headerlink" title="跨主机迁移卷组"></a>跨主机迁移卷组</h4><p>源计算机上 </p>
<p>​    1 在旧系统中,umount所有卷组上的逻辑卷 </p>
<p>​    2 vgchange –a n vg0 lvdisplay </p>
<p>​    3 vgexport vg0 </p>
<p>​        pvscan </p>
<p>​        vgdisplay </p>
<p>​        拆下旧硬盘 </p>
<p> 在目标计算机上 </p>
<p>​    4 在新系统中安装旧硬盘,并vgimport vg0. </p>
<p>​    5 vgchange –ay vg0 </p>
<p>​    6 mount所有卷组上的逻辑卷 </p>
<h4 id="创建逻辑卷示例"><a href="#创建逻辑卷示例" class="headerlink" title="创建逻辑卷示例"></a>创建逻辑卷示例</h4><p>创建物理卷 </p>
<p>​    pvcreate /dev/sda3 </p>
<p>为卷组分配物理卷 </p>
<p>​    vgcreate vg0 /dev/sda3 </p>
<p>从卷组创建逻辑卷 </p>
<p>​    lvcreate -L 256M -n data vg0 </p>
<p>​    mke2fs -j /dev/vg0/data </p>
<p>mount /dev/vg0/data /mnt/data </p>
<h4 id="逻辑卷管理器快照"><a href="#逻辑卷管理器快照" class="headerlink" title="逻辑卷管理器快照"></a>逻辑卷管理器快照</h4><p>快照是特殊的逻辑卷,它是在生成快照时存在的逻辑卷的准确拷贝 </p>
<p>对于需要备份或者复制的现有数据临时拷贝以及其它操作来说,快照是最合适 的选择 </p>
<p>快照只有在它们和原来的逻辑卷不同时才会消耗空间 </p>
<p>​    在生成快照时会分配给它一定的空间,但只有在原来的逻辑卷或者快照有所 改变才会使用这些空间 </p>
<p>​    当原来的逻辑卷中有所改变时,会将旧的数据复制到快照中。 </p>
<p>​    快照中只含有原来的逻辑卷中更改的数据或者自生成快照后的快照中更改的 数据 </p>
<p>​    建立快照的卷大小只需要原始逻辑卷的15%～20%就够了,也可以使用 lvextend放大快照 </p>
<h4 id="逻辑卷管理器快照-1"><a href="#逻辑卷管理器快照-1" class="headerlink" title="逻辑卷管理器快照"></a>逻辑卷管理器快照</h4><p>快照就是将当时的系统信息记录下来,就好像照相一般,若将来有任何数据 改动了,则原始数据会被移动到快照区,没有改动的区域则由快照区和文件 系统共享 </p>
<p>由于快照区与原本的LV共用很多PE的区块,因此快照与被快照的LV必须在同 一个VG中.系统恢复的时候的文件数量不能高于快照区的实际容量 </p>
<h4 id="使用LVM快照"><a href="#使用LVM快照" class="headerlink" title="使用LVM快照"></a>使用LVM快照</h4><p>为现有逻辑卷创建快照 </p>
<p>​    lvcreate -l 64 -s -n data-snapshot -p r /dev/vg0/data </p>
<p>挂载快照 </p>
<p>​    mkdir -p /mnt/snap </p>
<p>​    mount -o ro /dev/vg0/data-snapshot /mnt/snap </p>
<p>恢复快照 </p>
<p>​    umount /dev/vg0/data-snapshot </p>
<p>​    umount /dev/vg0/data </p>
<p>​    lvconvert –merge /dev/vg0/data-snapshot </p>
<p>删除快照 </p>
<p>​    umount /mnt/databackup </p>
<p>​    lvremove /dev/vg0/databackup </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Mark"
      src="/images/mark_avatar.png">
  <p class="site-author-name" itemprop="name">Mark</p>
  <div class="site-description" itemprop="description">半吊子民工 英特纳雄耐尔就一定要实现</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:markupzh@gmail.com" title="E-Mail → mailto:markupzh@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mark</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
