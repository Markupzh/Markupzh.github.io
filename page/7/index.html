<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/M_32px.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/M_16px.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":7,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="半吊子民工 英特纳雄耐尔就一定要实现">
<meta property="og:type" content="website">
<meta property="og:title" content="Mark blog">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="Mark blog">
<meta property="og:description" content="半吊子民工 英特纳雄耐尔就一定要实现">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Mark">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Mark blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Mark blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">知行合一 划水归档</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/Linux-%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mark_avatar.png">
      <meta itemprop="name" content="Mark">
      <meta itemprop="description" content="半吊子民工 英特纳雄耐尔就一定要实现">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mark blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Linux-%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E4%BA%8C/" class="post-title-link" itemprop="url">Linux 磁盘存储和文件系统(二)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-10-20 20:51:40" itemprop="dateCreated datePublished" datetime="2015-10-20T20:51:40+08:00">2015-10-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-02 23:42:18" itemprop="dateModified" datetime="2019-01-02T23:42:18+08:00">2019-01-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%B5%B7%E6%8B%BE%E8%B4%9D/" itemprop="url" rel="index"><span itemprop="name">学海拾贝</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="挂载-mount"><a href="#挂载-mount" class="headerlink" title="挂载 mount"></a>挂载 mount</h3><p>挂载:将额外文件系统与根文件系统某现存的目录建立起关联关系,进而使得此 目录做为其它文件访问入口的行为 </p>
<p>卸载:为解除此关联关系的过程 </p>
<p>把设备关联挂载点:mount Point </p>
<p>​    mount </p>
<p>卸载时:可使用设备,也可以使用挂载点 </p>
<p>​    umount </p>
<p>挂载点下原有文件在挂载完成后会被临时隐藏 </p>
<p>挂载点目录一般为空 </p>
<h4 id="用mount命令挂载文件系统"><a href="#用mount命令挂载文件系统" class="headerlink" title="用mount命令挂载文件系统"></a>用mount命令挂载文件系统</h4><p>挂载方法:mount DEVICE MOUNT_POINT </p>
<p>mount:通过查看/etc/mtab文件显示当前已挂载的所有设备 </p>
<p>mount [-fnrsvw]/[-t vfstype]/[-o options] device dir </p>
<p>​    device:指明要挂载的设备； </p>
<p>​    (1) 设备文件:例如/dev/sda5 </p>
<p>​    (2) 卷标:-L ‘LABEL’, 例如 -L ‘MYDATA’ </p>
<p>​    (3) UUID, -U ‘UUID’:例如 -U ‘0c50523c-43f1-45e7- 85c0-a126711d406e’ </p>
<p>​    (4) 伪文件系统名称:proc, sysfs, devtmpfs, configfs </p>
<p>​    dir:挂载点 </p>
<p>​        事先存在；建议使用空目录 </p>
<p>​        进程正在使用中的设备无法被卸载 </p>
<h4 id="mount-常用命令选项"><a href="#mount-常用命令选项" class="headerlink" title="mount 常用命令选项"></a>mount 常用命令选项</h4><p>-t vsftype:指定要挂载的设备上的文件系统类型 </p>
<p>-r: readonly,只读挂载 </p>
<p>-w: read and write, 读写挂载 </p>
<p>-n: 不更新/etc/mtab,mount不可见 </p>
<p>-a:自动挂载所有支持自动挂载的设备(定义在了/etc/fstab文件中,且挂载选 项中有auto功能) </p>
<p>-L ‘LABEL’: 以卷标指定挂载设备 </p>
<p>-U ‘UUID’: 以UUID指定要挂载的设备 </p>
<p>-B, –bind: 绑定目录到另一个目录上 </p>
<p>查看内核追踪到的已挂载的所有设备 </p>
<p>​    cat /proc/mounts </p>
<p> -o options:(挂载文件系统的选项),多个选项使用逗号分隔 </p>
<p>​    async:异步模式 sync:同步模式,内存更改时,同时写磁盘 </p>
<p>​    atime/noatime:包含目录和文件 </p>
<p>​    diratime/nodiratime:目录的访问时间戳 </p>
<p>​    auto/noauto:是否支持自动挂载,是否支持-a选项 </p>
<p>​    exec/noexec:是否支持将文件系统上运行应用程序 </p>
<p>​    dev/nodev:是否支持在此文件系统上使用设备文件 </p>
<p>​    suid/nosuid:是否支持suid和sgid权限 </p>
<p>​    remount:重新挂载 </p>
<p>​    ro:只读 rw:读写 </p>
<p>​    user/nouser:是否允许普通用户挂载此设备,/etc/fstab使用 </p>
<p>​    acl:启用此文件系统上的acl功能 </p>
<p>​    loop: 使用loop设备 </p>
<p> defaults:相当于rw, suid, dev, exec, auto, nouser, async </p>
<h4 id="卸载命令"><a href="#卸载命令" class="headerlink" title="卸载命令"></a>卸载命令</h4><p>查看挂载情况 </p>
<p>​    findmnt MOUNT_POINT|device </p>
<p>查看正在访问指定文件系统的进程 </p>
<p>​    lsof MOUNT_POINT </p>
<p>​    fuser -v MOUNT_POINT </p>
<p>终止所有在正访问指定的文件系统的进程 </p>
<p>​    fuser -km MOUNT_POINT </p>
<p>卸载 </p>
<p>​    umount DEVICE </p>
<p>​    umount MOUNT_POINT </p>
<h4 id="挂载点和-etc-fstab"><a href="#挂载点和-etc-fstab" class="headerlink" title="挂载点和/etc/fstab"></a>挂载点和/etc/fstab</h4><p>配置文件系统体系 </p>
<p>被mount、fsck和其它程序使用 </p>
<p>系统重启时保留文件系统体系 </p>
<p>可以在设备栏使用文件系统卷标 </p>
<p>使用mount -a 命令挂载/etc/fstab中的所有文件系统 </p>
<h4 id="文件挂载配置文件"><a href="#文件挂载配置文件" class="headerlink" title="文件挂载配置文件"></a>文件挂载配置文件</h4><p> /etc/fstab每行定义一个要挂载的文件系统 </p>
<p> 1、要挂载的设备或伪文件系统 </p>
<p>​    设备文件 </p>
<p>​    LABEL:LABEL=”” </p>
<p>​    UUID:UUID=”” </p>
<p>​    伪文件系统名称:proc, sysfs </p>
<p> 2、挂载点 </p>
<p> 3、文件系统类型:ext4,xfs,nfs,none </p>
<p> 4、挂载选项:defaults ,acl,bind </p>
<p> 5、转储频率:</p>
<p>​    0:不做备份 </p>
<p>​    1:每天转储 </p>
<p>​    2:每隔一天转储 </p>
<p> 6、fsck检查的文件系统的顺序:允许的数字是0, 1, 和2 </p>
<p>​    0:不自检 </p>
<p>​    1:首先自检；一般只有rootfs才用 </p>
<p>​    2:非rootfs使用 </p>
<h4 id="处理交换文件和分区"><a href="#处理交换文件和分区" class="headerlink" title="处理交换文件和分区"></a>处理交换文件和分区</h4><p>交换分区是系统RAM的补充 </p>
<p>基本设置包括: </p>
<p>​    • 创建交换分区或者文件 </p>
<p>​    • 使用mkswap写入特殊签名 </p>
<p>​    • 在/etc/fstab文件中添加适当的条目 </p>
<p>​    • 使用swapon -a 激活交换空间 </p>
<h4 id="挂载交换分区"><a href="#挂载交换分区" class="headerlink" title="挂载交换分区"></a>挂载交换分区</h4><p>启用:swapon </p>
<p>​    swapon [OPTION]… [DEVICE] </p>
<p>​        -a:激活所有的交换分区 </p>
<p>​        -p PRIORITY:指定优先级 </p>
<p>​        /etc/fstab:pri=value </p>
<p>禁用:swapoff [OPTION]… [DEVICE] </p>
<h4 id="SWAP的优先级"><a href="#SWAP的优先级" class="headerlink" title="SWAP的优先级"></a>SWAP的优先级</h4><p>可以指定swap分区0到32767的优先级,值越大优先级越高 </p>
<p>如果用户没有指定,那么核心会自动给swap指定一个优先级,这个优先级从 -1开始,每加入一个新的没有用户指定优先级的swap,会给这个优先级减一 </p>
<p>先添加的swap的缺省优先级比较高,除非用户自己指定一个优先级,而用户 指定的优先级(是正数)永远高于核心缺省指定的优先级(是负数) </p>
<p>优化性能:分布存放,高性能磁盘存放 </p>
<h3 id="移动介质"><a href="#移动介质" class="headerlink" title="移动介质"></a>移动介质</h3><p>挂载意味着使外来的文件系统看起来如同是主目录树的一部分 </p>
<p>访问前、介质必须被挂载 </p>
<p>摘除时,介质必须被卸载 </p>
<p>按照默认设置,非根用户只能挂载某些设备（光盘、DVD、软 盘、USB等等） </p>
<p>挂载点通常在/media 或/mnt下 </p>
<h3 id="使用光盘"><a href="#使用光盘" class="headerlink" title="使用光盘"></a>使用光盘</h3><p>在图形环境下自动启动挂载/run/media/[lable]/[lable] </p>
<p>否则就必须被手工挂载 </p>
<p>​    mount /dev/cdrom /mnt/ </p>
<p>eject命令卸载或弹出磁盘 </p>
<p>创建ISO文件 </p>
<p>​    cp /dev/cdrom /root/centos7.iso </p>
<p>​    mkisofs -r -o /root/etc.iso /etc </p>
<p>刻录光盘 </p>
<p>​    wodim –v –eject centos.iso </p>
<h3 id="挂载USB介质"><a href="#挂载USB介质" class="headerlink" title="挂载USB介质"></a>挂载USB介质</h3><p>查看USB设备是否识别 </p>
<p>​    • lsusb </p>
<p>被内核探测为SCSI设备 </p>
<p>​    • /dev/sdaX、/dev/sdbX、或类似的设备文件 </p>
<p>在图形环境中自动挂载 </p>
<p>​    • 图标在[计算机]窗口中创建 </p>
<p>​    • 挂载在/run/media// </p>
<p>手动挂载 • mount /dev/sdb1 /mn </p>
<h4 id="常见工具"><a href="#常见工具" class="headerlink" title="常见工具"></a>常见工具</h4><p>文件系统空间占用等信息的查看工具: </p>
<p>​    df [OPTION]… [FILE]… </p>
<p>​    -H 以1000为单位 </p>
<p>​    -T 文件系统类型 </p>
<p>​    -h: human-readable </p>
<p>​    -i:inodes instead of blocks </p>
<p>​    -P: 以Posix兼容的格式输出 </p>
<p>查看某目录总体空间占用状态: </p>
<p>​    du [OPTION]… DIR </p>
<p>​    -h: human-readable </p>
<p>​    -s: summary –max-depth </p>
<h4 id="工具dd"><a href="#工具dd" class="headerlink" title="工具dd"></a>工具dd</h4><p> dd命令:convert and copy a file </p>
<p> 用法: </p>
<p>​    dd if=/PATH/FROM/SRC of=/PATH/TO/DEST </p>
<p>​    bs=#:block size, 复制单元大小 </p>
<p>​    count=#:复制多少个bs </p>
<p>​    of=file 写到所命名的文件而不是到标准输出 </p>
<p>​    if=file 从所命名文件读取而不是从标准输入 </p>
<p>​    bs=size 指定块大小（既是是ibs也是obs) </p>
<p>​    ibs=size 一次读size个byte </p>
<p>​    obs=size 一次写size个byte </p>
<p>​    cbs=size 一次转化size个byte </p>
<p>​    skip=blocks 从开头忽略blocks个ibs大小的块 </p>
<p>​    seek=blocks 从开头忽略blocks个obs大小的块 </p>
<p>​    count=n 只拷贝n个记录 </p>
<p>conv=conversion[,conversion…] 用指定的参数转换文件 </p>
<p>转换参数: </p>
<p>ascii 转换 EBCDIC 为 ASCII </p>
<p>ebcdic 转换 ASCII 为 EBCDIC </p>
<p>lcase 把大写字符转换为小写字符 </p>
<p>ucase 把小写字符转换为大写字符 </p>
<p>nocreat 不创建输出文件 </p>
<p>noerror 出错时不停止 </p>
<p>notrunc 不截短输出文件 </p>
<p>sync 把每个输入块填充到ibs个字节,不足部分用空(NUL)字符补齐 </p>
<p>备份MBR: </p>
<p>​    dd if=/dev/sda of=/tmp/mbr.bak bs=512 count=1 </p>
<p>破坏MBR中的bootloader: </p>
<p>​    dd if=/dev/zero of=/dev/sda bs=64 count=1 seek=446 </p>
<p>有一个大与2K的二进制文件fileA。现在想从第64个字节位置开始读取,需要读 取的大小是128Byts。又有fileB, 想把上面读取到的128Bytes写到第32个字节开 始的位置,替换128Bytes,实现如下: </p>
<p>​    dd if=fileA of=fileB bs=1 count=128 skip=63 seek=31 conv=notrunc </p>
<p>备份: </p>
<p>​    dd if=/dev/sdx of=/dev/sdy </p>
<p>​    将本地的/dev/sdx整盘备份到/dev/sdy </p>
<p>​    dd if=/dev/sdx of=/path/to/image </p>
<p>​    将/dev/sdx全盘数据备份到指定路径的image文件 </p>
<p>​    dd if=/dev/sdx | gzip &gt;/path/to/image.gz </p>
<p>​    备份/dev/sdx全盘数据,并利用gzip压缩,保存到指定路径 </p>
<p>恢复: </p>
<p>​    dd if=/path/to/image of=/dev/sdx </p>
<p>​    将备份文件恢复到指定盘 </p>
<p>​    gzip -dc /path/to/image.gz | dd of=/dev/sdx </p>
<p>​    将压缩的备份文件恢复到指定盘 </p>
<p>拷贝内存资料到硬盘 </p>
<p>​    dd if=/dev/mem of=/root/mem.bin bs=1024 </p>
<p>将内存里的数据拷贝到root目录下的mem.bin文件 </p>
<p>从光盘拷贝iso镜像 </p>
<p>​    dd if=/dev/cdrom of=/root/cd.iso </p>
<p>拷贝光盘数据到root文件夹下,并保存为cd.iso文件 </p>
<p>销毁磁盘数据 </p>
<p>​    dd if=/dev/urandom of=/dev/sda1 </p>
<p>利用随机的数据填充硬盘,在某些必要的场合可以用来销毁数据,执行此操作以后, /dev/sda1将无法挂载,创建和拷贝操作无法执行 </p>
<p>得到最恰当的block size </p>
<p>​    dd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file </p>
<p>​    dd if=/dev/zero bs=2048 count=500000 of=/root/1Gb.file </p>
<p>​    dd if=/dev/zero bs=4096 count=250000 of=/root/1Gb.file </p>
<p>通过比较dd指令输出中命令的执行时间,即可确定系统最佳的block size大小 </p>
<p>测试硬盘写速度 </p>
<p>​    dd if=/dev/zero of=/root/1Gb.file bs=1024 count=1000000 </p>
<p>测试硬盘读速度 </p>
<p>​    dd if=/root/1Gb.file bs=64k | dd of=/dev/null </p>
<p>修复硬盘 </p>
<p>​    dd if=/dev/sda of=/dev/sda </p>
<p>当硬盘较长时间（比如1,2年）放置不使用后,磁盘上会产生消磁点。当磁头读 到这些区域时会遇到困难,并可能导致I/O错误。当这种情况影响到硬盘的第一 个扇区时,可能导致硬盘报废。上边的命令有可能使这些数据起死回生,且这个 过程是安全高效的 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/Linux-%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E4%B8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mark_avatar.png">
      <meta itemprop="name" content="Mark">
      <meta itemprop="description" content="半吊子民工 英特纳雄耐尔就一定要实现">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mark blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Linux-%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E4%B8%80/" class="post-title-link" itemprop="url">Linux 磁盘存储和文件系统(一)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-10-15 20:51:31" itemprop="dateCreated datePublished" datetime="2015-10-15T20:51:31+08:00">2015-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-02 23:41:39" itemprop="dateModified" datetime="2019-01-02T23:41:39+08:00">2019-01-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%B5%B7%E6%8B%BE%E8%B4%9D/" itemprop="url" rel="index"><span itemprop="name">学海拾贝</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="设备文件"><a href="#设备文件" class="headerlink" title="设备文件"></a>设备文件</h4><p>I/O Ports: I/O设备地址 </p>
<p>一切皆文件:open(), read(), write(), close() </p>
<p>设备类型: </p>
<pre><code>块设备:block,存取单位“块”,磁盘 

字符设备:char,存取单位“字符”,键盘 </code></pre><p>设备文件:</p>
<pre><code>关联至一个设备驱动程序,进而能够跟与之对应硬件设备进行通信 </code></pre><p>设备号码: </p>
<pre><code>主设备号:major number, 标识设备类型 

次设备号:minor number, 标识同一类型下的不同设备 </code></pre><p>磁盘设备的设备文件命名:/dev/DEV_FILE </p>
<p>SCSI, SATA, SAS, IDE,USB: /dev/sd </p>
<p>虚拟磁盘:/dev/vd </p>
<p>不同磁盘标识:a-z,aa,ab… </p>
<pre><code>/dev/sda, /dev/sdb, ... </code></pre><p>同一设备上的不同分区:1,2, … </p>
<pre><code>/dev/sda1, /dev/sda5 </code></pre><p>硬盘存储术语 </p>
<pre><code>head:磁头 

track:磁道 

cylinder: 柱面 

sector: 扇区,512bytes </code></pre><h4 id="CHS和LBA"><a href="#CHS和LBA" class="headerlink" title="CHS和LBA"></a>CHS和LBA</h4><p>CHS </p>
<pre><code>采用24bit位寻址 

其中前10位表示cylinder,中间8位表示head,后面6位表示sector 

最大寻址空间8GB </code></pre><p>LBA(logical block addressing) </p>
<p>​    LBA是一个整数,通过转换成CHS格式完成磁盘具体寻址 </p>
<pre><code>LBA采用48个bit位寻址 

最大寻址空间128PB </code></pre><p>由于CHS寻址方式的寻址空间在大概8GB以内,所以在磁盘容量小于大概8GB 时,可以使用CHS寻址方式或是LBA寻址方式;在磁盘容量大于大概8GB时,则 只能使用LBA寻址方式 </p>
<h4 id="使用分区空间"><a href="#使用分区空间" class="headerlink" title="使用分区空间"></a>使用分区空间</h4><p>设备识别 </p>
<p>设备分区 </p>
<p>创建文件系统 </p>
<p>标记文件系统 </p>
<p>在/etc/fstab文件中创建条目 </p>
<p>挂载新的文件系统 </p>
<h3 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h3><h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h4><p>两种分区方式:MBR,GPT </p>
<p>MBR: Master Boot Record,1982年,使用32位表示扇区数,分区不超过2T </p>
<p>如何分区:按柱面 </p>
<p>0磁道0扇区:512bytes </p>
<pre><code>446bytes: boot loader 

64bytes:分区表 

    16bytes: 标识一个分区 

2bytes: 55AA </code></pre><p>4个主分区;3主分区+1扩展(N个逻辑分区) </p>
<h4 id="MBR分区结构"><a href="#MBR分区结构" class="headerlink" title="MBR分区结构"></a>MBR分区结构</h4><p>硬盘主引导记录MBR由4个部分组成 </p>
<p>主引导程序(偏移地址0000H–0088H),它负责从活动分区中装载,并运行 系统引导程序 </p>
<p>出错信息数据区,偏移地址0089H–00E1H为出错信息,00E2H–01BDH全为 0字节 </p>
<p>分区表(DPT,Disk Partition Table)含4个分区项,偏移地址01BEH–01FDH, 每个分区表项长16个字节,共64字节为分区项1、分区项2、分区项3、分区项4 </p>
<p>结束标志字,偏移地址01FE–01FF的2个字节值为结束标志55AA </p>
<h4 id="GPT分区"><a href="#GPT分区" class="headerlink" title="GPT分区"></a>GPT分区</h4><p>GPT:GUID(Globals Unique Identifiers) partition table 支持128个分区, 使用64位,支持8Z( 512Byte/block )64Z ( 4096Byte/block) </p>
<p>使用128位UUID(Universally Unique Identifier) 表示磁盘和分区 GPT分区表 自动备份在头和尾两份,并有CRC校验位 </p>
<p>UEFI (统一扩展固件接口)硬件支持GPT,使操作系统启动 </p>
<h3 id="管理分区"><a href="#管理分区" class="headerlink" title="管理分区"></a>管理分区</h3><p>列出块设备 </p>
<pre><code>• lsblk </code></pre><p>创建分区使用: </p>
<pre><code>• fdisk 创建MBR分区 

• gdisk 创建GPT分区 </code></pre><p>​    • parted 高级分区操作 </p>
<p>partprobe－重新设置内存中的内核分区表版本 </p>
<h4 id="parted命令"><a href="#parted命令" class="headerlink" title="parted命令"></a>parted命令</h4><p>parted的操作都是实时生效的,小心使用 </p>
<p>用法:parted [选项]… [设备 [命令 [参数]…]…] </p>
<pre><code>parted /dev/sdb mklabel gpt|msdos 

parted /dev/sdb print 

parted /dev/sdb mkpart primary 1 200 (默认M) 

parted /dev/sdb rm 1 

parted –l 列出分区信息 </code></pre><h4 id="分区工具fdisk和gdisk"><a href="#分区工具fdisk和gdisk" class="headerlink" title="分区工具fdisk和gdisk"></a>分区工具fdisk和gdisk</h4><p>gdisk /dev/sdb 类fdisk 的GPT分区工具 </p>
<pre><code>fdisk -l [ -u]/[device...] 查看分区 

fdisk /dev/sdb 管理分区 

子命令: 

    p 分区列表 

    t 更改分区类型 

    n 创建新分区 

    d 删除分区 

    v 校验分区 

    u 转换单位 

    w 保存并退出 

    q 不保存并退出 </code></pre><h4 id="同步分区表"><a href="#同步分区表" class="headerlink" title="同步分区表"></a>同步分区表</h4><p>查看内核是否已经识别新的分区: </p>
<pre><code>cat /proc/partations </code></pre><p>centos6通知内核重新读取硬盘分区表 </p>
<pre><code>新增分区用 

partx -a /dev/DEVICE 

kpartx -a /dev/DEVICE -f: force 

删除分区用 

partx -d --nr M-N /dev/DEVICE </code></pre><p>CentOS 5,7: 使用partprobe </p>
<p>​    partprobe [/dev/DEVICE] </p>
<p>同步分区表的时候注意系统的版本,centOS 5,7 是相同的,但是6和以上两个版本都不一样</p>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>文件系统是操作系统用于明确存储设备或分区上的文件的方法和数据结构;即 在存储设备上组织文件的方法。操作系统中负责管理和存储文件信息的软件结 构称为文件管理系统,简称文件系统 </p>
<p>从系统角度来看,文件系统是对文件存储设备的空间进行组织和分配,负责文 件存储并对存入的文件进行保护和检索的系统。具体地说,它负责为用户建立 文件,存入、读出、修改、转储文件,控制文件的存取,安全控制,日志,压 缩,加密等 </p>
<p>支持的文件系统:</p>
<pre><code>/lib/modules/\`uname –r`/kernel/fs </code></pre><p>各种文件系统: </p>
<pre><code>https://en.wikipedia.org/wiki/Comparison_of_file_systems </code></pre><h4 id="文件系统类型"><a href="#文件系统类型" class="headerlink" title="文件系统类型"></a>文件系统类型</h4><p> Linux文件系统: </p>
<pre><code>ext2(Extended file system) :适用于那些分区容量不是太大,更新也不频繁的情况,例如 /boot 分区。 

ext3:是 ext2 的改进版本,其支持日志功能,能够帮助系统从非正常关机导致的异常中 恢复。它通常被用作通用的文件系统 

ext4:是 ext 文件系统的最新版。提供了很多新的特性,包括纳秒级时间戳、创建和使 用巨型文件(16TB)、最大1EB的文件系统,以及速度的提升 

xfs:SGI,支持最大8EB的文件系统 

btrfs(Oracle), reiserfs, jfs(AIX), swap </code></pre><p> 光盘:iso9660 </p>
<p> Windows:FAT32, exFAT,NTFS </p>
<p> Unix: FFS(fast), UFS(unix), JFS2 </p>
<p> 网络文件系统:NFS, CIFS </p>
<p> 集群文件系统:GFS2, OCFS2(oracle) </p>
<p> 分布式文件系统: fastdfs,ceph, moosefs, mogilefs, glusterfs, Lustre </p>
<p> RAW:未经处理或者未经格式化产生的文件系统 </p>
<h4 id="文件系统分类"><a href="#文件系统分类" class="headerlink" title="文件系统分类"></a>文件系统分类</h4><p>根据其是否支持”journal”功能: </p>
<pre><code>日志型文件系统: ext3, ext4, xfs, ... 

非日志型文件系统: ext2, vfat </code></pre><p>文件系统的组成部分: </p>
<pre><code>内核中的模块:ext4, xfs, vfat 

用户空间的管理工具:mkfs.ext4, mkfs.xfs,mkfs.vfat </code></pre><p>Linux的虚拟文件系统:VFS </p>
<p>查前支持的文件系统:cat /proc/filesystems </p>
<h4 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h4><p>mkfs命令: </p>
<p>(1) mkfs.FS_TYPE /dev/DEVICE </p>
<pre><code>ext4 

xfs 

btrfs 

vfat </code></pre><p>(2) mkfs -t FS_TYPE /dev/DEVICE </p>
<pre><code>-L &apos;LABEL&apos;: 设定卷标 </code></pre><h4 id="创建ext文件系统"><a href="#创建ext文件系统" class="headerlink" title="创建ext文件系统"></a>创建ext文件系统</h4><p>mke2fs:ext系列文件系统专用管理工具 </p>
<pre><code>-t {ext2|ext3|ext4} 

-b {1024|2048|4096} 

-L &apos;LABEL&apos; 

-j: 相当于 -t ext3 

    mkfs.ext3 = mkfs -t ext3 = mke2fs -j = mke2fs -t ext3 

-i #: 为数据空间中每多少个字节创建一个inode;此大小不应该小于 block的大小 

-N #:指定分区中创建多少个inode 

-I 一个inode记录占用的磁盘空间大小,128---4096 

-m #: 默认5%,为管理人员预留空间占总空间的百分比 

-O FEATURE[,...]:启用指定特性 

-O ^FEATURE:关闭指定特性 </code></pre><h4 id="文件系统标签"><a href="#文件系统标签" class="headerlink" title="文件系统标签"></a>文件系统标签</h4><p>指向设备的另一种方法 </p>
<p>与设备无关 </p>
<p>blkid:块设备属性信息查看 </p>
<p>blkid [OPTION]… [DEVICE] </p>
<pre><code>-U UUID: 根据指定的UUID来查找对应的设备 

-L LABEL:根据指定的LABEL来查找对应的设备 </code></pre><p>e2label:管理ext系列文件系统的LABEL </p>
<pre><code>e2label DEVICE [LABEL] </code></pre><p>findfs :查找分区 </p>
<pre><code>findfs [options] LABEL= /&lt;/label/&gt;/

findfs [options] UUID= /&lt;/uuid/&gt;/</code></pre><h4 id="tune2fs"><a href="#tune2fs" class="headerlink" title="tune2fs"></a>tune2fs</h4><p>tune2fs:重新设定ext系列文件系统可调整参数的值 </p>
<pre><code>-l:查看指定文件系统超级块信息;super block 

-L &apos;LABEL&apos;:修改卷标 

-m #:修预留给管理员的空间百分比 

-j: 将ext2升级为ext3 

-O: 文件系统属性启用或禁用, –O ^has_journal 

-o: 调整文件系统的默认挂载选项,–o ^acl 

-U UUID: 修改UUID号 </code></pre><p>dumpe2fs: </p>
<pre><code>块分组管理,32768块 

-h:查看超级块信息,不显示分组信息 </code></pre><h4 id="文件系统检测和修复"><a href="#文件系统检测和修复" class="headerlink" title="文件系统检测和修复"></a>文件系统检测和修复</h4><p>常发生于死机或者非正常关机之后 </p>
<p>挂载为文件系统标记为“no clean” </p>
<p>注意:一定不要在挂载状态下修复 </p>
<p>fsck: File System Check </p>
<pre><code>fsck.FS_TYPE 

fsck -t FS_TYPE 

-p: 自动修复错误 

-r: 交互式修复错误 

FS_TYPE一定要与分区上已经文件类型相同 </code></pre><p>e2fsck:ext系列文件专用的检测修复工具 </p>
<pre><code>-y:自动回答为yes 

-f:强制修复 </code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/Linux-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mark_avatar.png">
      <meta itemprop="name" content="Mark">
      <meta itemprop="description" content="半吊子民工 英特纳雄耐尔就一定要实现">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mark blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Linux-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">Linux 软件包管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-09-10 20:48:27" itemprop="dateCreated datePublished" datetime="2015-09-10T20:48:27+08:00">2015-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-02 23:41:18" itemprop="dateModified" datetime="2019-01-02T23:41:18+08:00">2019-01-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%B5%B7%E6%8B%BE%E8%B4%9D/" itemprop="url" rel="index"><span itemprop="name">学海拾贝</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="软件运行和编译"><a href="#软件运行和编译" class="headerlink" title="软件运行和编译"></a>软件运行和编译</h3><p>ABI:Application Binary Interface </p>
<p>​    Windows与Linux不兼容 </p>
<p>​        ELF(Executable and Linkable Format) </p>
<p>​        PE（Portable Executable） </p>
<p>​    库级别的虚拟化: </p>
<p>​        Linux: WINE </p>
<p>​        Windows: Cygwin </p>
<p>API:Application Programming Interface </p>
<p>​    POSIX:Portable OS </p>
<p>程序源代码 –&gt; 预处理 –&gt; 编译 –&gt; 汇编 –&gt; 链接 </p>
<p>​    静态编译:.a </p>
<p>​    动态编译:.so </p>
<h4 id="静态和动态链接"><a href="#静态和动态链接" class="headerlink" title="静态和动态链接"></a>静态和动态链接</h4><p>链接主要作用是把各个模块之间相互引用的部分处理好,使得各个模块之间能 够正确地衔接,分为静态链接和动态链接 </p>
<p>静态链接 </p>
<p>​    把程序对应的依赖库复制一份到包 </p>
<p>​    libxxx.a </p>
<p>​    嵌入程序包 </p>
<p>​    升级难,需重新编译 </p>
<p>​    占用较多空间,迁移容易 </p>
<p>动态链接 </p>
<p>​    只把依赖加做一个动态链接 </p>
<p>​    libxxx.so </p>
<p>​    连接指向 </p>
<p>​    占用较少空间,升级方便 </p>
<h3 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h3><p>二进制应用程序的组成部分: </p>
<p>​    二进制文件、库文件、配置文件、帮助文件 </p>
<p>程序包管理器: </p>
<p>​    debian:deb文件,dpkg包管理器 </p>
<p>​    redhat:     rpm文件,rpm包管理器 </p>
<p>​    rpm:         Redhat Package Manager </p>
<p>​                RPM Package Manager </p>
<h4 id="包命名"><a href="#包命名" class="headerlink" title="包命名"></a>包命名</h4><p>源代码:name-VERSION.tar.gz|bz2|xz </p>
<p>​    VERSION: major.minor.release </p>
<p>rpm包命名方式: </p>
<p>​    name-VERSION-release.arch.rpm </p>
<p>​    例:bash-4.2.46-19.el7.x86_64.rpm </p>
<p>​    VERSION: major.minor.release </p>
<p>​    release:release.OS </p>
<p>​    常见的arch: </p>
<p>​    x86: i386,i486,i586,i686 </p>
<p>​    x86_64: x64,x86_64,amd64 </p>
<p>​    powerpc: ppc </p>
<p>​    跟平台无关:noarch </p>
<h4 id="包命名和工具"><a href="#包命名和工具" class="headerlink" title="包命名和工具"></a>包命名和工具</h4><p>包:分类和拆包 </p>
<p>​    Application-VERSION-ARCH.rpm: 主包 </p>
<p>​    Application-devel-VERSION-ARCH.rpm 开发子包 </p>
<p>​    Application-utils-VERSION-ARHC.rpm 其它子包 </p>
<p>​    Application-libs-VERSION-ARHC.rpm 其它子包 </p>
<p>包之间:可能存在依赖关系,甚至循环依赖 </p>
<p>解决依赖包管理工具: </p>
<p>​    yum:rpm包管理器的前端工具 </p>
<p>​    apt-get:deb包管理器前端工具 </p>
<p>​    zypper: suse上的rpm前端管理工具 </p>
<p>​    dnf: Fedora 18+ rpm包管理器前端管理工具</p>
<h4 id="库文件"><a href="#库文件" class="headerlink" title="库文件"></a>库文件</h4><p>查看二进制程序所依赖的库文件 </p>
<p>​    ldd /PATH/TO/BINARY_FILE </p>
<p>管理及查看本机装载的库文件 </p>
<p>​    ldconfig 加载库文件 </p>
<p>​    /sbin/ldconfig -p: 显示本机已经缓存的所有可用库文件名及文件路径 映射关系 </p>
<p>​    配置文件:/etc/ld.so.conf,/etc/ld.so.conf.d/*.conf </p>
<p>​    缓存文件:/etc/ld.so.cache </p>
<h4 id="包管理器-1"><a href="#包管理器-1" class="headerlink" title="包管理器"></a>包管理器</h4><p>程序包管理器: </p>
<p>​    功能:将编译好的应用程序的各组成文件打包一个或几个程序包文件,从而 方便快捷地实现程序包的安装、卸载、查询、升级和校验等管理操作 </p>
<p>包文件组成 (每个包独有) </p>
<p>​    RPM包内的文件 </p>
<p>​    RPM的元数据,如名称,版本,依赖性,描述等 </p>
<p>​    安装或卸载时运行的脚本 </p>
<p>数据库(公共):/var/lib/rpm </p>
<p>​    程序包名称及版本 </p>
<p>​    依赖关系 </p>
<p>​    功能说明 </p>
<p>​    包安装后生成的各文件路径及校验码信息 </p>
<h4 id="程序包的来源"><a href="#程序包的来源" class="headerlink" title="程序包的来源"></a>程序包的来源</h4><p>管理程序包的方式: </p>
<p>​    使用包管理器:rpm </p>
<p>​    使用前端工具:yum,dnf </p>
<p>获取程序包的途径: </p>
<p>​    (1) 系统发版的光盘或官方的服务器 </p>
<p>​        CentOS镜像: </p>
<p>​        <a href="https://www.centos.org/download/" target="_blank" rel="noopener">https://www.centos.org/download/</a> </p>
<p>​        <a href="http://mirrors.aliyun.com" target="_blank" rel="noopener">http://mirrors.aliyun.com</a> </p>
<p>​        <a href="http://mirrors.sohu.com" target="_blank" rel="noopener">http://mirrors.sohu.com</a> </p>
<p>​        <a href="http://mirrors.163.com" target="_blank" rel="noopener">http://mirrors.163.com</a> </p>
<p>​    (2) 项目官方站点 </p>
<p>​    (3) 第三方组织: </p>
<p>​        Fedora-EPEL: </p>
<p>​            Extra Packages for Enterprise Linux </p>
<p>​        Rpmforge:RHEL推荐,包很全 </p>
<p>​        搜索引擎: </p>
<p>​            <a href="http://pkgs.org" target="_blank" rel="noopener">http://pkgs.org</a> </p>
<p>​            <a href="http://rpmfind.net" target="_blank" rel="noopener">http://rpmfind.net</a> </p>
<p>​            <a href="http://rpm.pbone.net" target="_blank" rel="noopener">http://rpm.pbone.net</a> </p>
<p>​            <a href="https://sourceforge.net/" target="_blank" rel="noopener">https://sourceforge.net/</a> </p>
<p>​    (4) 自己制作 </p>
<p>​    注意:第三方包建议要检查其合法性 来源合法性,程序包的完整性 </p>
<h3 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h3><h4 id="rpm包管理"><a href="#rpm包管理" class="headerlink" title="rpm包管理"></a>rpm包管理</h4><p>CentOS系统上使用rpm命令管理程序包: </p>
<p>​    安装、卸载、升级、查询、校验、数据库维护 </p>
<p>​    安装: </p>
<p>​    rpm {-i|–install} [install-options] PACKAGE_FILE… </p>
<p>​        -v: verbose </p>
<p>​        -vv: </p>
<p>​        -h: 以#显示程序包管理执行进度 </p>
<p>​    rpm -ivh PACKAGE_FILE  </p>
<h4 id="rpm包安装"><a href="#rpm包安装" class="headerlink" title="rpm包安装"></a>rpm包安装</h4><p>[install-options] </p>
<p>​    –test: 测试安装,但不真正执行安装,即dry run模式 </p>
<p>​    –nodeps:忽略依赖关系 </p>
<p>​    –replacepkgs | replacefiles </p>
<p>​    –nosignature: 不检查来源合法性 </p>
<p>​    –nodigest:不检查包完整性 </p>
<p>​    –noscripts:不执行程序包脚本 </p>
<p>​        %pre: 安装前脚本     –nopre </p>
<p>​        %post: 安装后脚本 –nopost </p>
<p>​        %preun: 卸载前脚本 –nopreun </p>
<p>​        %postun: 卸载后脚本 –nopostun </p>
<h4 id="rpm包升级"><a href="#rpm包升级" class="headerlink" title="rpm包升级"></a>rpm包升级</h4><p>rpm {-U|–upgrade} [install-options] PACKAGE_FILE… </p>
<p>rpm {-F|–freshen} [install-options] PACKAGE_FILE…     </p>
<p>​    upgrade:安装有旧版程序包,则“升级” 如果不存在旧版程序包,则“安装” </p>
<p>​    freshen:安装有旧版程序包,则“升级” 如果不存在旧版程序包,则不执行升级操作 </p>
<p>​    rpm -Uvh PACKAGE_FILE … </p>
<p>​    rpm -Fvh PACKAGE_FILE … </p>
<p>​    –oldpackage:降级 </p>
<p>​    –force: 强制安装 </p>
<h4 id="升级注意事项"><a href="#升级注意事项" class="headerlink" title="升级注意事项"></a>升级注意事项</h4><p>(1) 不要对内核做升级操作；Linux支持多内核版本并存,因此,对直接安装新版本内核 </p>
<p>(2) 如果原程序包的配置文件安装后曾被修改,升级时,新版本的提供的同一个配 置文件并不会直接覆盖老版本的配置文件,而把新版本的文件重命名 (FILENAME.rpmnew)后保留 </p>
<h4 id="包查询"><a href="#包查询" class="headerlink" title="包查询"></a>包查询</h4><p>rpm {-q|–query} [select-options]/[query-options] </p>
<p>[select-options] </p>
<p>​    -a: 所有包 </p>
<p>​    -f: 查看指定的文件由哪个程序包安装生成 </p>
<p>​    -p rpmfile:针对尚未安装的程序包文件做查询操作 </p>
<p>​    –whatprovides CAPABILITY:查询指定的CAPABILITY由哪个包所提供 </p>
<p>​    –whatrequires CAPABILITY:查询指定的CAPABILITY被哪个包所依赖 </p>
<p>rpm2cpio 包文件|cpio –itv 预览包内文件 </p>
<p>rpm2cpio 包文件|cpio –id “*.conf” 释放包内文件 </p>
<p>[query-options] </p>
<p>​    –changelog:查询rpm包的changelog </p>
<p>​    -c: 查询程序的配置文件 </p>
<p>​    -d: 查询程序的文档 </p>
<p>​    -i: information </p>
<p>​    -l: 查看指定的程序包安装后生成的所有文件 </p>
<p>​    –scripts:程序包自带的脚本 </p>
<p>​    –provides: 列出指定程序包所提供的CAPABILITY </p>
<p>​    -R: 查询指定的程序包所依赖的CAPABILITY </p>
<p>常用查询用法: </p>
<p>​    -qi PACKAGE,</p>
<p>​    -qf FILE,</p>
<p>​    -qc PACKAGE,</p>
<p>​    -ql PACKAGE,</p>
<p>​    -qd PACKAGE </p>
<p>​    -qpi PACKAGE_FILE,</p>
<p>​    -qpl PACKAGE_FILE,… </p>
<p>​    -qa </p>
<p>包卸载: rpm {-e|–erase} [–allmatches]/[–nodeps]/[–noscripts]/[–notriggers]/[–test] PACKAGE_NAME … </p>
<h4 id="包校验"><a href="#包校验" class="headerlink" title="包校验"></a>包校验</h4><p>rpm {-V|–verify} [select-options]/[verify-options] </p>
<p>​    S file Size differs </p>
<p>​    M Mode differs (includes permissions and file type) </p>
<p>​    5 digest (formerly MD5 sum) differs </p>
<p>​    D Device major/minor number mismatch </p>
<p>​    L readLink(2) path mismatch </p>
<p>​    U User ownership differs </p>
<p>​    G Group ownership differs </p>
<p>​    T mTime differs </p>
<p>​    P capabilities differ </p>
<p>包来源合法性验正及完整性验正 </p>
<p>​    完整性验正:SHA256 </p>
<p>​    来源合法性验正:RSA </p>
<p> 公钥加密 </p>
<p>​    对称加密:加密、解密使用同一密钥 </p>
<p>​    非对称加密:密钥是成对儿的 </p>
<p>​        public key: 公钥,公开所有人 </p>
<p>​        secret key: 私钥,不能公开 </p>
<p> 导入所需要公钥 </p>
<p>​    rpm -K|checksig rpmfile 检查包的完整性和签名 </p>
<p>​    rpm –import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7         </p>
<p>​    CentOS 7发行版光盘提供:RPM-GPG-KEY-CentOS-7 </p>
<p>​    rpm -qa “gpg-pubkey*” </p>
<h4 id="rpm数据库"><a href="#rpm数据库" class="headerlink" title="rpm数据库"></a>rpm数据库</h4><p>数据库重建: </p>
<p>​    /var/lib/rpm </p>
<p>rpm {–initdb|–rebuilddb} </p>
<p>​    initdb: 初始化 </p>
<p>​        如果事先不存在数据库,则新建之 </p>
<p>​        否则,不执行任何操作 </p>
<p>​    rebuilddb:重建已安装的包头的数据库索引目录 </p>
<h3 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h3><h4 id="yum包管理"><a href="#yum包管理" class="headerlink" title="yum包管理"></a>yum包管理</h4><p>CentOS: yum,dnf </p>
<p>YUM: Yellowdog Update Modifier,rpm的前端程序,可解决软件包相关依 赖性,可在多个库之间定位软件包,up2date的替代工具 </p>
<p>​    yum repository: yum repo,存储了众多rpm包,以及包的相关的元数据文件（放置于特定目录repodata下） </p>
<p>​    文件服务器: </p>
<p>​        http:// </p>
<p>​        https:// </p>
<p>​        ftp:// </p>
<p>​        file:// </p>
<h4 id="yum配置文件"><a href="#yum配置文件" class="headerlink" title="yum配置文件"></a>yum配置文件</h4><p>yum客户端配置文件: </p>
<p>​    /etc/yum.conf:为所有仓库提供公共配置     </p>
<p>​    /etc/yum.repos.d/*.repo:为仓库的指向提供配置 </p>
<p>​    仓库指向的定义: </p>
<p>​    [repositoryID] </p>
<p>​    name=Some name for this repository </p>
<p>​    baseurl=url://path/to/repository/ enabled={1|0} </p>
<p>​    gpgcheck={1|0} gpgkey=URL enablegroups={1|0} </p>
<p>​    failovermethod={roundrobin|priority} </p>
<p>​        roundrobin:意为随机挑选,默认值 </p>
<p>​        priority:按顺序访问 </p>
<p>​    cost= 默认为1000 </p>
<h4 id="yum仓库"><a href="#yum仓库" class="headerlink" title="yum仓库"></a>yum仓库</h4><p>yum的repo配置文件中可用的变量: </p>
<p>​    $releasever: 当前OS的发行版的主版本号 </p>
<p>​    $arch: 平台,i386,i486,i586,x86_64等 </p>
<p>​    $basearch:基础平台；i386,x86_64 </p>
<p>​    $YUM0-$YUM9:自定义变量 </p>
<p>实例: </p>
<p>​    <a href="http://server/centos/$releasever/$basearch/" target="_blank" rel="noopener">http://server/centos/$releasever/$basearch/</a> </p>
<p>​    <a href="http://server/centos/7/x86_64" target="_blank" rel="noopener">http://server/centos/7/x86_64</a> </p>
<p>​    <a href="http://server/centos/6/i384" target="_blank" rel="noopener">http://server/centos/6/i384</a> </p>
<h4 id="yum源"><a href="#yum源" class="headerlink" title="yum源"></a>yum源</h4><p>阿里云repo文件: </p>
<p>​    <a href="http://mirrors.aliyun.com/repo/" target="_blank" rel="noopener">http://mirrors.aliyun.com/repo/</a> </p>
<p>CentOS系统的yum源 </p>
<p>​    阿里云:</p>
<p>​    <a href="https://mirrors.aliyun.com/centos/$releasever/os/x86_64/" target="_blank" rel="noopener">https://mirrors.aliyun.com/centos/$releasever/os/x86_64/</a>     清华大学:</p>
<p>​    <a href="https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/os/x86_64/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/os/x86_64/</a> </p>
<p>EPEL的yum源: </p>
<p>​    阿里云:</p>
<p>​    <a href="https://mirrors.aliyun.com/epel/$releasever/x86_64" target="_blank" rel="noopener">https://mirrors.aliyun.com/epel/$releasever/x86_64</a> </p>
<h4 id="yum-config-manager"><a href="#yum-config-manager" class="headerlink" title="yum-config-manager"></a>yum-config-manager</h4><p>生成172.16.0.1_cobbler_ks_mirror_CentOS-X-x86_64_.repo </p>
<p>yum-config-manager –add-repo= <a href="http://172.16.0.1/cobbler/ks_mirror/7/" target="_blank" rel="noopener">http://172.16.0.1/cobbler/ks_mirror/7/</a> </p>
<p>yum-config-manager –disable “仓库名” 禁用仓库 </p>
<p>yum-config-manager –enable “仓库名” 启用仓库 </p>
<h4 id="yum命令"><a href="#yum命令" class="headerlink" title="yum命令"></a>yum命令</h4><p>yum命令的用法: </p>
<p>​    yum [options]/[command]/[package …] </p>
<p>显示仓库列表: </p>
<p>​    yum repolist [all|enabled|disabled] </p>
<p>显示程序包: </p>
<p>​    yum list </p>
<p>​    yum list [all | glob_exp1]/[glob_exp2]/[…] </p>
<p>​    yum list {available|installed|updates} [glob_exp1]/[…] </p>
<p>安装程序包: </p>
<p>​    yum install package1 [package2]/[…] </p>
<p>​    yum reinstall package1 [package2]/[…] (重新安装) </p>
<p>升级程序包: </p>
<p>​    yum update [package1]/[package2] /[…] </p>
<p>​    yum downgrade package1 [package2]/[…] (降级) </p>
<p>检查可用升级: </p>
<p>​    yum check-update </p>
<p>卸载程序包: </p>
<p>​    yum remove | erase package1 [package2]/[…] </p>
<p>查看程序包information: </p>
<p>​    yum info […] </p>
<p>查看指定的特性(可以是某文件)是由哪个程序包所提供: </p>
<p>​    yum provides | whatprovides feature1 [feature2]/[…] </p>
<p>清理本地缓存: </p>
<p>​    清除/var/cache/yum/$basearch/$releasever缓存 </p>
<p>​    yum clean [ packages | metadata | expire-cache | rpmdb | plugins | all ] </p>
<p>构建缓存: </p>
<p>​    yum makecache </p>
<p>搜索:yum search string1 [string2]/[…] </p>
<p>​    以指定的关键字搜索程序包名及summary信息 </p>
<p>查看指定包所依赖的capabilities: yum deplist package1 [package2][…] </p>
<p>查看yum事务历史: </p>
<p>​    yum history [info|list|packages-list|packages-info| </p>
<p>​    summary|addon-info|redo|undo| </p>
<p>​    rollback|new|sync|stats] </p>
<p>​    yum history </p>
<p>​    yum history info 6 </p>
<p>​    yum history undo 6 </p>
<p>日志 :/var/log/yum.log </p>
<p>安装及升级本地程序包: </p>
<p>​    yum localinstall rpmfile1 [rpmfile2]/[…] </p>
<p>​    (用install替代) </p>
<p>​    yum localupdate rpmfile1 rpmfile2]/[…] </p>
<p>​    (用update替代) </p>
<p>包组管理的相关命令: </p>
<p>​    yum groupinstall group1 [group2]/[…] </p>
<p>​    yum groupupdate group1 [group2]/[…] </p>
<p>​    yum grouplist [hidden]/[groupwildcard]/[…] </p>
<p>​    yum groupremove group1 [group2]/[…] </p>
<p>​    yum groupinfo group1 […] </p>
<p>yum的命令行选项: </p>
<p>​    –nogpgcheck:禁止进行gpg check </p>
<p>​    -y: 自动回答为“yes” </p>
<p>​    -q:静默模式 </p>
<p>​    –disablerepo=repoidglob:临时禁用此处指定的repo </p>
<p>​    –enablerepo=repoidglob:临时启用此处指定的repo </p>
<p>​    –noplugins:禁用所有插件 </p>
<h4 id="系统光盘的yum仓库"><a href="#系统光盘的yum仓库" class="headerlink" title="系统光盘的yum仓库"></a>系统光盘的yum仓库</h4><p>系统安装光盘作为本地yum仓库: </p>
<p>​    (1) 挂载光盘至某目录,例如/mnt/cdrom </p>
<p>​        mount /dev/cdrom /mnt/cdrom </p>
<p>​    (2) 创建配置文件 </p>
<p>​        [CentOS7] </p>
<p>​        name= </p>
<p>​        baseurl= </p>
<p>​        gpgcheck= </p>
<p>​        enabled= </p>
<p>创建yum仓库: </p>
<p>​    createrepo [options]  <directory></p>
<h3 id="程序包编译"><a href="#程序包编译" class="headerlink" title="程序包编译"></a>程序包编译</h3><p>程序包编译安装: </p>
<p>Application-VERSION-release.src.rpm –&gt; 安装后,使用rpmbuild命令制作 成二进制格式的rpm包,而后再安装 </p>
<p>源代码–&gt;预处理–&gt;编译–&gt;汇编–&gt;链接–&gt;执行 </p>
<p>源代码组织格式: </p>
<p>​    多文件:文件中的代码之间,很可能存在跨文件依赖关系 </p>
<p>​    C、C++:make 项目管理器 </p>
<p>​        configure脚本 –&gt; Makefile.in –&gt; Makefile </p>
<p>​    java: maven </p>
<h4 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h4><p>C语言源代码编译安装三步骤: </p>
<p>​     1、./configure </p>
<p>​    (1) 通过选项传递参数,指定启用特性、安装路径等；执行时会参考用户的 指定以及Makefile.in文件生成Makefile </p>
<p>​    (2) 检查依赖到的外部环境,如依赖的软件包 </p>
<p>​     2、make 根据Makefile文件,构建应用程序 </p>
<p>​     3、make install 复制文件到相应路径 </p>
<p>开发工具: </p>
<p>​    autoconf: 生成configure脚本 </p>
<p>​    automake:生成Makefile.in </p>
<p>注意:安装前查看INSTALL,README </p>
<p>开源程序源代码的获取: </p>
<p>​    官方自建站点: </p>
<p>​    apache.org (ASF:Apache Software Foundation) </p>
<p>​    mariadb.org </p>
<p>​    … </p>
<p>​    代码托管: </p>
<p>​    SourceForge.net </p>
<p>​    Github.com </p>
<p>​    code.google.com </p>
<p>c/c++编译器: gcc (GNU C Complier) </p>
<p>编译C源代码: </p>
<p>​    准备:提供开发工具及开发环境 </p>
<p>​        开发工具:make,gcc等 </p>
<p>​        开发环境:开发库,头文件 </p>
<p>​            glibc:标准库 </p>
<p>​    实现:通过“包组”提供开发组件 </p>
<p>​        Development Tools </p>
<p>​        Server Platform Development </p>
<p>第一步:configure脚本 </p>
<p>​    选项:指定安装位置、指定启用的特性 </p>
<p>​        –help: 获取其支持使用的选项 </p>
<p>​    选项分类: </p>
<p>​        安装路径设定: </p>
<p>​        –prefix=/PATH: 指定默认安装位置,默认为/usr/local/ </p>
<p>​        –sysconfdir=/PATH:配置文件安装位置 </p>
<p>​    System types:支持交叉编译 </p>
<p>​    Optional Features: 可选特性 </p>
<p>​        –disable-FEATURE </p>
<p>​        –enable-FEATURE[=ARG] </p>
<p>​     Optional Packages: 可选包 </p>
<p>​        –with-PACKAGE[=ARG],依赖包 </p>
<p>​        –without-PACKAGE,禁用依赖关系 </p>
<p>​     注意:通常被编译操作依赖的程序包,需要安装此程序包的“开发”组件,其包名 一般类似于name-devel-VERSION </p>
<p>第二步:make </p>
<p>第三步:make install </p>
<p>安装后的配置: </p>
<p>​     (1) 二进制程序目录导入至PATH环境变量中 </p>
<p>​        编辑文件/etc/profile.d/NAME.sh </p>
<p>​        export PATH=/PATH/TO/BIN:$PATH </p>
<p>​     (2) 导入库文件路径 </p>
<p>​        编辑/etc/ld.so.conf.d/NAME.conf </p>
<p>​            添加新的库文件所在目录至此文件中 </p>
<p>​        让系统重新生成缓存: </p>
<p>​            ldconfig [-v] </p>
<p>​    (3) 导入头文件 </p>
<p>​        基于链接的方式实现: </p>
<p>​            ln -sv </p>
<p>​    (4) 导入帮助手册 </p>
<p>​        编辑/etc/man.config|man_db.conf文件 </p>
<p>​        添加一个MANPATH </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/Linux-%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%92%8C%E5%8E%8B%E7%BC%A9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mark_avatar.png">
      <meta itemprop="name" content="Mark">
      <meta itemprop="description" content="半吊子民工 英特纳雄耐尔就一定要实现">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mark blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Linux-%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%92%8C%E5%8E%8B%E7%BC%A9/" class="post-title-link" itemprop="url">Linux 文件查找和压缩</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-09-05 20:44:29" itemprop="dateCreated datePublished" datetime="2015-09-05T20:44:29+08:00">2015-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-02 23:36:04" itemprop="dateModified" datetime="2019-01-02T23:36:04+08:00">2019-01-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%B5%B7%E6%8B%BE%E8%B4%9D/" itemprop="url" rel="index"><span itemprop="name">学海拾贝</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h3><p>在文件系统上查找符合条件的文件 </p>
<p>文件查找:locate, find </p>
<p>​    非实时查找(数据库查找):locate </p>
<p>​    实时查找:find </p>
<h4 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h4><p>查询系统上预建的文件索引数据库 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/mlocate/mlocate.db</span><br></pre></td></tr></table></figure>

<p>依赖于事先构建的索引 </p>
<p>索引的构建是在系统较为空闲时自动进行(周期性任务)，管理员手动更新数据库 (updatedb) </p>
<p>索引构建过程需要遍历整个根文件系统，极消耗资源 </p>
<p>工作特点: </p>
<p>• 查找速度快 </p>
<p>• 模糊查找 </p>
<p>• 非实时查找 </p>
<p>• 搜索的是文件的全路径，不仅仅是文件名 </p>
<p>• 可能只搜索用户具备读取和执行权限的目录 </p>
<h4 id="locate-命令"><a href="#locate-命令" class="headerlink" title="locate 命令"></a>locate 命令</h4><p>locate KEYWORD </p>
<p>有用的选项 </p>
<p>​    -i 不区分大小写的搜索 </p>
<p>​    -n N 只列举前N个匹配项目 </p>
<p>​    -r 使用正则表达式 </p>
<p>示例 </p>
<p>搜索名称或路径中带有”conf”的文件 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate conf</span><br></pre></td></tr></table></figure>

<p>使用Regex来搜索以”.conf”结尾的文件 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate -r ‘\.conf$’</span><br></pre></td></tr></table></figure>



<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>实时查找工具，通过遍历指定路径完成文件查找 </p>
<p>工作特点: </p>
<p>​    • 查找速度略慢 </p>
<p>​    • 精确查找 </p>
<p>​    • 实时查找 </p>
<p>​    • 可能只搜索用户具备读取和执行权限的目录 </p>
<p>语法: </p>
<p>find [OPTION]… [查找路径][查找条件][处理动作] </p>
<p>查找路径:指定具体目标路径;</p>
<p>默认为当前目录 查找条件:指定的查找标准，可以文件名、大小、类型、权限等标准进行; 默认为找出指定路径下的所有文件 </p>
<p>处理动作:对符合条件的文件做操作，默认输出至屏幕     </p>
<h4 id="查找条件"><a href="#查找条件" class="headerlink" title="查找条件"></a>查找条件</h4><p>指搜索层级 </p>
<p>​    -maxdepth level 最大搜索目录深度,指定目录为第1级 </p>
<p>​    -mindepth level 最小搜索目录深度 </p>
<p>根据文件名和inode查找: </p>
<p>​    -name “文件名称”:支持使用glob </p>
<p>​        *, ?, [], [^] </p>
<p>​    -iname “文件名称”:不区分字母大小写 </p>
<p>​    -inum n 按inode号查找 </p>
<p>​    -samefile name 相同inode号的文件 </p>
<p>​    -links n 链接数为n的文件 </p>
<p>​    -regex “PATTERN”:以PATTERN匹配整个文件路径字符串，而不仅仅是文 件名称     </p>
<p>根据属主、属组查找: </p>
<p>​    -user USERNAME:查找属主为指定用户(UID)的文件 </p>
<p>​    -group GRPNAME: 查找属组为指定组(GID)的文件 </p>
<p>​    -uid UserID:查找属主为指定的UID号的文件 </p>
<p>​    -gid GroupID:查找属组为指定的GID号的文件 </p>
<p>​    -nouser:查找没有属主的文件 </p>
<p>​    -nogroup:查找没有属组的文件     </p>
<p>根据文件类型查找: </p>
<p>​    -type TYPE: </p>
<p>​    • f: 普通文件 </p>
<p>​    • d: 目录文件 </p>
<p>​    • l: 符号链接文件 </p>
<p>​    • s:套接字文件 </p>
<p>​    • b: 块设备文件 </p>
<p>​    • c: 字符设备文件 </p>
<p>​    • p: 管道文件     </p>
<p>空文件或目录 </p>
<p>​    -empty </p>
<p>​    find /app -type d -empty     </p>
<p>组合条件: </p>
<p>​    与:-a </p>
<p>​    或:-o </p>
<p>​    非:-not, !     </p>
<p>德·摩根定律: </p>
<pre><code>(非 A) 或 (非 B) = 非(A 且 B) 

(非 A) 且 (非 B) = 非(A 或 B) </code></pre><p>示例: </p>
<pre><code>!A -a !B = !(A -o B) 

!A -o !B = !(A -a B) </code></pre><h4 id="查找条件-1"><a href="#查找条件-1" class="headerlink" title="查找条件"></a>查找条件</h4><p>根据文件大小来查找: </p>
<p>-size [+|-]#UNIT </p>
<pre><code>常用单位:k, M, G，c（byte） </code></pre><p>#UNIT: (#-1, #] </p>
<pre><code>如:6k 表示(5k,6k] </code></pre><p>-#UNIT:[0,#-1] </p>
<pre><code>如:-6k 表示[0,5k] </code></pre><p>+#UNIT:(#,∞) </p>
<pre><code>如:+6k 表示(6k,∞)     </code></pre><p>根据时间戳: </p>
<p>以”天”为单位; </p>
<p>​    -atime [+|-]#, </p>
<p>​        #: [#,#+1) </p>
<p>​        +#: [#+1,∞] </p>
<p>​        -#: [0,#)     </p>
<p>​    -mtime </p>
<p>​    -ctime     </p>
<p>以”分钟”为单位: </p>
<p>​    -amin </p>
<p>​    -mmin </p>
<p>​    -cmin         </p>
<p>根据权限查找: </p>
<p>-perm [/|-]MODE </p>
<p>MODE: 精确权限匹配 </p>
<p>​    /MODE:任何一类(u,g,o)对象的权限中只要能一位匹配即可，或关系，+ 从centos7开始淘汰 </p>
<p>​    -MODE:每一类对象都必须同时拥有指定权限，与关系 0 表示不关注 </p>
<p>​    • find -perm 755 会匹配权限模式恰好是755的文件 </p>
<p>​    • 只要当任意人有写权限时，find -perm +222就会匹配 </p>
<p>​    • 只有当每个人都有写权限时，find -perm -222才会匹配 </p>
<p>​    • 只有当其它人（other）有写权限时，find -perm -002才会匹配     </p>
<h4 id="处理动作"><a href="#处理动作" class="headerlink" title="处理动作"></a>处理动作</h4><p>-print:默认的处理动作，显示至屏幕 </p>
<p>-ls:类似于对查找到的文件执行”ls -l”命令 </p>
<p>-delete:删除查找到的文件 </p>
<p>-fls file:查找到的所有文件的长格式信息保存至指定文件中 </p>
<p>-ok COMMAND {} ; </p>
<p>​    对查找到的每个文件执行由COMMAND指定的命令，对于 每个文件执行命令之前，都会交互式要求用户确认 </p>
<p>-exec COMMAND {} ; </p>
<p>​    对查找到的每个文件执行由COMMAND指定的命令 </p>
<p>{}: 用于引用查找到的文件名称自身 </p>
<p>find传递查找到的文件至后面指定的命令时，查找到所有符合条件的文件一次性 传递给后面的命令 </p>
<h4 id="参数替换xargs"><a href="#参数替换xargs" class="headerlink" title="参数替换xargs"></a>参数替换xargs</h4><p>由于很多命令不支持管道|来传递参数，而日常工作中有这个必要，所以就有了 xargs命令 </p>
<p>xargs用于产生某个命令的参数，xargs 可以读入 stdin 的数据，并且以空格符 或回车符将 stdin 的数据分隔成为arguments </p>
<p>注意:文件名或者是其他意义的名词内含有空格符的情况 </p>
<p>有些命令不能接受过多参数，命令执行可能会失败，xargs可以解决 </p>
<p>示例: </p>
<p>​    ls f* |xargs rm </p>
<p>​    find /sbin -perm +700 |ls -l 这个命令是错误的     </p>
<p>​    find /sbin -perm +700 | xargs ls –l </p>
<p>find和xargs格式:find | xargs COMMAND </p>
<h3 id="压缩，解压缩及归档工具"><a href="#压缩，解压缩及归档工具" class="headerlink" title="压缩，解压缩及归档工具"></a>压缩，解压缩及归档工具</h3><p>file-roller </p>
<p>compress/uncompress: .Z </p>
<p>gzip/gunzip: .gz </p>
<p>bzip2/bunzip2: .bz2 </p>
<p>xz/unxz: .xz </p>
<p>zip/unzip </p>
<p>tar </p>
<p>cpio </p>
<h4 id="compress-uncompress"><a href="#compress-uncompress" class="headerlink" title="compress/uncompress"></a>compress/uncompress</h4><p>compress [-dfvcVr]/[-b maxbits]/[file …] </p>
<p>​    -d: 解压缩，相当于uncompress </p>
<p>​    -c: 结果输出至标准输出,不删除原文件 </p>
<p>​    -v: 显示详情     </p>
<p>uncompress 解压缩 </p>
<p>zcat file.Z &gt;file </p>
<h4 id="gzip-gunzip"><a href="#gzip-gunzip" class="headerlink" title="gzip/gunzip"></a>gzip/gunzip</h4><p>gzip [OPTION]… FILE … </p>
<p>​    -d: 解压缩，相当于gunzip </p>
<p>​    -c: 将压缩或解压缩的结果输出至标准输出 </p>
<p>​    -#:1-9，指定压缩比，值越大压缩比越大     </p>
<p>zcat:不显式解压缩的前提下查看文本文件内容 </p>
<p>实例: </p>
<p>​    gzip -c messages &gt;messages.gz </p>
<p>​    gzip -c -d messages.gz &gt; messages </p>
<p>​    zcat messages.gz &gt; messages     </p>
<h4 id="bzip2-bunzip-bzcat"><a href="#bzip2-bunzip-bzcat" class="headerlink" title="bzip2/bunzip/bzcat"></a>bzip2/bunzip/bzcat</h4><p>bzip2 [OPTION]… FILE … </p>
<p>​    -k: keep, 保留原文件 </p>
<p>​    -d:解压缩 </p>
<p>​    -#:1-9，压缩比，默认为9     </p>
<p>bzcat:不显式解压缩的前提下查看文本文件内容 </p>
<h4 id="xz-unxz-xzcat"><a href="#xz-unxz-xzcat" class="headerlink" title="xz/unxz/xzcat"></a>xz/unxz/xzcat</h4><p>xz [OPTION]… FILE … </p>
<p>​    -k: keep, 保留原文件 </p>
<p>​    -d:解压缩 </p>
<p>​    -#:1-9，压缩比，默认为6     </p>
<p>xzcat: 不显式解压缩的前提下查看文本文件内容 </p>
<h4 id="zip-unzip"><a href="#zip-unzip" class="headerlink" title="zip/unzip"></a>zip/unzip</h4><p>打包压缩 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip –r /testdir/sysconfig /etc/sysconfig/</span><br></pre></td></tr></table></figure>

<p>解包解压缩 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unzip sysconfig.zip </span><br><span class="line"></span><br><span class="line">cat /var/log/messages | zip messages - </span><br><span class="line"></span><br><span class="line">unzip -p message &gt; message</span><br></pre></td></tr></table></figure>



<h4 id="tar工具"><a href="#tar工具" class="headerlink" title="tar工具"></a>tar工具</h4><p> tar（Tape ARchive，磁带归档的缩写） </p>
<p> tar [OPTION]… </p>
<p>(1) 创建归档 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cpvf /PATH/TO/SOMEFILE.tar FILE...</span><br></pre></td></tr></table></figure>

<p>(2) 追加文件至归档: 注:不支持对压缩文件追加 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -r -f /PATH/TO/SOMEFILE.tar FILE...</span><br></pre></td></tr></table></figure>

<p>(3) 查看归档文件中的文件列表 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -t -f /PATH/TO/SOMEFILE.tar</span><br></pre></td></tr></table></figure>

<p>(4) 展开归档 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -x -f /PATH/TO/SOMEFILE.tar </span><br><span class="line"></span><br><span class="line">tar -x -f /PATH/TO/SOMEFILE.tar -C /PATH/</span><br></pre></td></tr></table></figure>

<p>(5) 结合压缩工具实现:归档并压缩 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-j: bzip2, -z: gzip, -J: xz</span><br></pre></td></tr></table></figure>

<p>-T选项指定输入文件,-X选项指定包含要排除的文件列表 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zcvf mybackup.tgz -T /root/includefilelist -X /root/excludefilelist</span><br></pre></td></tr></table></figure>

<p>分割大的 tar 文件为多份小文件: </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">split –b Size –d tar-file-name prefix-name </span><br><span class="line"></span><br><span class="line">split -b 1M –d mybackup.tgz mybackup-parts </span><br><span class="line"></span><br><span class="line">split -b 1M mybackup.tgz mybackup-parts</span><br></pre></td></tr></table></figure>

<p>合并: </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat mybackup-parts* &gt; mybackup.tar.gz</span><br></pre></td></tr></table></figure>



<h4 id="cpio"><a href="#cpio" class="headerlink" title="cpio"></a>cpio</h4><p>功能:复制文件从或到归档 </p>
<p>cpio命令是通过重定向的方式将文件进行打包备份，还原恢复的工具，它可以 解压以”.cpio”或者”.tar”结尾的文件 </p>
<p>cpio [选项] &gt; 文件名或者设备名 </p>
<p>cpio [选项] &lt; 文件名或者设备名 </p>
<p>选项 </p>
<p>​    -o 将文件拷贝打包成文件或者将文件输出到设备上 </p>
<p>​    -i 解包，将打包文件解压或将设备上的备份还原到系统 </p>
<p>​    -t 预览，查看文件内容或者输出到设备上的文件内容 </p>
<p>​    -v 显示打包过程中的文件名称。 </p>
<p>​    -d 解包生成目录，在cpio还原时，自动的建立目录 </p>
<p>​    -c 一种较新的存储方式     </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/%E4%BD%BF%E7%94%A8shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mark_avatar.png">
      <meta itemprop="name" content="Mark">
      <meta itemprop="description" content="半吊子民工 英特纳雄耐尔就一定要实现">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mark blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E4%BD%BF%E7%94%A8shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/" class="post-title-link" itemprop="url">使用shell脚本实现俄罗斯方块</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-09-02 17:24:07" itemprop="dateCreated datePublished" datetime="2015-09-02T17:24:07+08:00">2015-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-02 23:38:58" itemprop="dateModified" datetime="2019-01-02T23:38:58+08:00">2019-01-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%B5%B7%E6%8B%BE%E8%B4%9D/" itemprop="url" rel="index"><span itemprop="name">学海拾贝</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>学习 shell 的最好方法就是去实践,网上有很多的源码可供参考</p>
<h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>源码分析:</p>
<p>先从游戏主程序开始分析:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if [[ "$1" == "-h" || "$1" == "--help" ]]; then</span><br><span class="line">        Usage</span><br><span class="line">elif [[ "$1" == "--version" ]]; then</span><br><span class="line">        echo "$APP_NAME $APP_VERSION"</span><br><span class="line">elif [[ "$1" == "--show" ]]; then</span><br><span class="line">        #当发现具有参数--show时，运行显示函数</span><br><span class="line">        RunAsDisplayer</span><br><span class="line">else</span><br><span class="line">        bash $0 --show&amp;        #以参数--show将本程序再运行一遍</span><br><span class="line">        RunAsKeyReceiver $!        #以上一行产生的进程的进程号作为参数</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>里面出现了两个变量,查看定义后发现</p>
<p>APP_NAME : 打印了脚本名</p>
<p><code>APP_NAME=&quot;${0##*[\\/]}&quot;</code></p>
<p>APP_VERSION : 自己定义了版本号</p>
<p><code>APP_VERSION=&quot;1.0&quot;</code></p>
<p>其中出现了3个函数</p>
<p>Usage :显示脚本用法的函数</p>
<p>RunAsDisplayer :处理显示和游戏流程的主函数</p>
<p>RunAsKeyReceiver :接收输入的进程的主函数</p>
<p>我们从头开始分析这些函数的实现</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Usage</span><br><span class="line">&#123;</span><br><span class="line">        cat &lt;&lt; EOF</span><br><span class="line">Usage: $APP_NAME</span><br><span class="line">Start tetris game.</span><br><span class="line">  </span><br><span class="line">  -h, --help              display this help and exit</span><br><span class="line">      --version           output version information and exit</span><br><span class="line">EOF</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 Usage 函数就是打印了一些信息,主要是用户提示.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function RunAsDisplayer()</span><br><span class="line">&#123;</span><br><span class="line">        local sigThis	#定义了局部变量 sigThis</span><br><span class="line">        InitDraw</span><br><span class="line">  </span><br><span class="line">        #挂载各种信号的处理函数</span><br><span class="line">        trap "sig=$sigRotate;" $sigRotate</span><br><span class="line">        trap "sig=$sigLeft;" $sigLeft</span><br><span class="line">        trap "sig=$sigRight;" $sigRight</span><br><span class="line">        trap "sig=$sigDown;" $sigDown</span><br><span class="line">        trap "sig=$sigAllDown;" $sigAllDown</span><br><span class="line">        trap "ShowExit;" $sigExit</span><br><span class="line">  </span><br><span class="line">        while :</span><br><span class="line">        do</span><br><span class="line">                #根据当前的速度级iLevel不同，设定相应的循环的次数</span><br><span class="line">                for ((i = 0; i &lt; 21 - iLevel; i++))</span><br><span class="line">                do</span><br><span class="line">                        sleep 0.02</span><br><span class="line">                        sigThis=$sig</span><br><span class="line">                        sig=0</span><br><span class="line">  </span><br><span class="line">                        #根据sig变量判断是否接受到相应的信号</span><br><span class="line">                        if ((sigThis == sigRotate)); then BoxRotate;        #旋转</span><br><span class="line">                        elif ((sigThis == sigLeft)); then BoxLeft;        #左移一列</span><br><span class="line">                        elif ((sigThis == sigRight)); then BoxRight;        #右移一列</span><br><span class="line">                        elif ((sigThis == sigDown)); then BoxDown;        #下落一行</span><br><span class="line">                        elif ((sigThis == sigAllDown)); then BoxAllDown;        #下落到底</span><br><span class="line">                        fi</span><br><span class="line">                done</span><br><span class="line">                #kill -$sigDown $$</span><br><span class="line">                BoxDown        #下落一行</span><br><span class="line">        done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>暂时先不管 RunAsDisplayer 中调用的 InitDraw 函数,先看一下这个函数的功能.</p>
<p>从流程上分析这个函数实现了按键信号的捕捉,然后在一个死循环中以操作时间为0.02秒,不断的执行对方块的移动操作,然后执行下落一行的操作.</p>
<p>接下来对其中出现的参数和函数进行分析:</p>
<p>trap 这个命令实现了shell中脚本信号的获取,可以在脚本运行中执行额外的操作,比如获取键盘的输入用来控制方块的运动轨迹.</p>
<p>iLevel 这个参数是定义的速度级,这个稍后会提到.</p>
<p>BoxDown : 控制方块下落的函数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">function RunAsKeyReceiver()</span><br><span class="line">&#123;</span><br><span class="line">        local pidDisplayer key aKey sig cESC sTTY</span><br><span class="line">  </span><br><span class="line">        pidDisplayer=$1</span><br><span class="line">        aKey=(0 0 0)</span><br><span class="line">  </span><br><span class="line">        cESC=`echo -ne "\033"`</span><br><span class="line">        cSpace=`echo -ne "\040"`</span><br><span class="line">  </span><br><span class="line">        #保存终端属性。在read -s读取终端键时，终端的属性会被暂时改变。</span><br><span class="line">        #如果在read -s时程序被不幸杀掉，可能会导致终端混乱，</span><br><span class="line">        #需要在程序退出时恢复终端属性。</span><br><span class="line">        sTTY=`stty -g`</span><br><span class="line">  </span><br><span class="line">        #捕捉退出信号</span><br><span class="line">        trap "MyExit;" INT TERM</span><br><span class="line">        trap "MyExitNoSub;" $sigExit</span><br><span class="line">  </span><br><span class="line">        #隐藏光标</span><br><span class="line">        echo -ne "\033[?25l"</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        while :</span><br><span class="line">        do</span><br><span class="line">                #读取输入。注-s不回显，-n读到一个字符立即返回</span><br><span class="line">                read -s -n 1 key</span><br><span class="line">  </span><br><span class="line">                aKey[0]=$&#123;aKey[1]&#125;</span><br><span class="line">                aKey[1]=$&#123;aKey[2]&#125;</span><br><span class="line">                aKey[2]=$key</span><br><span class="line">                sig=0</span><br><span class="line">  </span><br><span class="line">                #判断输入了何种键</span><br><span class="line">                if [[ $key == $cESC &amp;&amp; $&#123;aKey[1]&#125; == $cESC ]]</span><br><span class="line">                then</span><br><span class="line">                        #ESC键</span><br><span class="line">                        MyExit</span><br><span class="line">                elif [[ $&#123;aKey[0]&#125; == $cESC &amp;&amp; $&#123;aKey[1]&#125; == "[" ]]</span><br><span class="line">                then</span><br><span class="line">                        if [[ $key == "A" ]]; then sig=$sigRotate        #&lt;向上键&gt;</span><br><span class="line">                        elif [[ $key == "B" ]]; then sig=$sigDown        #&lt;向下键&gt;</span><br><span class="line">                        elif [[ $key == "D" ]]; then sig=$sigLeft        #&lt;向左键&gt;</span><br><span class="line">                        elif [[ $key == "C" ]]; then sig=$sigRight        #&lt;向右键&gt;</span><br><span class="line">                        fi</span><br><span class="line">                elif [[ $key == "W" || $key == "w" ]]; then sig=$sigRotate        #W, w</span><br><span class="line">                elif [[ $key == "S" || $key == "s" ]]; then sig=$sigDown        #S, s</span><br><span class="line">                elif [[ $key == "A" || $key == "a" ]]; then sig=$sigLeft        #A, a</span><br><span class="line">                elif [[ $key == "D" || $key == "d" ]]; then sig=$sigRight        #D, d</span><br><span class="line">                elif [[ "[$key]" == "[]" ]]; then sig=$sigAllDown        #空格键</span><br><span class="line">                elif [[ $key == "Q" || $key == "q" ]]                        #Q, q</span><br><span class="line">                then</span><br><span class="line">                        MyExit</span><br><span class="line">                fi</span><br><span class="line">  </span><br><span class="line">                if [[ $sig != 0 ]]</span><br><span class="line">                then</span><br><span class="line">                        #向另一进程发送消息</span><br><span class="line">                        kill -$sig $pidDisplayer</span><br><span class="line">                fi</span><br><span class="line">        done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数是接收输入的进程的主程序,然后判断用户的输入,在这个脚本中,可以使用方向键和wasd来控制方块的运行轨迹,然后不断显示直到游戏结束.</p>
<p>里面调用了一个MyExit的函数.</p>
<p>接下来分析一下 RunAsDisplayer中BoxDown 这个函数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function BoxDown()</span><br><span class="line">&#123;</span><br><span class="line">        local y s</span><br><span class="line">        ((y = boxCurY + 1))        #新的y坐标</span><br><span class="line">        if BoxMove $y $boxCurX        #测试是否可以下落一行</span><br><span class="line">        then</span><br><span class="line">                s="`DrawCurBox 0`"        #将旧的方块抹去</span><br><span class="line">                ((boxCurY = y))</span><br><span class="line">                s="$s`DrawCurBox 1`"        #显示新的下落后方块</span><br><span class="line">                echo -ne $s</span><br><span class="line">        else</span><br><span class="line">                #走到这儿, 如果不能下落了</span><br><span class="line">                Box2Map                #将当前移动中的方块贴到背景方块中</span><br><span class="line">                RandomBox        #产生新的方块</span><br><span class="line">        fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数主要是定义了控制方块下落的功能,首先会判断是否可也下落,如果可以消除的话,先把可以消除的方块抹去,然后显示新的下落后的方块,如果不能下落了就将当前移动中的方块贴到背景方块中,然后继续产生新的方块.</p>
<p>里面调用了四个函数</p>
<p>BoxMove : 测试是否可以下落一行</p>
<p>DrawCurBox : 显示方块</p>
<p>Box2Map : 将当前移动中的方块贴到背景方块中</p>
<p>RandomBox : 产生新的方块</p>
<p>查看一下BoxMove这个函数,看看其中的功能是怎么实现的:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function BoxMove()</span><br><span class="line">&#123;</span><br><span class="line">        local j i x y xTest yTest</span><br><span class="line">        yTest=$1</span><br><span class="line">        xTest=$2</span><br><span class="line">        for ((j = 0; j &lt; 8; j += 2))</span><br><span class="line">        do</span><br><span class="line">                ((i = j + 1))</span><br><span class="line">                ((y = $&#123;boxCur[$j]&#125; + yTest))</span><br><span class="line">                ((x = $&#123;boxCur[$i]&#125; + xTest))</span><br><span class="line">                if (( y &lt; 0 || y &gt;= iTrayHeight || x &lt; 0 || x &gt;= iTrayWidth))</span><br><span class="line">                then</span><br><span class="line">                        #撞到墙壁了</span><br><span class="line">                        return 1</span><br><span class="line">                fi</span><br><span class="line">                if (($&#123;iMap[y * iTrayWidth + x]&#125; != -1 ))</span><br><span class="line">                then</span><br><span class="line">                        #撞到其他已经存在的方块了</span><br><span class="line">                        return 1</span><br><span class="line">                fi</span><br><span class="line">        done</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面定义了方块移动的相关信息,通过判断方块的位置来确定是否可以进行移动</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/shell-%E4%B8%AD%E7%89%B9%E6%AE%8A%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%A8%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mark_avatar.png">
      <meta itemprop="name" content="Mark">
      <meta itemprop="description" content="半吊子民工 英特纳雄耐尔就一定要实现">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mark blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/shell-%E4%B8%AD%E7%89%B9%E6%AE%8A%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%A8%E6%B3%95/" class="post-title-link" itemprop="url">shell 中特殊变量的用法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-09-01 16:20:02" itemprop="dateCreated datePublished" datetime="2015-09-01T16:20:02+08:00">2015-09-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-02 23:34:19" itemprop="dateModified" datetime="2019-01-02T23:34:19+08:00">2019-01-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%B5%B7%E6%8B%BE%E8%B4%9D/" itemprop="url" rel="index"><span itemprop="name">学海拾贝</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Shell 编程中的有很多特殊的变量可以打印出来很多有用的信息.在网上检索之后做个笔记.希望也可以帮助更多有需要的人</p>
<p><strong>$$</strong> </p>
<p>Shell本身的PID（ProcessID） </p>
<p><strong>$!</strong> </p>
<p>Shell最后运行的后台Process的PID </p>
<p><strong>$?</strong> </p>
<p>最后运行的命令的结束代码（返回值） </p>
<p><strong>$-</strong> </p>
<p>使用Set命令设定的Flag一览 <strong>$</strong></p>
<p><strong>S*</strong> </p>
<p>所有参数列表。如”$*”用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。 </p>
<p><strong>$@</strong> </p>
<p>所有参数列表。如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。 </p>
<p><strong>$#</strong></p>
<p> 添加到Shell的参数个数 </p>
<p><strong>$0</strong></p>
<p> Shell本身的文件名 $1～$n 添加到Shell的各参数值。$1是第1参数、$2是第2参数…。 </p>
<hr>
<p>我们先写一个简单的脚本，执行以后再解释各个变量的意义 </p>
<p><code># touch variable</code> </p>
<p><code># vi variable</code> </p>
<p>脚本内容如下： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh </span></span><br><span class="line"></span><br><span class="line">echo "number:$#" </span><br><span class="line"></span><br><span class="line">echo "scname:$0" </span><br><span class="line"></span><br><span class="line">echo "first :$1" </span><br><span class="line"></span><br><span class="line">echo "second:$2" </span><br><span class="line"></span><br><span class="line">echo "argume:$@"</span><br></pre></td></tr></table></figure>

<p>保存退出 赋予脚本执行权限 </p>
<p><code># chmod +x variable</code> </p>
<p>执行脚本 </p>
<p><code># ./variable aa bb</code> </p>
<p>执行结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">number:2 </span><br><span class="line">scname:./variable </span><br><span class="line">first: aa </span><br><span class="line">second:bb </span><br><span class="line">argume:aa bb</span><br></pre></td></tr></table></figure>

<p> 通过显示结果可以看到： </p>
<p>$# 是传给脚本的参数个数 </p>
<p>$0 是脚本本身的名字 </p>
<p>$1是传递给该shell脚本的第一个参数 </p>
<p>$2是传递给该shell脚本的第二个参数 </p>
<p>$@ 是传给脚本的所有参数的列表 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/Linux-Shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6-%E5%9B%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mark_avatar.png">
      <meta itemprop="name" content="Mark">
      <meta itemprop="description" content="半吊子民工 英特纳雄耐尔就一定要实现">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mark blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Linux-Shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6-%E5%9B%9B/" class="post-title-link" itemprop="url">Linux Shell 脚本编程进阶(四)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-08-30 14:26:48" itemprop="dateCreated datePublished" datetime="2015-08-30T14:26:48+08:00">2015-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-02 23:33:48" itemprop="dateModified" datetime="2019-01-02T23:33:48+08:00">2019-01-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%B5%B7%E6%8B%BE%E8%B4%9D/" itemprop="url" rel="index"><span itemprop="name">学海拾贝</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="高级变量用法-有类型变量"><a href="#高级变量用法-有类型变量" class="headerlink" title="高级变量用法-有类型变量"></a>高级变量用法-有类型变量</h3><p>Shell变量一般是无类型的,但是bash Shell提供了declare和typeset两个命令用于指定变量的类型,两个命令是等价的<br>declare [选项] 变量名<br>​    -r 声明或显示只读变量<br>​    -i 将变量定义为整型数<br>​    -a 将变量定义为数组<br>​    -A 将变量定义为关联数组<br>​    -f 显示已定义的所有函数名及其内容<br>​    -F 仅显示已定义的所有函数名<br>​    -x 声明或显示环境变量和函数<br>​    -l 声明变量为小写字母 declare –l var=UPPER<br>​    -u 声明变量为大写字母 declare –u var=lower</p>
<h3 id="eval命令"><a href="#eval命令" class="headerlink" title="eval命令"></a>eval命令</h3><p>eval命令将会首先扫描命令行进行所有的置换,然后再执行该命令.该命令适用于那些一次扫描无法实现其功能的变量.该命令对变量进行两次扫描<br> 示例:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@server ~]# CMD=whoami</span><br><span class="line">[root@server ~]# echo $CMD</span><br><span class="line">whoami</span><br><span class="line">[root@server ~]# eval $CMD</span><br><span class="line">root</span><br><span class="line">[root@server ~]# n=10</span><br><span class="line">[root@server ~]# echo &#123;0..$n&#125;</span><br><span class="line">&#123;0..10&#125;</span><br><span class="line">[root@server ~]# eval echo &#123;0..$n&#125;</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 10</span><br></pre></td></tr></table></figure>



<h3 id="间接变量引用"><a href="#间接变量引用" class="headerlink" title="间接变量引用"></a>间接变量引用</h3><p>如果第一个变量的值是第二个变量的名字,从第一个变量引用第二个变量的值就称为间接变量引用<br>variable1的值是variable2,而variable2又是变量名,variable2的值为value,间接变量引用是指通过variable1获得变量值value的行为<br>​    variable1=variable2<br>​    variable2=value</p>
<p>bash Shell提供了两种格式实现间接变量引用<br>​    eval tempvar=$$variable1<br>​    tempvar=${!variable1}<br>示例:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@server ~]# N=NAME</span><br><span class="line">[root@server ~]# NAME=mark</span><br><span class="line">[root@server ~]# N1=$&#123;!N&#125;</span><br><span class="line">[root@server ~]# echo $N1</span><br><span class="line">mark</span><br><span class="line">[root@server ~]# eval N2=$$N</span><br><span class="line">[root@server ~]# echo $N2</span><br><span class="line">mark</span><br></pre></td></tr></table></figure>



<h3 id="创建临时文件"><a href="#创建临时文件" class="headerlink" title="创建临时文件"></a>创建临时文件</h3><p>mktemp命令:创建并显示临时文件,可避免冲突<br>mktemp [OPTION]… [TEMPLATE]<br>​    TEMPLATE: filenameXXX<br>​        X至少要出现三个<br>OPTION:<br>​    -d: 创建临时目录<br>​    -p DIR或–tmpdir=DIR:指明临时文件所存放目录位置<br>示例:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mktemp /tmp/testXXX</span><br><span class="line"></span><br><span class="line">tmpdir=`mktemp –d /tmp/testdirXXX`</span><br><span class="line"></span><br><span class="line">mktemp --tmpdir=/testdir testXXXXXX</span><br></pre></td></tr></table></figure>

<h3 id="安装复制文件"><a href="#安装复制文件" class="headerlink" title="安装复制文件"></a>安装复制文件</h3><p>install命令:<br>​    install [OPTION]… [-T] SOURCE DEST 单文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">install [OPTION]... SOURCE... DIRECTORY</span><br><span class="line"></span><br><span class="line">install [OPTION]... -t DIRECTORY SOURCE...</span><br><span class="line"></span><br><span class="line">install [OPTION]... -d DIRECTORY...创建空目录</span><br></pre></td></tr></table></figure>

<p>选项:<br>​    -m MODE,默认755</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-o OWNER</span><br><span class="line"></span><br><span class="line">-g GROUP</span><br></pre></td></tr></table></figure>

<p>示例:<br>​    install -m 700 -o mark -g admins srcfile desfile</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install –m 770 –d &#x2F;testdir&#x2F;installdir</span><br></pre></td></tr></table></figure>



<h3 id="expect介绍"><a href="#expect介绍" class="headerlink" title="expect介绍"></a>expect介绍</h3><p>expect 是由Don Libes基于Tcl（ Tool Command Language ）语言开发的,主要应用于自动化交互式操作的场景,借助Expect处理交互的命令,可以将交互过程如:ssh登录,ftp登录等写在一个脚本上,使之自动化完成.尤其适用于需要对多台服务器执行相同操作的环境中,可以大大提高系统管理人员的工作效率</p>
<h4 id="expect命令"><a href="#expect命令" class="headerlink" title="expect命令"></a>expect命令</h4><p>expect 语法:<br>expect [选项][ -c cmds ] [ [ -[f|b] ] cmdfile ][ args ]<br>选项<br>​    -c:从命令行执行expect脚本,默认expect是交互地执行的<br>​    示例:expect -c ‘expect “\n” {send “pressed enter\n”}<br>​    -d:可以输出输出调试信息<br>​    示例:expect -d ssh.exp<br>expect中相关命令<br>​    spawn:启动新的进程<br>​    send:用于向进程发送字符串<br>​    expect:从进程接收字符串<br>​    interact:允许用户交互<br>​    exp_continue 匹配多个字符串在执行动作后加此命令</p>
<p> expect最常用的语法(tcl语言:模式-动作)<br> 单一分支模式语法:<br>​    expect “hi” {send “You said hi\n”}<br>​    匹配到hi后,会输出“you said hi”,并换行<br> 多分支模式语法:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expect "hi" &#123; send "You said hi\n" &#125; \</span><br><span class="line">"hehe" &#123; send “Hehe yourself\n" &#125; \</span><br><span class="line">"bye" &#123; send “Good bye\n" &#125;</span><br></pre></td></tr></table></figure>

<p>匹配hi,hello,bye任意字符串时,执行相应输出.等同如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expect &#123;</span><br><span class="line">"hi" &#123; send "You said hi\n"&#125;</span><br><span class="line">"hehe" &#123; send "Hehe yourself\n"&#125;</span><br><span class="line">"bye" &#123; send “Good bye\n"&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="expect例程"><a href="#expect例程" class="headerlink" title="expect例程"></a>expect例程</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line">spawn scp /etc/fstab 192.168.8.100:/app</span><br><span class="line">expect &#123;</span><br><span class="line">	"yes/no" &#123; send "yes\n";exp_continue &#125;</span><br><span class="line">	"password" &#123; send “mark\n" &#125;</span><br><span class="line">&#125;</span><br><span class="line">expect eof</span><br></pre></td></tr></table></figure>

<p>例程:变量</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line">set ip 192.168.8.100</span><br><span class="line">set user root</span><br><span class="line">set password mark</span><br><span class="line">set timeout 10</span><br><span class="line">spawn ssh $user@$ip</span><br><span class="line">expect &#123;</span><br><span class="line">	"yes/no" &#123; send "yes\n";exp_continue &#125;</span><br><span class="line">	"password" &#123; send "$password\n" &#125;</span><br><span class="line">&#125;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure>

<p>例程:位置参数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line">set ip [lindex $argv 0]</span><br><span class="line">set user [lindex $argv 1]</span><br><span class="line">set password [lindex $argv 2]</span><br><span class="line">spawn ssh $user@$ip</span><br><span class="line">expect &#123;</span><br><span class="line"> "yes/no" &#123; send "yes\n";exp_continue &#125;</span><br><span class="line"> "password" &#123; send "$password\n" &#125;</span><br><span class="line">&#125;</span><br><span class="line">interact</span><br><span class="line"><span class="meta">#</span><span class="bash">./ssh3.exp 192.168.8.100 root mark</span></span><br></pre></td></tr></table></figure>

<p>例程:执行多个命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line">set ip [lindex $argv 0]</span><br><span class="line">set user [lindex $argv 1]</span><br><span class="line">set password [lindex $argv 2]</span><br><span class="line">set timeout 10</span><br><span class="line">spawn ssh $user@$ip</span><br><span class="line">expect &#123;</span><br><span class="line"> "yes/no" &#123; send "yes\n";exp_continue &#125;</span><br><span class="line"> "password" &#123; send "$password\n" &#125;</span><br><span class="line">&#125;</span><br><span class="line">expect "]#" &#123; send "useradd haha\n" &#125;</span><br><span class="line">expect "]#" &#123; send "echo mark |passwd --stdin haha\n" &#125;</span><br><span class="line">send "exit\n"</span><br><span class="line">expect eof</span><br><span class="line"><span class="meta">#</span><span class="bash">./ssh4.exp 192.168.8.100 root mark</span></span><br></pre></td></tr></table></figure>

<p>例程:shell脚本调用expect</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">ip=$1</span><br><span class="line">user=$2</span><br><span class="line">password=$3</span><br><span class="line">expect &lt;&lt;EOF</span><br><span class="line">set timeout 10</span><br><span class="line">spawn ssh $user@$ip</span><br><span class="line">expect &#123;</span><br><span class="line"> "yes/no" &#123; send "yes\n";exp_continue &#125;</span><br><span class="line"> "password" &#123; send "$password\n" &#125;</span><br><span class="line">&#125;</span><br><span class="line">expect "]#" &#123; send "useradd hehe\n" &#125;</span><br><span class="line">expect "]#" &#123; send "echo mark |passwd --stdin hehe\n" &#125;</span><br><span class="line">expect "]#" &#123; send "exit\n" &#125;</span><br><span class="line">expect eof</span><br><span class="line">EOF</span><br><span class="line"><span class="meta">#</span><span class="bash">./ssh5.sh 192.168.8.100 root mark</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Mark"
      src="/images/mark_avatar.png">
  <p class="site-author-name" itemprop="name">Mark</p>
  <div class="site-description" itemprop="description">半吊子民工 英特纳雄耐尔就一定要实现</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:markupzh@gmail.com" title="E-Mail → mailto:markupzh@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mark</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
