<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android 避免OOM(内存优化)</title>
    <url>/Android-%E9%81%BF%E5%85%8DOOM-%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>Android内存优化是性能优化很重要的一部分，而如何避免OOM又是内存优化的核心。</p>
<h2 id="Android内存管理机制"><a href="#Android内存管理机制" class="headerlink" title="Android内存管理机制"></a>Android内存管理机制</h2><p>android官网有一篇文章</p>
<p><a href="https://link.jianshu.com?t=http://developer.android.com/training/articles/memory.html" target="_blank" rel="noopener">Android是如何管理应用的进程与内存分配</a><br> Android系统的Dalvik虚拟机扮演了内存垃圾自动回收的角色。</p>
<h4 id="OOM介绍（out-of-memory-内存溢出）"><a href="#OOM介绍（out-of-memory-内存溢出）" class="headerlink" title="OOM介绍（out of memory 内存溢出）"></a>OOM介绍（out of memory 内存溢出）</h4><p>Android和java中都会出现由于不良代码引起的内存泄露，为了使Android应用程序能够快速高效的运行，Android每个应用程序都会有专门Dalvik虚拟机实例来运行，也就是每个程序都在属于自己的进程中运行。<br> 这样，某个应用程序内存泄露仅仅只会使自己进程被kill掉不会影响其他进程（如果是system_process等系统进程出现问题，就会造成系统重启），<strong>另一方面</strong>，系统为每一个应用程序分配了不同的内存上限，如果超过这个上限被视为内存泄露，从而被kill掉。<br> Dalvik Heap size因不同设备的RAM不同而有所差异，应用占用内存接近这个阀值，在尝试分配内存就会引起outofmemoryError的错误。</p>
<p>出现OOM有几种情况：</p>
<p>1.加载对象过大</p>
<p>2.相应资源过多，来不及加载。</p>
<p>解决这些问题，有：</p>
<p>1.内存引用上做一些处理，常用的有软引用。</p>
<p>2.内存中加载图片直接在内存中做处理（如边界压缩） 这个Glide\Fresco 图片框架可能封装好了</p>
<p>3.动态回收内存</p>
<p>4.优化Delivk虚拟机的堆内存分配</p>
<p>5.自定义堆内存大小</p>
<p>从Android内存分配的角度来理解OOM的产生和避免</p>
<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>Android应用程序的进程都是从Zygote的进程fork出来的。Zygote进程在系统启动并载入通用的framework代码和资源后启动。一个新的应用程序启动，系统就会从Zygote中fork出来一个新的进程，在新的进程中加载并允许应用程序的代码。这使得大多数RAM pages被分配给framework的代码，并且RAM资源能够在应用的所有进程之间共享。</p>
<p>大多数static 数据被mmapped到一个进程中，这样使得同样的数据在进程之间能够共享，而且在需要的时候能paged out.常见static 数据包括Dalvik code ,app resourecs,so 文件等。</p>
<p>大多数情况下，Android通过显示的方式分配共享内存区域（例如ashmem或gralloc）来实现动态RAM区域能够在不同进程之间进行共享的机制。比如，Window Surface在APP和Screen Composition之间使用共享的内存，<br> Cursor Buffers在Content Provider与Clients之间共享内存。</p>
<h4 id="分配与回收内存"><a href="#分配与回收内存" class="headerlink" title="分配与回收内存"></a>分配与回收内存</h4><p>每个进程的Dalvik heap都反应了使用内存的占用范围,（Dalvik Heap Size）,他可以根据需要进行增长，但是系统有一个上限。</p>
<p>HeapSize跟实际的物理内存大小是不对等的，PSS（proportional Set Size）记录了应用程序自身占用以及和其他进程共享的内容。</p>
<p>Android不会对heap空闲区域进行做碎片整理。系统仅仅在新的内存分配之前判断Heap的尾端剩余空间是否足够，不够就会触发gc操作，从而腾出更多空闲的内存空间。gc操作(garbage collection)也就是所谓的垃圾回收，Android在适当时候触发gc操作，将一些不再使用的对象回收，在Android高级系统针对Heap空间有一个Generational Heap Memory的模型，最近分配的对象在放在young generation区域，当停留一段时间，这个对象会被移动到old generation中，最后在移动到permanent generation区域中。系统会根据内存中不同的内存数据类型进行gc操作，young generation区域的对象更容易被销毁，而且gc操作的速度比old generation的速度要快，时间更短。<br> 每个generation的内存区域都有固定的大小，随着新的对象陆续被分配到此区域，当这些对象的大小快达到阀门值时，就会触发gc操作。通常情况下，gc操作发生时，所有线程都是暂停的。<br> 如何查看本机heap size:<br> <code>ActivityManager manager=(Activity)getSystemService(Context.ACTIVITY_SERVICE); int heapsize=manager.getMemoryClass();</code> </p>
<h4 id="应用切换操作"><a href="#应用切换操作" class="headerlink" title="应用切换操作"></a>应用切换操作</h4><p>Android系统不会再用户切换应用的时候进行交换内存的操作，而是把不包含Foreground组件的应用进程放到LRUCache中，比如用户启动一个应用，系统会为它创建一个进程，但是当用户离开这个应用，此进程不会背立即销毁而是会放到一个Cache中，当用户切换回来够快速的恢复。</p>
<h4 id="发生OOM的条件"><a href="#发生OOM的条件" class="headerlink" title="发生OOM的条件"></a>发生OOM的条件</h4><p>通过不同的内存分配方式对不同的对象(bitmap,etc)进行操作因Android版本差异发生变化。<br> 4.0以上，废除了external的计数器，类似bitmap的分配改到dalvik的Java heap(堆)中申请，只要allocated+新分配的内存&gt;=getMemoryClass()就会发生OOM。(在AS memory monitor查看内存中Dalvik Heap的实时变化)</p>
<h4 id="如何避免OOM"><a href="#如何避免OOM" class="headerlink" title="如何避免OOM"></a>如何避免OOM</h4><p>减少OOM的第一步就是要尽量减少新分配出来的对象占用内存的大小，尽量使用更加轻量的对象。解决的途径通常有以下几种:</p>
<p>1.使用更加轻量的数据结构<br> 考虑使用ArrayMap/SpareseArray而不是传统的HashMap等数据结构，Android系统为移动系统设计的容器ArrayMap更加高效，占用内存更少，因为HashMap需要一个额外的实例对象来记录Mapping的操作。而SparesArray高效的避免了key和value的自动装箱，而且避免了装箱后的解箱。</p>
<p>2.避免在Android中使用Enum</p>
<p>3.减少Bitmap对象的内存占用<br> Bitmap是一个消耗内存的大胖子，减少创建出来的Bitmap的内存占用很重要。一般有两种措施</p>
<ul>
<li>inSampleSize:缩放比例，在把图片载入内存之前，我们需要计算一个合适的缩放比例，避免不必要的大图载入。</li>
<li>decode format:解码格式，选择ARGB_8888/RBG_565/ARGB_4444/ALPHA_8，存在很大差异。</li>
</ul>
<p>4.使用更小的图片<br> 在设计图片资源的时候，我们要考虑图片是否存在可以压缩的空间，是否能使用更小的图片，使用小图在xml加载资源时就不会在初始化视图因为内存不足而发生InflationException,其根本原因就是发生了OOM。</p>
<h4 id="内存对象的重复利用"><a href="#内存对象的重复利用" class="headerlink" title="内存对象的重复利用"></a>内存对象的重复利用</h4><p>Android最常用的缓存算法LRU(Least Recently Use)</p>
<p>1.复用系统自带的资源，比如字符串、图片、动画、样式、颜色、简单布局，在应用中直接引用，减少自身负重、apk大小、减少内存的开销、复用性更好。但需要考虑版本差异。</p>
<p>2.Listview和GirdView出现大量重复子组件的视图里面对ConvertView的复用。</p>
<p>3.Bitmap对象的复用</p>
<ul>
<li><p>在ListView和GridView等显示大量图片的控件里面需要使用LRU机制缓存Bitmap.</p>
</li>
<li><p>利用inBitmap的高级特性提高Android系统在Bitmap分配和释放执行效率，inBitmap属性可以告知Bitmap解码器使用已经存在的内存区域而不是重新申请一块内存区域存放Bitmap,也就是新解码的Bitmap会使用之前那张bitmap在heap占用的内存区域，即使是上千张图片，也只占用屏幕能放下图片的内存</p>
</li>
</ul>
<p>  inBitmap的限制</p>
<ul>
<li><p>SDK19以后：新申请的BItmap大小必须小于或等于前面赋值过的bitmap的大小</p>
</li>
<li><p>新的Bitmap和原来的解码格式要相同，我们可以创建包含多种类型可以重用的bitmap对象池，这样后序的bitmap创建就可以找到合适的模板去重用。</p>
</li>
</ul>
<p>4.避免在onDraw方法里面执行对象的创建<br>在onDraw这种频繁调用的方法要避免对象的创建操作，因为他会迅速增加内存的使用，引起频繁的gc，甚至内存抖动</p>
<p>5.StringBuilder<br>如果代码中有大量字符串拼接操作，使用StringBuilder代替”+”</p>
<h4 id="避免对象的内存泄露"><a href="#避免对象的内存泄露" class="headerlink" title="避免对象的内存泄露"></a>避免对象的内存泄露</h4><p>内存对象的泄露会导致不再使用的对象无法及时释放，不仅浪费了宝贵的内存空间，后续要分配内存的时候，空间不足造成OOM。这样，每级的generation会变小，gc更加容易触发，引起内存抖动，带来性能问题。</p>
<ul>
<li>LeakCanary开源控件可以帮助我们发现内存泄露的问题。<br> 介绍：<a href="https://link.jianshu.com?t=https://github.com/square/leakcanary" target="_blank" rel="noopener">https://github.com/square/leakcanary</a> </li>
<li>中文文档 <a href="https://link.jianshu.com?t=http://www.liaohuqiu.net/cn/posts/leak-canary-read-me/" target="_blank" rel="noopener">http://www.liaohuqiu.net/cn/posts/leak-canary-read-me/</a>)</li>
</ul>
<p>1.注意Activity的泄露<br> Activity泄露是内存泄露最为严重的问题，涉及内存多，影响面广</p>
<p> 两种情形：</p>
<ul>
<li>内部类引用导致Activity的泄露<br> 典型的是Handler导致的Activity泄露，如果Handler中有延迟的任务或者等待执行的任务队列过长，很可能因为Handler继续执行造成Activity的泄露。<br> 引用链是Looper-&gt;MessageQueue-&gt;Message-&gt;handler-&gt;Activity,解决办法是在退出UI之前执行 remove Handler消息队列中的消息与runnable对象。或者使用Static+WeakReference的方式来判断Handler和Activity之间存在引用关系。</li>
<li>Activity Context被传递到其他实例中，可能导致自身被引用而发生泄露</li>
</ul>
<p>2.考虑使用Application Context而不是Activity Context<br> 除必须使用Activity Context的情况(Dialog的context必须是Activity),我们可以使用Application Context来避免Activity泄露</p>
<p>3.注意临时Bitmap的及时回收<br> 大多数情况下，我们对Bitmap对象增加缓存机制，但是有时候部分bitmap需要及时回收。比如我们临时创建的摸个相对大的bitmap对象，变换得到新的bitmap对象后，尽快回收原始的bitmap,及时释放原来的空间。</p>
<p>4.注意监听器的注销<br> android程序里面register后要及时释放unregister那些监听器，自己手动add的listener，要记得remove这个listener.</p>
<p>5.注意缓存容器的对象泄露<br> 有时候我们为了提高对象的复用性，把某些对象放到缓存容器中，如果这些对象没有及时从容器中清楚，也可能导致内存泄露，</p>
<p>6.注意webview的泄露<br> Android不同版本对webview产生有很大差异，较为严重的问题是webview的泄露，解决办法：为webview新开一个线程，通过AIDL与主进程通信，根据业务的需要在合适的时机进行销毁，从而达到内存的释放。</p>
<p>7.注意cursor对象是否关闭<br>我们在对数据库进行操作时，使用完cursor没有及时关闭，cursor的泄露，会对内存管理带来负面影响.</p>
<h4 id="内存使用策略优化"><a href="#内存使用策略优化" class="headerlink" title="内存使用策略优化"></a>内存使用策略优化</h4><p>1.谨慎使用large heap<br> android设备由于软硬件的差异，heap阀值不同，特殊情况下可以在manifest中使用largeheap=true声明一个更大的heap空间，使用getLargeMemoryClass()来获取到这个更大的空间。但是要谨慎使用，因为额外的空间会影响到系统整体的用户体验，并且会使每次gc的运行时间更长。切换任务时性能大打折扣，large heap并不一定能获取到更大的heap.</p>
<p>2.综合考虑设备内存阈值与其他因素设计合适的缓存大小<br>例如，在设计ListView或者GridView的Bitmap LRU缓存的时候，需要考虑的点有：</p>
<p>应用程序剩下了多少可用的内存空间?</p>
<ul>
<li>有多少图片会被一次呈现到屏幕上？有多少图片需要事先缓存好以便快速滑动时能够立即显示到屏幕？</li>
<li>设备的屏幕大小与密度是多少? 一个xhdpi的设备会比hdpi需要一个更大的Cache来hold住同样数量的图片。</li>
<li>不同的页面针对Bitmap的设计的尺寸与配置是什么，大概会花费多少内存？</li>
<li>页面图片被访问的频率？是否存在其中的一部分比其他的图片具有更高的访问频繁？如果是，也许你想要保存那些最常访问的到内存中，或者为不同组别的位图(按访问频率分组)设置多个LruCache容器。</li>
</ul>
<p>3.onLowMemory() 与onTrimMemory()<br> Android可以在不同的应用当中随意切换。为了让background转到foreground, 每一个background都会占用一定的内存。系统会根据内存的使用情况决定回收部分background的应用内存。background的应用从暂停状态恢复到foreground，比较快，如果从kill状态恢复比较慢。</p>
<p>4.资源文件需要选择合适的文件夹进行存放<br> 我们知道hdpi/xhdpi/xxhdpi等等不同dpi的文件夹下的图片在不同的设备上会经过scale的处理。例如我们只在hdpi的目录下放置了一张100X100的图片，那么根据换算关系，xxhdpi 的手机去引用那张图片就会被拉伸到200X200。需要注意到在这种情况下，内存占用是会显著提高的。对于不希望被拉伸的图片，需要放到assets或者nodpi的目录下。</p>
<p>5.Try catch某些大内存分配的操作<br>在某些情况下，我们需要事先评估那些可能发生OOM的代码，对于这些可能发生OOM的代码，加入catch机制，可以考虑在catch里面尝试一次降级的内存分配操作。例如decode bitmap的时候，catch到OOM，可以尝试把采样比例再增加一倍之后，再次尝试decode。</p>
<p>6.谨慎使用static对象<br>因为static的生命周期过长，和应用的进程保持一致，使用不当很可能导致对象泄漏，在Android中应该谨慎使用static对象。</p>
<p>7.特别留意单例对象中不合理的持有<br>虽然单例模式简单实用，提供了很多便利性，但是因为单例的生命周期和应用保持一致，使用不合理很容易出现持有对象的泄漏。</p>
<p>8.珍惜Services资源<br> 如果你的应用需要在后台使用service，除非它被触发并执行一个任务，否则其他时候Service都应该是停止状态。另外需要注意当这个service完成任务之后因为停止service失败而引起的内存泄漏。 当你启动一个Service，系统会倾向为了保留这个Service而一直保留Service所在的进程。这使得进程的运行代价很高，因为系统没有办法把Service所占用的RAM空间腾出来让给其他组件，另外Service还不能被Paged out。这减少了系统能够存放到LRU缓存当中的进程数量，它会影响应用之间的切换效率，甚至会导致系统内存使用不稳定，从而无法继续保持住所有目前正在运行的service。 建议使用<a href="https://link.jianshu.com?t=http://developer.android.com/reference/android/app/IntentService.html" target="_blank" rel="noopener">IntentService</a>，它会在处理完交代给它的任务之后尽快结束自己。更多信息，请阅读<a href="https://link.jianshu.com?t=http://developer.android.com/training/run-background-service/index.html" target="_blank" rel="noopener">Running in a Background Service</a>。</p>
<p>9.优化布局层次，减少内存消耗<br> 越扁平化的视图布局，占用的内存就越少，效率越高。我们需要尽量保证布局足够扁平化，当使用系统提供的View无法实现足够扁平的时候考虑使用自定义View来达到目的。</p>
<p>10.谨慎使用“抽象”编程<br> 很多时候，开发者会使用抽象类作为”好的编程实践”，因为抽象能够提升代码的灵活性与可维护性。然而，抽象会导致一个显著的额外内存开销：他们需要同等量的代码用于可执行，那些代码会被mapping到内存中，因此如果你的抽象没有显著的提升效率，应该尽量避免他们。</p>
<p>11.使用nano protobufs序列化数据<br> Protocol buffers是由Google为序列化结构数据而设计的，一种语言无关，平台无关，具有良好的扩展性。类似XML，却比XML更加轻量，快速，简单。如果你需要为你的数据实现序列化与协议化，建议使用nano protobufs。关于更多细节，请参考<a href="https://link.jianshu.com?t=https://android.googlesource.com/platform/external/protobuf/+/master/java/README.txt" target="_blank" rel="noopener">protobuf readme</a>的”Nano version”章节。</p>
<p>12.谨慎使用依赖注入框架<br>使用类似Guice或者RoboGuice等框架注入代码，在某种程度上可以简化你的代码。然而，那些注入框架会通过扫描你的代码执行许多初始化的操作，这会导致你的代码需要大量的内存空间来mapping代码，而且mapped pages会长时间的被保留在内存中。除非真的很有必要，建议谨慎使用这种技术。</p>
<p>13.谨慎使用多进程<br> 使用多进程可以把应用中的部分组件运行在单独的进程当中，这样可以扩大应用的内存占用范围，但是这个技术必须谨慎使用，绝大多数应用都不应该贸然使用多进程，一方面是因为使用多进程会使得代码逻辑更加复杂，另外如果使用不当，它可能反而会导致显著增加内存。当你的应用需要运行一个常驻后台的任务，而且这个任务并不轻量，可以考虑使用这个技术。</p>
<p>一个典型的例子是创建一个可以长时间后台播放的Music Player。如果整个应用都运行在一个进程中，当后台播放的时候，前台的那些UI资源也没有办法得到释放。类似这样的应用可以切分成2个进程：一个用来操作UI，另外一个给后台的Service。</p>
<p>14.使用ProGuard来剔除不需要的代码<br> <a href="https://link.jianshu.com?t=http://developer.android.com/tools/help/proguard.html" target="_blank" rel="noopener">ProGuard</a>能够通过移除不需要的代码，重命名类，域与方法等等对代码进行压缩，优化与混淆。使用ProGuard可以使得你的代码更加紧凑，这样能够减少mapping代码所需要的内存空间。</p>
<p>15.谨慎使用第三方libraries<br> 很多开源的library代码都不是为移动网络环境而编写的，如果运用在移动设备上，并不一定适合。即使是针对Android而设计的library，也需要特别谨慎，特别是在你不知道引入的library具体做了什么事情的时候。例如，其中一个library使用的是nano protobufs, 而另外一个使用的是micro protobufs。这样一来，在你的应用里面就有2种protobuf的实现方式。这样类似的冲突还可能发生在输出日志，加载图片，缓存等等模块里面。另外不要为了1个或者2个功能而导入整个library，如果没有一个合适的库与你的需求相吻合，你应该考虑自己去实现，而不是导入一个大而全的解决方案。</p>
<p>写在最后：</p>
<ul>
<li>设计风格很大程度上会影响到程序的内存与性能，相对来说，如果大量使用类似Material Design的风格，不仅安装包可以变小，还可以减少内存的占用，渲染性能与加载性能都会有一定的提升。</li>
<li>内存优化并不就是说程序占用的内存越少就越好，如果因为想要保持更低的内存占用，而频繁触发执行gc操作，在某种程度上反而会导致应用性能整体有所下降，这里需要综合考虑做一定的权衡。</li>
<li>Android的内存优化涉及的知识面还有很多：内存管理的细节，垃圾回收的工作原理，如何查找内存泄漏等等都可以展开讲很多。OOM是内存优化当中比较突出的一点，尽量减少OOM的概率对内存优化有着很大的意义。</li>
</ul>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>AWK 工具的使用(一)</title>
    <url>/AWK-%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8-%E4%B8%80/</url>
    <content><![CDATA[<h3 id="AWK介绍"><a href="#AWK介绍" class="headerlink" title="AWK介绍"></a>AWK介绍</h3><p>awk:Aho, Weinberger, Kernighan,报告生成器,格式化文本输出<br> 有多种版本:New awk(nawk),GNU awk( gawk)<br> gawk:模式扫描和处理语言<br> 基本用法:<br>    awk [options] ‘program’ var=value file…<br>    awk [options] -f programfile var=value file…<br>    awk [options] ‘BEGIN{ action;… } pattern{ action;… } END{ action;… }’ file …<br>    awk 程序通常由:BEGIN语句块、能够使用模式匹配的通用语句块、END语句块,共3部分组成<br>    program通常是被单引号或双引号中<br> 选项:<br>    -F 指明输入时用到的字段分隔符<br>    -v var=value: 自定义变量</p>
<h3 id="awk语言"><a href="#awk语言" class="headerlink" title="awk语言"></a>awk语言</h3><p>基本格式:awk [options] ‘program’ file…<br>program:pattern{action statements;..}<br>pattern和action:<br>• pattern部分决定动作语句何时触发及触发事件<br>    BEGIN,END<br>• action statements对数据进行处理,放在{}内指明<br>    print, printf<br>分割符、域和记录<br>• awk执行时,由分隔符分隔的字段(域)标记$1,$2..$n称为域标识.$0为所有域,注意:和shell中变量$符含义不同<br>• 文件的每一行称为记录<br>• 省略action,则默认执行 print $0 的操作</p>
<h3 id="awk工作原理"><a href="#awk工作原理" class="headerlink" title="awk工作原理"></a>awk工作原理</h3><p>第一步:执行BEGIN{action;… }语句块中的语句</p>
<p>第二步:从文件或标准输入(stdin)读取一行,然后执行pattern{ action;… }语句块,它逐行扫描文件,从第一行到最后一行重复这个过程,直到文件全部被读取完毕.</p>
<p>第三步:当读至输入流末尾时,执行END{action;…}语句块</p>
<p>BEGIN语句块在awk开始从输入流中读取行之前被执行,这是一个可选的语句块,比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中</p>
<p>END语句块在awk从输入流中读取完所有的行之后即被执行,比如打印所有行的分析结果这类信息汇总都是在END语句块中完成,它也是一个可选语句块</p>
<p>pattern语句块中的通用命令是最重要的部分,也是可选的.如果没有提供pattern语句块,则默认执行{ print },即打印每一个读取到的行,awk读取的每一行都会执行该语句块</p>
<h3 id="awk格式与示例"><a href="#awk格式与示例" class="headerlink" title="awk格式与示例"></a>awk格式与示例</h3><p>print格式: print item1, item2, …<br> 要点:<br>    (1) 逗号分隔符<br>    (2) 输出的各item可以字符串,也可以是数值；当前记录的字段、变量或awk的表达式<br>    (3) 如省略item,相当于print $0<br> 示例:<br>    awk ‘{print “hello,awk”}’<br>    awk –F: ‘{print}’ /etc/passwd<br>    awk –F: ‘{print “wang”}’ /etc/passwd<br>    awk –F: ‘{print $1}’ /etc/passwd<br>    awk –F: ‘{print $0}’ /etc/passwd<br>    awk –F: ‘{print $1”\t”$3}’ /etc/passwd<br>    tail –3 /etc/fstab |awk ‘{print $2,$4}’</p>
<h3 id="awk变量与参数"><a href="#awk变量与参数" class="headerlink" title="awk变量与参数"></a>awk变量与参数</h3><p>变量:内置和自定义变量<br> FS:输入字段分隔符,默认为空白字符<br>    awk -v FS=’:’ ‘{print $1,FS,$3}’ /etc/passwd<br>    awk –F: ‘{print $1,$3,$7}’ /etc/passwd<br> OFS:输出字段分隔符,默认为空白字符<br>    awk -v FS=‘:’ -v OFS=‘:’ ‘{print $1,$3,$7}’ /etc/passwd<br> RS:输入记录分隔符,指定输入时的换行符<br>    awk -v RS=’ ‘ ‘{print }’ /etc/passwd<br> ORS:输出记录分隔符,输出时用指定符号代替换行符<br>    awk -v RS=’ ‘ -v ORS=’###’‘{print }’ /etc/passwd<br> NF:字段数量<br>    awk -F: ‘{print NF}’ /etc/fstab,引用内置变量不用$<br>    awk -F: ‘{print $(NF-1)}’ /etc/passwd<br> NR:记录号<br>    awk ‘{print NR}’ /etc/fstab ; awk END’{print NR}’ /etc/fstab</p>
<p>FNR:各文件分别计数,记录号<br>    awk ‘{print FNR}’ /etc/fstab /etc/inittab<br>FILENAME:当前文件名<br>    awk ‘{print FILENAME}’ /etc/fstab<br>ARGC:命令行参数的个数<br>    awk ‘{print ARGC}’ /etc/fstab /etc/inittab<br>    awk ‘BEGIN {print ARGC}’ /etc/fstab /etc/inittab<br>ARGV:数组,保存的是命令行所给定的各参数<br>    awk ‘BEGIN {print ARGV[0]}’ /etc/fstab /etc/inittab<br>    awk ‘BEGIN {print ARGV[1]}’ /etc/fstab /etc/inittab</p>
<p>自定义变量(区分字符大小写)<br>    (1) -v var=value<br>    (2) 在program中直接定义<br>示例:<br>    awk -v test=’hello gawk’ ‘{print test}’ /etc/fstab<br>    awk -v test=’hello gawk’ ‘BEGIN{print test}’<br>    awk ‘BEGIN{test=”hello,gawk”;print test}’<br>    awk –F:‘{sex=“male”;print $1,sex,age;age=18}’    /etc/passwd<br>    cat awkscript<br>    {print script,$1,$2}<br>    awk -F: -f awkscript script=“awk” /etc/passwd</p>
<h3 id="printf命令"><a href="#printf命令" class="headerlink" title="printf命令"></a>printf命令</h3><p>格式化输出:printf “FORMAT”, item1, item2, …<br>    (1) 必须指定FORMAT<br>    (2) 不会自动换行,需要显式给出换行控制符,\n<br>    (3) FORMAT中需要分别为后面每个item指定格式符<br> 格式符:与item一一对应<br>    %c: 显示字符的ASCII码<br>    %d, %i: 显示十进制整数<br>    %e, %E:显示科学计数法数值<br>    %f:显示为浮点数<br>    %g, %G:以科学计数法或浮点形式显示数值<br>    %s:显示字符串<br>    %u:无符号整数<br>    %%: 显示%自身<br> 修饰符:<br>    #[.#]:第一个数字控制显示的宽度；第二个#表示小数点后精度,%3.1f<br>    -: 左对齐(默认右对齐) %-15s<br>    +:显示数值的正负符号 %+d</p>
<h3 id="printf示例"><a href="#printf示例" class="headerlink" title="printf示例"></a>printf示例</h3><p>awk -F: ‘{printf “%s”,$1}’ /etc/passwd<br>awk -F: ‘{printf “%s\n”,$1}’ /etc/passwd<br>awk -F: ‘{printf “%-20s %10d\n”,$1,$3}’ /etc/passwd<br>awk -F: ‘{printf “Username: %s\n”,$1}’ /etc/passwd<br>awk -F: ‘{printf “Username: %s,UID:%d\n”,$1,$3}’ /etc/passwd<br>awk -F: ‘{printf “Username: %15s,UID:%d\n”,$1,$3}’ /etc/passwd<br>awk -F: ‘{printf “Username: %-15s,UID:%d\n”,$1,$3}’ /etc/passwd</p>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>算术操作符:<br>    x+y, x-y, x*y, x/y, x^y, x%y<br>    -x: 转换为负数<br>    +x: 转换为数值<br>字符串操作符:没有符号的操作符,字符串连接<br>赋值操作符:<br>    =, +=, -=, *=, /=, %=, ^=<br>    ++, –<br>比较操作符:<br>    ==, !=, &gt;, &gt;=, &lt;, &lt;=<br>模式匹配符:<br>    <del>:左边是否和右边匹配包含 !</del>:是否不匹配<br>示例:<br>    awk –F: ‘$0 ~ /root/{print $1}‘ /etc/passwd<br>    awk ‘$0<del>“^root”‘ /etc/passwd<br>    awk ‘$0 !</del> /root/‘ /etc/passwd<br>    awk –F: ‘$3==0’ /etc/passwd</p>
<p>逻辑操作符:与&amp;&amp;,或||,非!<br> 示例:<br>• awk –F: ‘$3&gt;=0 &amp;&amp; $3&lt;=1000 {print $1}’ /etc/passwd<br>• awk -F: ‘$3==0 || $3&gt;=1000 {print $1}’ /etc/passwd<br>• awk -F: ‘!($3==0) {print $1}’ /etc/passwd<br>• awk -F: ‘!($3&gt;=500) {print $3}’ /etc/passwd<br> 函数调用: function_name(argu1, argu2, …)<br> 条件表达式(三目表达式):<br>    selector?if-true-expression:if-false-expression<br>• 示例:<br>    awk -F: ‘{$3&gt;=1000?usertype=”Common User”:usertype=”Sysadmin or SysUser”;printf<br>“%15s:%-s\n”,$1,usertype}’ /etc/passwd</p>
<h3 id="awk-PATTERN"><a href="#awk-PATTERN" class="headerlink" title="awk PATTERN"></a>awk PATTERN</h3><p>PATTERN:根据pattern条件,过滤匹配的行,再做处理<br>(1)如果未指定:空模式,匹配每一行<br>(2) /regular expression/:仅处理能够模式匹配到的行,需要用/ /括起来<br>    awk ‘/^UUID/{print $1}’ /etc/fstab<br>    awk ‘!/^UUID/{print $1}’ /etc/fstab<br>(3) relational expression: 关系表达式,结果为“真”才会被处理<br>    真:结果为非0值,非空字符串<br>    假:结果为空字符串或0值<br> 示例:<br>• awk -F: ‘i=1;j=1{print i,j}’ /etc/passwd<br>• awk ‘!0’ /etc/passwd ; awk ‘!1’ /etc/passwd<br>• awk –F: ‘$3&gt;=1000{print $1,$3}’ /etc/passwd<br>• awk -F: ‘$3&lt;1000{print $1,$3}’ /etc/passwd<br>• awk -F: ‘$NF==”/bin/bash”{print $1,$NF}’ /etc/passwd<br>• awk -F: ‘$NF ~ /bash$/{print $1,$NF}’ /etc/passwd</p>
<p>4) line ranges:行范围<br>    startline,endline:/pat1/,/pat2/ 不支持直接给出数字格式<br>    awk -F: ‘/^root&gt;/,/^nobody&gt;/{print $1}’ /etc/passwd<br>    awk -F: ‘(NR&gt;=10&amp;&amp;NR&lt;=20){print NR,$1}’ /etc/passwd<br>(5) BEGIN/END模式<br>    BEGIN{}: 仅在开始处理文件中的文本之前执行一次<br>    END{}:仅在文本处理完成之后执行一次</p>
<p>awk例程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk -F : 'BEGIN &#123;print "USER USERID"&#125; &#123;print $1":"$3&#125; END&#123;print "end file"&#125;'</span><br><span class="line">/etc/passwd</span><br><span class="line">awk -F : '&#123;print "USER USERID“;print $1":"$3&#125; END&#123;print "end file"&#125;' /etc/passwd</span><br><span class="line">awk -F: 'BEGIN&#123;print " USER UID \n--------------- "&#125;&#123;print $1,$3&#125;' /etc/passwd</span><br><span class="line">awk -F: 'BEGIN&#123;print " USER UID \n--------------- "&#125;&#123;print $1,$3&#125;'END&#123;print</span><br><span class="line">"=============="&#125; /etc/passwd</span><br><span class="line">seq 10 |awk ‘i=0’</span><br><span class="line">seq 10 |awk ‘i=1’</span><br><span class="line">seq 10 | awk 'i=!i‘</span><br><span class="line">seq 10 | awk '&#123;i=!i;print i&#125;‘</span><br><span class="line">seq 10 | awk ‘!(i=!i)’</span><br><span class="line">seq 10 |awk -v i=1 'i=!i'</span><br></pre></td></tr></table></figure>



<h3 id="awk-action"><a href="#awk-action" class="headerlink" title="awk action"></a>awk action</h3><p>常用的action分类<br>• (1) Expressions:算术,比较表达式等<br>• (2) Control statements:if, while等<br>• (3) Compound statements:组合语句<br>• (4) input statements<br>• (5) output statements:print等</p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>AWK</tag>
      </tags>
  </entry>
  <entry>
    <title>AWK 工具的使用(二)</title>
    <url>/AWK-%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8-%E4%BA%8C/</url>
    <content><![CDATA[<h3 id="awk控制语句"><a href="#awk控制语句" class="headerlink" title="awk控制语句"></a>awk控制语句</h3><p>{ statements;… } 组合语句<br>if(condition) {statements;…}<br>if(condition) {statements;…} else {statements;…}<br>while(conditon) {statments;…}<br>do {statements;…} while(condition)<br>for(expr1;expr2;expr3) {statements;…}<br>break<br>continue<br>delete array[index]<br>delete array<br>exit</p>
<h3 id="awk控制语句-if-else"><a href="#awk控制语句-if-else" class="headerlink" title="awk控制语句 if-else"></a>awk控制语句 if-else</h3><p>语法:if(condition){statement;…}[else statement]<br>if(condition1){statement1}else if(condition2){statement2}<br>else{statement3}<br> 使用场景:对awk取得的整行或某个字段做条件判断<br> 例程:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk -F: '&#123;if($3&gt;=1000)print $1,$3&#125;' /etc/passwd</span><br><span class="line">awk -F: '&#123;if($NF=="/bin/bash") print $1&#125;' /etc/passwd</span><br><span class="line">awk '&#123;if(NF&gt;5) print $0&#125;' /etc/fstab</span><br><span class="line">awk -F: '&#123;if($3&gt;=1000) &#123;printf "Common user: %s\n",$1&#125; else &#123;printf "root or Sysuser: %s\n",$1&#125;&#125;'</span><br><span class="line">/etc/passwd</span><br><span class="line">awk -F: '&#123;if($3&gt;=1000) printf "Common user: %s\n",$1; else printf "root or Sysuser: %s\n",$1&#125;'</span><br><span class="line">/etc/passwd</span><br><span class="line">df -h|awk -F% '/^\/dev/&#123;print $1&#125;'|awk '$NF&gt;=80&#123;print $1,$5&#125;‘</span><br><span class="line">awk 'BEGIN&#123; test=100;if(test&gt;90)&#123;print "very good“&#125;else if(test&gt;60)&#123; print "good"&#125;else&#123;print "no pass"&#125;&#125;'</span><br></pre></td></tr></table></figure>



<h3 id="awk控制语句-while"><a href="#awk控制语句-while" class="headerlink" title="awk控制语句 while"></a>awk控制语句 while</h3><p>while循环<br>语法:while(condition){statement;…}<br>条件“真”,进入循环；条件“假”,退出循环<br>使用场景:<br>对一行内的多个字段逐一类似处理时使用<br>对数组中的各元素逐一处理时使用<br>示例:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk '/^[[:space:]]*linux16/&#123;i=1;while(i&lt;=NF)</span><br><span class="line">&#123;print $i,length($i); i++&#125;&#125;' /etc/grub2.cfg</span><br><span class="line">awk ‘/^[[:space:]]*linux16/&#123;i=1;while(i&lt;=NF) &#123;if(length($i)&gt;=10) &#123;print</span><br><span class="line"><span class="meta">$</span><span class="bash">i,length(<span class="variable">$i</span>)&#125;; i++&#125;&#125;’ /etc/grub2.cfg</span></span><br></pre></td></tr></table></figure>



<h3 id="awk控制语句-do-while"><a href="#awk控制语句-do-while" class="headerlink" title="awk控制语句 do-while"></a>awk控制语句 do-while</h3><p>do-while循环<br>语法:do {statement;…}while(condition)<br>意义:无论真假,至少执行一次循环体</p>
<p>例程:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk 'BEGIN&#123; total=0;i=0;do&#123; total+=i;i++;&#125;while(i&lt;=100);print total&#125;’</span><br></pre></td></tr></table></figure>

<p>for循环<br>语法:for(expr1;expr2;expr3) {statement;…}<br>常见用法:<br>for(variable assignment;condition;iteration process)<br>{for-body}<br>特殊用法:能够遍历数组中的元素<br>语法:for(var in array) {for-body}</p>
<p>例程:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk '/^[[:space:]]*linux16/&#123;for(i=1;i&lt;=NF;i++) &#123;print $i,length($i)&#125;&#125;'</span><br><span class="line">/etc/grub2.cfg</span><br></pre></td></tr></table></figure>

<h3 id="awk控制语句-switch"><a href="#awk控制语句-switch" class="headerlink" title="awk控制语句 switch"></a>awk控制语句 switch</h3><p>语法:switch(expression) {case VALUE1 or /REGEXP/: statement1; case<br>VALUE2 or /REGEXP2/: statement2; …; default: statementn}</p>
<p>break和continue<br>• awk ‘BEGIN{sum=0;for(i=1;i&lt;=100;i++)<br>    {if(i%2==0)continue;sum+=i}print sum}‘<br>• awk ‘BEGIN{sum=0;for(i=1;i&lt;=100;i++)<br>    {if(i==66)break;sum+=i}print sum}‘ </p>
<h3 id="awk控制语句-break-continue"><a href="#awk控制语句-break-continue" class="headerlink" title="awk控制语句 break continue"></a>awk控制语句 break continue</h3><p>break [n]<br>continue [n]<br>next:<br>提前结束对本行处理而直接进入下一行处理(awk自身循环)<br>awk -F: ‘{if($3%2!=0) next; print $1,$3}’ /etc/passwd</p>
<h3 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">time (awk 'BEGIN&#123; total=0;for(i=0;i&lt;=10000;i++)&#123;total+=i;&#125;;print total;&#125;')</span><br><span class="line">time(total=0;for i in &#123;1..10000&#125;;do total=$(($total+i));done;echo $total)</span><br><span class="line">time(for ((i=0;i&lt;=10000;i++));do let total+=i;done;echo $total)</span><br><span class="line">time(seq –s ”+” 10000|bc)</span><br></pre></td></tr></table></figure>



<h3 id="awk数组"><a href="#awk数组" class="headerlink" title="awk数组"></a>awk数组</h3><p>关联数组:array[index-expression]<br>index-expression:<br>• (1) 可使用任意字符串；字符串要使用双引号括起来<br>• (2) 如果某数组元素事先不存在,在引用时,awk会自动创建此元素,并将其值<br>初始化为“空串”<br>• 若要判断数组中是否存在某元素,要使用“index in array”格式进行遍历</p>
<p>例程:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">weekdays[“mon”]="Monday“</span><br><span class="line">awk 'BEGIN&#123;weekdays["mon"]="Monday";</span><br><span class="line">weekdays["tue"]="Tuesday";print weekdays["mon"]&#125;‘</span><br><span class="line">awk ‘!arr[$0]++’ dupfile</span><br><span class="line">awk '&#123;!arr[$0]++;print $0, arr[$0]&#125;' dupfile</span><br></pre></td></tr></table></figure>

<p>若要遍历数组中的每个元素,要使用for循环<br>for(var in array) {for-body}<br>注意:var会遍历array的每个索引</p>
<p>例程:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk 'BEGIN&#123;weekdays["mon"]="Monday";weekdays["tue"]</span><br><span class="line">="Tuesday";for(i in weekdays) &#123;print weekdays[i]&#125;&#125;‘</span><br><span class="line">netstat -tan | awk '/^tcp/&#123;state[$NF]++&#125;END</span><br><span class="line">&#123;for(i in state) &#123; print i,state[i]&#125;&#125;'</span><br><span class="line">awk '&#123;ip[$1]++&#125;END&#123;for(i in ip) &#123;print i,ip[i]&#125;&#125;' /var/log/httpd/access_log</span><br></pre></td></tr></table></figure>



<h3 id="awk函数"><a href="#awk函数" class="headerlink" title="awk函数"></a>awk函数</h3><p>数值处理:<br>    rand():返回0和1之间一个随机数<br>awk ‘BEGIN{srand(); for (i=1;i&lt;=10;i++)print int(rand()*100) }’<br> 字符串处理:<br>• length([s]):返回指定字符串的长度<br>• sub(r,s,[t]):对t字符串进行搜索r表示的模式匹配的内容,并将第一个匹配的内容替换为s<br>    echo “2008:08:08 08:08:08” | awk ‘sub(/:/,“-“,$1)’<br>• gsub(r,s,[t]):对t字符串进行搜索r表示的模式匹配的内容,并全部替换为s所表示的内容<br>    echo “2008:08:08 08:08:08” | awk ‘gsub(/:/,“-“,$0)’<br>• split(s,array,[r]):以r为分隔符,切割字符串s,并将切割后的结果保存至array所表示的数组中,<br>第一个索引值为1,第二个索引值为2,…<br>    netstat -tan | awk ‘/^tcp&gt;/{split($5,ip,”:”);count[ip[1]]++}<br>END{for (i in count) {print i,count[i]}}’</p>
<p><strong>自定义函数</strong></p>
<p> 格式:<br>    function name ( parameter, parameter, … ) {<br>        statements<br>        return expression<br>    }<br> 示例:<br>    cat fun.awk<br>    function max(v1,v2) {<br>        v1&gt;v2?var=v1:var=v2<br>        return var<br>    }<br>    BEGIN{a=3;b=2;print max(a,b)}<br>awk –f fun.awk</p>
<h3 id="awk中调用shell命令"><a href="#awk中调用shell命令" class="headerlink" title="awk中调用shell命令"></a>awk中调用shell命令</h3><p>system命令<br>空格是awk中的字符串连接符,如果system中需要使用awk中的变量可以使用<br>空格分隔,或者说除了awk的变量外其他一律用””引用起来.<br>    awk BEGIN’{system(“hostname”) }’<br>    awk ‘BEGIN{score=100; system(“echo your score is “ score) }</p>
<h3 id="awk脚本"><a href="#awk脚本" class="headerlink" title="awk脚本"></a>awk脚本</h3><p>将awk程序写成脚本,直接调用或执行<br>示例:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat f1.awk</span><br><span class="line">	&#123;if($3&gt;=1000)print $1,$3&#125;</span><br><span class="line">awk -F: -f f1.awk /etc/passwd</span><br><span class="line"></span><br><span class="line">cat f2.awk</span><br><span class="line"><span class="meta">	#</span><span class="bash">!/bin/awk –f</span></span><br><span class="line"><span class="meta">	#</span><span class="bash">this is a awk script</span></span><br><span class="line">	&#123;if($3&gt;=1000)print $1,$3&#125;</span><br><span class="line">chmod +x f2.awk</span><br><span class="line">f2.awk –F: /etc/passwd</span><br></pre></td></tr></table></figure>



<h3 id="向awk脚本传递参数"><a href="#向awk脚本传递参数" class="headerlink" title="向awk脚本传递参数"></a>向awk脚本传递参数</h3><p>格式:<br>    awkfile var=value var2=value2… Inputfile<br>注意:在BEGIN过程中不可用.直到首行输入完成以后,变量才可用.可以通过-v 参数,让awk在执行BEGIN之前得到变量的值.命令行中每一个指定的变量都需要一个-v参数<br>示例:<br>    cat test.awk<br>    #!/bin/awk –f<br>    {if($3 &gt;=min &amp;&amp; $3&lt;=max)print $1,$3}<br>    chmod +x test.awk<br>    test.awk -F: min=100 max=200 /etc/passwd</p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>AWK</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中Handler的使用</title>
    <url>/Android%E4%B8%ADHandler%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>在Android开发中,我们经常会遇到这样一种情况:在UI界面上进行某项操作后要执行一段很耗时的代码,比如我们在界面上点击了一个”下载“按钮,那么我们需要执行网络请求,这是一个耗时操作,因为不知道什么时候才能完成.为了保证不影响UI线程,所以我们会创建一个新的线程去执行我们的耗时的代码.当我们的耗时操作完成时,我们需要更新UI界面以告知用户操作完成了.所以我们可能会写出如下的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ispring.com.testhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">Button</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView statusTextView = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        statusTextView = (TextView)findViewById(R.id.statusTextView);</span><br><span class="line">        Button btnDownload = (Button)findViewById(R.id.btnDownload);</span><br><span class="line">        btnDownload.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        DownloadThread downloadThread = <span class="keyword">new</span> DownloadThread();</span><br><span class="line">        downloadThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DownloadThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"开始下载文件"</span>);</span><br><span class="line">                <span class="comment">//此处让线程DownloadThread休眠5秒中,模拟文件的耗时过程</span></span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.out.println(<span class="string">"文件下载完成"</span>);</span><br><span class="line">                <span class="comment">//文件下载完成后更新UI</span></span><br><span class="line">                MainActivity.<span class="keyword">this</span>.statusTextView.setText(<span class="string">"文件下载完成"</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码演示了单击”下载“按钮后会启动一个新的线程去执行实际的下载操作,执行完毕后更新UI界面.但是在实际运行到代码MainActivity.this.statusTextView.setText(“文件下载完成”)时,会报错如下,系统崩溃退出:<br><code>android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.</code><br>错误的意思是只有创建View的原始线程才能更新View.出现这样错误的原因是Android中的View不是线程安全的,在Android应用启动时,会自动创建一个线程,即程序的主线程,主线程负责UI的展示、UI事件消息的派发处理等等,因此主线程也叫做UI线程,statusTextView是在UI线程中创建的,当我们在DownloadThread线程中去更新UI线程中创建的statusTextView时自然会报上面的错误.Android的UI控件是非线程安全的,其实很多平台的UI控件都是非线程安全的,比如C#的.Net Framework中的UI控件也是非线程安全的,所以不仅仅在Android平台中存在从一个新线程中去更新UI线程中创建的UI控件的问题.不同的平台提供了不同的解决方案以实现跨线程跟新UI控件,Android为了解决这种问题引入了Handler机制.</p>
<p>那么Handler到底是什么呢？Handler是Android中引入的一种让开发者参与处理线程中消息循环的机制.每个Hanlder都关联了一个线程,每个线程内部都维护了一个消息队列MessageQueue,这样Handler实际上也就关联了一个消息队列.可以通过Handler将Message和Runnable对象发送到该Handler所关联线程的MessageQueue（消息队列）中,然后该消息队列一直在循环拿出一个Message,对其进行处理,处理完之后拿出下一个Message,继续进行处理,周而复始.当创建一个Handler的时候,该Handler就绑定了当前创建Hanlder的线程.从这时起,该Hanlder就可以发送Message和Runnable对象到该Handler对应的消息队列中,当从MessageQueue取出某个Message时,会让Handler对其进行处理.</p>
<p>Handler可以用来在多线程间进行通信,在另一个线程中去更新UI线程中的UI控件只是Handler使用中的一种典型案例,除此之外,Handler可以做很多其他的事情.每个Handler都绑定了一个线程,假设存在两个线程ThreadA和ThreadB,并且HandlerA绑定了 ThreadA,在ThreadB中的代码执行到某处时,出于某些原因,我们需要让ThreadA执行某些代码,此时我们就可以使用Handler,我们可以在ThreadB中向HandlerA中加入某些信息以告知ThreadA中该做某些处理了.由此可以看出,Handler是Thread的代言人,是多线程之间通信的桥梁,通过Handler,我们可以在一个线程中控制另一个线程去做某事.</p>
<p>Handler提供了两种方式解决我们在本文一开始遇到的问题（在一个新线程中更新主线程中的UI控件）,一种是通过post方法,一种是调用sendMessage方法.</p>
<p>a. 使用post方法,代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ispring.com.testhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">Button</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView statusTextView = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//uiHandler在主线程中创建,所以自动绑定主线程</span></span><br><span class="line">    <span class="keyword">private</span> Handler uiHandler = <span class="keyword">new</span> Handler();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        statusTextView = (TextView)findViewById(R.id.statusTextView);</span><br><span class="line">        Button btnDownload = (Button)findViewById(R.id.btnDownload);</span><br><span class="line">        btnDownload.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        System.out.println(<span class="string">"Main thread id "</span> + Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        DownloadThread downloadThread = <span class="keyword">new</span> DownloadThread();</span><br><span class="line">        downloadThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DownloadThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"DownloadThread id "</span> + Thread.currentThread().getId());</span><br><span class="line">                System.out.println(<span class="string">"开始下载文件"</span>);</span><br><span class="line">                <span class="comment">//此处让线程DownloadThread休眠5秒中,模拟文件的耗时过程</span></span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.out.println(<span class="string">"文件下载完成"</span>);</span><br><span class="line">                <span class="comment">//文件下载完成后更新UI</span></span><br><span class="line">                Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"Runnable thread id "</span> + Thread.currentThread().getId());</span><br><span class="line">                        MainActivity.<span class="keyword">this</span>.statusTextView.setText(<span class="string">"文件下载完成"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                uiHandler.post(runnable);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在Activity中创建了一个Handler成员变量uiHandler,Handler有个特点,在执行new Handler()的时候,默认情况下Handler会绑定当前代码执行的线程,我们在主线程中实例化了uiHandler,所以uiHandler就自动绑定了主线程,即UI线程.当我们在DownloadThread中执行完耗时代码后,我们将一个Runnable对象通过post方法传入到了Handler中,Handler会在合适的时候让主线程执行Runnable中的代码,这样Runnable就在主线程中执行了,从而正确更新了主线程中的UI.</p>
<p>通过输出结果可以看出,Runnable中的代码所执行的线程ID与DownloadThread的线程ID不同,而与主线程的线程ID相同,因此我们也由此看出在执行了Handler.post(Runnable)这句代码之后,运行Runnable代码的线程与Handler所绑定的线程是一致的,而与执行Handler.post(Runnable)这句代码的线程（DownloadThread）无关.</p>
<p>b. 使用sendMessage方法,代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ispring.com.testhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">Button</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView statusTextView = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//uiHandler在主线程中创建,所以自动绑定主线程</span></span><br><span class="line">    <span class="keyword">private</span> Handler uiHandler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    System.out.println(<span class="string">"handleMessage thread id "</span> + Thread.currentThread().getId());</span><br><span class="line">                    System.out.println(<span class="string">"msg.arg1:"</span> + msg.arg1);</span><br><span class="line">                    System.out.println(<span class="string">"msg.arg2:"</span> + msg.arg2);</span><br><span class="line">                    MainActivity.<span class="keyword">this</span>.statusTextView.setText(<span class="string">"文件下载完成"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        statusTextView = (TextView)findViewById(R.id.statusTextView);</span><br><span class="line">        Button btnDownload = (Button)findViewById(R.id.btnDownload);</span><br><span class="line">        btnDownload.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        System.out.println(<span class="string">"Main thread id "</span> + Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        DownloadThread downloadThread = <span class="keyword">new</span> DownloadThread();</span><br><span class="line">        downloadThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DownloadThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"DownloadThread id "</span> + Thread.currentThread().getId());</span><br><span class="line">                System.out.println(<span class="string">"开始下载文件"</span>);</span><br><span class="line">                <span class="comment">//此处让线程DownloadThread休眠5秒中,模拟文件的耗时过程</span></span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.out.println(<span class="string">"文件下载完成"</span>);</span><br><span class="line">                <span class="comment">//文件下载完成后更新UI</span></span><br><span class="line">                Message msg = <span class="keyword">new</span> Message();</span><br><span class="line">                <span class="comment">//虽然Message的构造函数式public的,我们也可以通过以下两种方式通过循环对象获取Message</span></span><br><span class="line">                <span class="comment">//msg = Message.obtain(uiHandler);</span></span><br><span class="line">                <span class="comment">//msg = uiHandler.obtainMessage();</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//what是我们自定义的一个Message的识别码,以便于在Handler的handleMessage方法中根据what识别</span></span><br><span class="line">                <span class="comment">//出不同的Message,以便我们做出不同的处理操作</span></span><br><span class="line">                msg.what = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//我们可以通过arg1和arg2给Message传入简单的数据</span></span><br><span class="line">                msg.arg1 = <span class="number">123</span>;</span><br><span class="line">                msg.arg2 = <span class="number">321</span>;</span><br><span class="line">                <span class="comment">//我们也可以通过给obj赋值Object类型传递向Message传入任意数据</span></span><br><span class="line">                <span class="comment">//msg.obj = null;</span></span><br><span class="line">                <span class="comment">//我们还可以通过setData方法和getData方法向Message中写入和读取Bundle类型的数据</span></span><br><span class="line">                <span class="comment">//msg.setData(null);</span></span><br><span class="line">                <span class="comment">//Bundle data = msg.getData();</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//将该Message发送给对应的Handler</span></span><br><span class="line">                uiHandler.sendMessage(msg);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过Message与Handler进行通信的步骤是: </p>
<ol>
<li>重写Handler的handleMessage方法,根据Message的what值进行不同的处理操作 </li>
<li>创建Message对象<br> 虽然Message的构造函数式public的,我们还可以通过Message.obtain()或Handler.obtainMessage()来获得一个Message对象（Handler.obtainMessage()内部其实调用了Message.obtain()）. </li>
<li>设置Message的what值<br> Message.what是我们自定义的一个Message的识别码,以便于在Handler的handleMessage方法中根据what识别出不同的Message,以便我们做出不同的处理操作. </li>
<li>设置Message的所携带的数据,简单数据可以通过两个int类型的field arg1和arg2来赋值,并可以在handleMessage中读取. </li>
<li>如果Message需要携带复杂的数据,那么可以设置Message的obj字段,obj是Object类型,可以赋予任意类型的数据.或者可以通过调用Message的setData方法赋值Bundle类型的数据,可以通过getData方法获取该Bundle数据. </li>
<li>我们通过Handler.sendMessage(Message)方法将Message传入Handler中让其在handleMessage中对其进行处理.<br> 需要说明的是,如果在handleMessage中 不需要判断Message类型,那么就无须设置Message的what值；而且让Message携带数据也不是必须的,只有在需要的时候才需要让其携带数据；如果确实需要让Message携带数据,应该尽量使用arg1或arg2或两者,能用arg1和arg2解决的话就不要用obj,因为用arg1和arg2更高效.</li>
</ol>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言简介(一)</title>
    <url>/Go-%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B-%E4%B8%80/</url>
    <content><![CDATA[<p>为了解决在21世纪多核和网络化环境下越来越复杂的编程问题而发明了Go语言,编程语言的演化就像生物物种的演化一样,一个成功的编程语言的后代都会继承他们祖先的优点,当然有时多种语言杂合也会产生令人惊讶的特性,还有一些激进的新特性可能并没有先例,我们可以通过观察编程语言和软硬件环境是如何相互促进,相互影响的演化过程而学到很多.</p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_go_learning_01.png" alt=""></p>
<p>Go语言有时候被描述成”C类似语言”或者”21世纪的C语言”.Go从C语言继承了相似的表达语法,流程控制,基础数据类型,调用参数传值,指针等很多思想,还有C语言一直所看重的编译后机器码的运行效率以及和现有操作系统的无缝适配.</p>
<h4 id="开始一个-Hello-World"><a href="#开始一个-Hello-World" class="headerlink" title="开始一个 Hello World"></a>开始一个 Hello World</h4><p>文件名后缀 hello.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main <span class="comment">//声明本文件的package名</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span> <span class="comment">//import语言的fmt库——用于输出</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>有两种方式可以运行</p>
<ul>
<li>解释执行(将源码编译成a.out再执行)</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$<span class="keyword">go</span> run hello.<span class="keyword">go</span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<ul>
<li>编译执行</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$<span class="keyword">go</span> build hello.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line">$ls</span><br><span class="line">hello hello.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line">$./hello</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<h4 id="自己的package"><a href="#自己的package" class="headerlink" title="自己的package"></a>自己的package</h4><p>可以使用GOPATH环境变量，或是使用相对路径来import你自己的package。</p>
<p>Go的规约是这样的：</p>
<p>1）<strong>在import中，你可以使用相对路径，如 ./或 ../ 来引用你的package</strong></p>
<p>2）<strong>如果没有使用相对路径，那么，go会去找$GOPATH/src/目录。</strong></p>
<p>使用相对路径:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span><span class="string">` `</span><span class="string">"./haoel"</span><span class="string">`  `</span><span class="comment">//import当前目录里haoel子目录里的所有的go文件</span></span><br></pre></td></tr></table></figure>

<p>使用GOPATH路径</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">`import`</span> <span class="string">`"./haoel"`</span>  <span class="string">`//import当前目录里haoel子目录里的所有的go文件`</span></span><br></pre></td></tr></table></figure>

<h4 id="fmt输出格式"><a href="#fmt输出格式" class="headerlink" title="fmt输出格式"></a>fmt输出格式</h4><p>fmt包和libc里的那堆使用printf， scanf，fprintf，fscanf 很相似。下面的东西对于C程序员不会陌生。</p>
<p>注意：println不支持，printf才支持%式的输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"math"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello world"</span>)</span><br><span class="line"> </span><br><span class="line">    fmt.Printf(<span class="string">"%t\n"</span>, <span class="number">1</span>==<span class="number">2</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"二进制：%b\n"</span>, <span class="number">255</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"八进制：%o\n"</span>, <span class="number">255</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"十六进制：%X\n"</span>, <span class="number">255</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"十进制：%d\n"</span>, <span class="number">255</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"浮点数：%f\n"</span>, math.Pi)</span><br><span class="line">    fmt.Printf(<span class="string">"字符串：%s\n"</span>, <span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用如\n\t\r这样的和C语言一样的控制字符</p>
<h4 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h4><p>变量的声明很像 javascript，使用 var关键字。注意：<strong>go是静态类型的语言</strong>，下面是代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明初始化一个变量</span></span><br><span class="line"><span class="keyword">var</span>  x <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line">var str string = "hello world"&lt;/pre&gt;</span><br><span class="line"><span class="comment">//声明初始化多个变量</span></span><br><span class="line"><span class="keyword">var</span>  i, j, k <span class="keyword">int</span> = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//不用指明类型，通过初始化值来推导</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span> <span class="comment">//bool型</span></span><br></pre></td></tr></table></figure>

<p>还有一种定义变量的方式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := <span class="number">100</span> <span class="comment">//等价于 var x int = 100;</span></span><br></pre></td></tr></table></figure>

<p>常量很简单，使用const关键字：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s <span class="keyword">string</span> = <span class="string">"hello world"</span></span><br><span class="line"><span class="keyword">const</span> pi <span class="keyword">float32</span> = <span class="number">3.1415926</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>数组</p>
</blockquote>
<p>直接看代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line">    fmt.Println(<span class="string">"array a:"</span>, a)</span><br><span class="line"> </span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line">    a[<span class="number">3</span>] = <span class="number">30</span></span><br><span class="line">    fmt.Println(<span class="string">"assign:"</span>, a)</span><br><span class="line"> </span><br><span class="line">    fmt.Println(<span class="string">"len:"</span>, <span class="built_in">len</span>(a))</span><br><span class="line"> </span><br><span class="line">    b := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">"init:"</span>, b)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> c [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">3</span>; j++ &#123;</span><br><span class="line">            c[i][j] = i + j</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"2d: "</span>, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">array a: [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">assign: [<span class="number">0</span> <span class="number">10</span> <span class="number">0</span> <span class="number">30</span> <span class="number">0</span>]</span><br><span class="line"><span class="built_in">len</span>: <span class="number">5</span></span><br><span class="line">init: [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"><span class="number">2</span>d:  [[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>] [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]]</span><br></pre></td></tr></table></figure>

<h4 id="数组的切片操作"><a href="#数组的切片操作" class="headerlink" title="数组的切片操作"></a>数组的切片操作</h4><p>这个就和python类似了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"> </span><br><span class="line">b := a[<span class="number">2</span>:<span class="number">4</span>] <span class="comment">// a[2] 和 a[3]，但不包括a[4]</span></span><br><span class="line">fmt.Println(b)</span><br><span class="line"> </span><br><span class="line">b = a[:<span class="number">4</span>] <span class="comment">// 从 a[0]到a[4]，但不包括a[4]</span></span><br><span class="line">fmt.Println(b)</span><br><span class="line"> </span><br><span class="line">b = a[<span class="number">2</span>:] <span class="comment">// 从 a[2]到a[4]，且包括a[2]</span></span><br><span class="line">fmt.Println(b)</span><br></pre></td></tr></table></figure>

<h4 id="分支循环语句"><a href="#分支循环语句" class="headerlink" title="分支循环语句"></a>分支循环语句</h4><p><strong>if语句</strong></p>
<p>注意：if 语句没有圆括号，而必需要有花括号</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//if 语句</span></span><br><span class="line"><span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//if - else</span></span><br><span class="line"><span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">//偶数...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//奇数...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//多分支</span></span><br><span class="line"><span class="keyword">if</span> num &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">//负数</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> num == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">//零</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//正数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>switch 语句</strong></p>
<p>注意：switch语句没有break，还可以使用逗号case多个值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        fmt.Println(<span class="string">"one"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        fmt.Println(<span class="string">"two"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        fmt.Println(<span class="string">"three"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>:</span><br><span class="line">        fmt.Println(<span class="string">"four, five, six"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">"invalid value!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>for 语句</strong></p>
<p>前面你已见过了，下面再来看看for的三种形式：（注意：Go语言中没有while）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//经典的for语句 init; condition; post</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i&lt;<span class="number">10</span>; i++&#123;</span><br><span class="line">     fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//精简的for语句 condition</span></span><br><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i&lt;<span class="number">10</span> &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//死循环的for语句 相当于for(;;)</span></span><br><span class="line">i :=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i&gt;<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关于分号"><a href="#关于分号" class="headerlink" title="关于分号"></a>关于分号</h4><p>从上面的代码我们可以看到代码里没有分号。其实，<strong>和C一样，Go的正式的语法使用分号来终止语句。和C不同的是，这些分号由词法分析器在扫描源代码过程中使用简单的规则自动插入分号，因此输入源代码多数时候就不需要分号了</strong>。</p>
<p>规则是这样的：如果在一个新行前方的最后一个标记是一个标识符（包括像<code>int</code>和<code>float64</code>这样的单词）、一个基本的如数值这样的文字、或以下标记中的一个时，会自动插入分号：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">break</span> <span class="keyword">continue</span> <span class="keyword">fallthrough</span> <span class="keyword">return</span> ++ -- ) &#125;</span><br></pre></td></tr></table></figure>

<p>通常Go程序仅在<code>for</code>循环语句中使用分号，以此来分开初始化器、条件和增量单元。如果你在一行中写多个语句，也需要用分号分开。</p>
<p><strong>注意</strong>：<strong>无论任何时候，你都不应该将一个控制结构（(if、for、switch或select）的左大括号放在下一行。如果这样做，将会在大括号的前方插入一个分号，这可能导致出现不想要的结果</strong>。</p>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>map在别的语言里可能叫哈希表或叫dict，下面是和map的相关操作的代码，代码很容易懂</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>) <span class="comment">//使用make创建一个空的map</span></span><br><span class="line"></span><br><span class="line">    m[<span class="string">"one"</span>] = <span class="number">1</span></span><br><span class="line">    m[<span class="string">"two"</span>] = <span class="number">2</span></span><br><span class="line">    m[<span class="string">"three"</span>] = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(m) <span class="comment">//输出 map[three:3 two:2 one:1] (顺序在运行时可能不一样)</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(m)) <span class="comment">//输出 3</span></span><br><span class="line"></span><br><span class="line">    v := m[<span class="string">"two"</span>] <span class="comment">//从map里取值</span></span><br><span class="line">    fmt.Println(v) <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">delete</span>(m, <span class="string">"two"</span>)</span><br><span class="line">    fmt.Println(m) <span class="comment">//输出 map[three:3 one:1]</span></span><br><span class="line"></span><br><span class="line">    m1 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"one"</span>: <span class="number">1</span>, <span class="string">"two"</span>: <span class="number">2</span>, <span class="string">"three"</span>: <span class="number">3</span>&#125;</span><br><span class="line">    fmt.Println(m1) <span class="comment">//输出 map[two:2 three:3 one:1] (顺序在运行时可能不一样)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> key, val := <span class="keyword">range</span> m1&#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%s =&gt; %d \n"</span>, key, val)</span><br><span class="line">        <span class="comment">/*输出：(顺序在运行时可能不一样)</span></span><br><span class="line"><span class="comment">            three =&gt; 3</span></span><br><span class="line"><span class="comment">            one =&gt; 1</span></span><br><span class="line"><span class="comment">            two =&gt; 2*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>Go语言一样有指针，看代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> pInt *<span class="keyword">int</span> = &amp;i</span><br><span class="line"><span class="comment">//输出：i=1     pInt=0xf8400371b0       *pInt=1</span></span><br><span class="line">fmt.Printf(<span class="string">"i=%d\tpInt=%p\t*pInt=%d\n"</span>, i, pInt, *pInt)</span><br><span class="line"> </span><br><span class="line">*pInt = <span class="number">2</span></span><br><span class="line"><span class="comment">//输出：i=2     pInt=0xf8400371b0       *pInt=2</span></span><br><span class="line">fmt.Printf(<span class="string">"i=%d\tpInt=%p\t*pInt=%d\n"</span>, i, pInt, *pInt)</span><br><span class="line"> </span><br><span class="line">i = <span class="number">3</span></span><br><span class="line"><span class="comment">//输出：i=3     pInt=0xf8400371b0       *pInt=3</span></span><br><span class="line">fmt.Printf(<span class="string">"i=%d\tpInt=%p\t*pInt=%d\n"</span>, i, pInt, *pInt)</span><br></pre></td></tr></table></figure>

<p>Go具有两个分配内存的机制，分别是内建的函数new和make。他们所做的事不同，所应用到的类型也不同，这可能引起混淆，但规则却很简单。</p>
<p>参考自:</p>
<p>GO 语言简介（上）— 语法</p>
<p><a href="https://coolshell.cn/articles/8460.html" target="_blank" rel="noopener">https://coolshell.cn/articles/8460.html</a></p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>CLI创建并使用KVM</title>
    <url>/CLI%E5%88%9B%E5%BB%BA%E5%B9%B6%E4%BD%BF%E7%94%A8KVM/</url>
    <content><![CDATA[<p>在虚拟机中搭建KVM实验环境并实现KVM虚拟机之间的网络通信及分布式网站架构.实验中直接使用命令行界面实现虚拟机中系统的安装和配置,免去了图形化界面操作的步骤.系统安装完成之后配置虚拟网卡,配置虚拟网段及实现远程连接,分布式网站中跳板机的设置及ip过滤,模拟了一个小型网站的架构后期可以使用docker来替代KVM以实现更好的实验效果.</p>
<p>整个实验从配置环境到安装虚拟机,配置软件环境,配置网络通信等方面实现了KVM虚拟机环境配置的需求.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.检测是否支持KVM</span><br><span class="line">KVM 是基于 x86 虚拟化扩展(Intel VT 或者 AMD-V) 技术的虚拟机软件，所以查看 CPU 是否支持 VT 技术，</span><br><span class="line">就可以判断是否支持KVM。有返回结果，如果结果中有vmx（Intel）或svm(AMD)字样，就说明CPU的支持的。切记</span><br><span class="line">在VMware CPU选项下点击CPU虚拟化</span><br><span class="line"><span class="meta">#</span><span class="bash"> cat /proc/cpuinfo | egrep <span class="string">'vmx|svm'</span></span></span><br><span class="line">关闭 Selinux 和 firewalld </span><br><span class="line"><span class="meta">#</span><span class="bash"> vi /etc/sysconfig/selinux</span></span><br><span class="line">selinux=disabled</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl stop firewalld</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl disabled firewalld</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> iptables -F</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> iptables -vnL</span></span><br><span class="line"></span><br><span class="line">2.安装KVM环境</span><br><span class="line">yum -y install qemu-kvm python-virtinst libvirt libvirt-python virt-manager libguestfs-tools bridge-utils virt-install kvm acpid</span><br><span class="line">装载 kvm 模块</span><br><span class="line"><span class="meta">#</span><span class="bash"> modprobe kvm</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> lsmod | grep kvm</span></span><br><span class="line">开启KVM服务,并设置开机自动启动</span><br><span class="line">systemctl start acpid.service</span><br><span class="line">systemctl enable acpid.service</span><br><span class="line">systemctl start libvirtd.service</span><br><span class="line">systemctl enable libvirtd.service</span><br><span class="line"></span><br><span class="line">3.安装虚拟机</span><br><span class="line">kvm创建虚拟机，特别注意.iso镜像文件一定放到/home 或者根目录重新创建目录，不然会因为权限报</span><br><span class="line">错，无法创建虚拟机。</span><br><span class="line">首先要创建一个虚拟网桥br0,无法创建的话就删除网卡原来的配置文件,然后重新生成(记得备份)</span><br><span class="line"><span class="meta">#</span><span class="bash"> virsh iface-bridge ens33 br0</span></span><br><span class="line">然后开始创建虚拟机</span><br><span class="line">创建虚拟机之前最好先把网桥设好并规划好网段,这样下次再创建虚拟机的时候可以直接连接到网桥上.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> virt-install \</span></span><br><span class="line">--name=centos7C1 \</span><br><span class="line">--vcpus=2 \</span><br><span class="line">--memory=4096 \</span><br><span class="line">--location=/tmp/CentOS-7-x86_64-Minimal-1511.iso \</span><br><span class="line">--disk path=/home/vms/c1/centosC1.qcow2,size=40,format=qcow2 \</span><br><span class="line">--network bridge=br0 \</span><br><span class="line">--graphics none \</span><br><span class="line">--extra-args='console=ttyS0' \</span><br><span class="line">--force</span><br><span class="line"></span><br><span class="line">选项参考:</span><br><span class="line">name: 虚拟机名</span><br><span class="line">vcpus: 虚拟cpu数量</span><br><span class="line">memory: 虚拟内存大小</span><br><span class="line">location: ios文件路径</span><br><span class="line">没有的话可以手动在 ftp 服务器上下载:</span><br><span class="line"><span class="meta">#</span><span class="bash"> wget ftp://172.20.0.1/pub/ISOs/CentOS/CentOS-7-x86_64-Minimal-1511.iso</span></span><br><span class="line">disk path: 虚拟机安装位置</span><br><span class="line">network bridge: 网桥名称</span><br><span class="line">graphics: 图形界面</span><br><span class="line"></span><br><span class="line">4.命令行配置系统:</span><br><span class="line">上面创建虚拟机命令最终需要你配置系统基础设置，带 [!] 基本都是要配置的，按照顺序往下配置，</span><br><span class="line">按对用的数字以此进行设置。</span><br><span class="line">Installation</span><br><span class="line"></span><br><span class="line"> 1) [x] Language settings                 2) [!] Timezone settings</span><br><span class="line">        (English (United States))                (Timezone is not set.)</span><br><span class="line"> 3) [!] Installation source               4) [!] Software selection</span><br><span class="line">        (Processing...)                          (Processing...)</span><br><span class="line"> 5) [!] Installation Destination          6) [x] Kdump</span><br><span class="line">        (No disks selected)                      (Kdump is enabled)</span><br><span class="line"> 7) [ ] Network configuration             8) [!] Root password</span><br><span class="line">        (Not connected)                          (Password is not set.)</span><br><span class="line"> 9) [!] User creation</span><br><span class="line">        (No user will be created)</span><br><span class="line">  Please make your choice from above ['q' to quit | 'b' to begin installation |</span><br><span class="line">  'r' to refresh]:</span><br><span class="line">  </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">2 Timezone settings 时区设置选择 5) Asia亚洲，再选择城市 62) Shanghai上海</span></span><br><span class="line"></span><br><span class="line">Available regions</span><br><span class="line"> 1)  Africa                 6)  Atlantic              10)  Pacific</span><br><span class="line"> 2)  America                7)  Australia             11)  US</span><br><span class="line"> 3)  Antarctica             8)  Europe                12)  Etc</span><br><span class="line"> 4)  Arctic                 9)  Indian</span><br><span class="line"> 5)  Asia</span><br><span class="line">Please select the timezone.</span><br><span class="line">Use numbers or type names directly [b to region list, q to quit]: 5</span><br><span class="line">--------------------</span><br><span class="line"></span><br><span class="line"> 8)  Baghdad               35)  Kathmandu             61)  Seoul</span><br><span class="line"> 9)  Bahrain               36)  Khandyga              62)  Shanghai</span><br><span class="line">10)  Baku                  37)  Kolkata               63)  Singapore</span><br><span class="line">26)  Hong_Kong             53)  Pontianak</span><br><span class="line">27)  Hovd</span><br><span class="line">Please select the timezone.</span><br><span class="line">Use numbers or type names directly [b to region list, q to quit]: 62</span><br><span class="line"></span><br><span class="line">Installation source 安装源输入数字2</span><br><span class="line">Choose an installation source type.</span><br><span class="line"> 1)  CD/DVD</span><br><span class="line"> 2)  local ISO file</span><br><span class="line"> 3)  Network</span><br><span class="line">  Please make your choice from above ['q' to quit | 'c' to continue |</span><br><span class="line">  'r' to refresh]: 2</span><br><span class="line">  </span><br><span class="line">Software selection 软件选择:</span><br><span class="line">Base environment</span><br><span class="line">Software selection</span><br><span class="line"></span><br><span class="line">Base environment</span><br><span class="line"></span><br><span class="line"> 1)  [x] Minimal Install</span><br><span class="line">  Please make your choice from above ['q' to quit | 'c' to continue |</span><br><span class="line">  'r' to refresh]:</span><br><span class="line">  </span><br><span class="line">Installation Destination 安装目的地</span><br><span class="line">Installation Destination</span><br><span class="line"></span><br><span class="line">[x] 1) : 40 GiB (vda)</span><br><span class="line"></span><br><span class="line">1 disk selected; 40 GiB capacity; 40 GiB free ...</span><br><span class="line"></span><br><span class="line">  Please make your choice from above ['q' to quit | 'c' to continue |</span><br><span class="line">  'r' to refresh]: c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Autopartitioning Options 自动分区选项</span><br><span class="line"></span><br><span class="line">[ ] 1) Replace Existing Linux system(s) 替换现有的Linux系统</span><br><span class="line"></span><br><span class="line">[x] 2) Use All Space 使用所有空间</span><br><span class="line"></span><br><span class="line">[ ] 3) Use Free Space 使用可用空间</span><br><span class="line"></span><br><span class="line">================================================================================</span><br><span class="line">Partition Scheme Options 分区方案选项</span><br><span class="line"></span><br><span class="line">[ ] 1) Standard Partition 标准分区</span><br><span class="line"></span><br><span class="line">[ ] 2) Btrfs Btrfs</span><br><span class="line"></span><br><span class="line">[x] 3) LVM LVM(逻辑卷管理)</span><br><span class="line"></span><br><span class="line">[ ] 4) LVM Thin Provisioning 精简配置</span><br><span class="line"></span><br><span class="line">Select a partition scheme configuration.</span><br><span class="line"></span><br><span class="line">  Please make your choice from above ['q' to quit | 'c' to continue |</span><br><span class="line">  'r' to refresh]: c</span><br><span class="line"></span><br><span class="line">然后输入8录入root账户的密码</span><br><span class="line">  </span><br><span class="line">此处也可以只设置 Root 密码和Installation Destination 安装目的地其它进入系统设置比如时区设置如下：</span><br><span class="line">echo "TZ='Asia/Shanghai'; export TZ" &gt;&gt; /etc/profile  </span><br><span class="line"></span><br><span class="line">选择完成后输入 b 就可以开始安装系统了.</span><br><span class="line">安装完成之后默认是在桌面环境的.直接登录并操作即可.</span><br><span class="line"></span><br><span class="line">安装完成之后第一次启动网卡eth0是获取不到ip地址的,所以需要手动启动</span><br><span class="line"><span class="meta">#</span><span class="bash"> vi /etc/sysconfig/network-scripts/ifcfg-eth0 </span></span><br><span class="line">ONBOOT=yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl restart network</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ip a</span></span><br><span class="line">查看到ip地址之后最好将ip地址固定下来,方便以后使用</span><br><span class="line"><span class="meta">#</span><span class="bash"> vi /etc/sysconfig/network-scripts/ifcfg-eth0 </span></span><br><span class="line">BOOTPROTO=static</span><br><span class="line">IPADDR=172.20.124.138</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5.添加第一个网桥之后还需要对网桥进行控制划分其他的网段</span><br><span class="line"><span class="meta">#</span><span class="bash"> brctl show</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> /etc/libvirt/qemu/networks</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cp default.xml mynet1.xml </span></span><br><span class="line"></span><br><span class="line">拷贝完成之后需要对配置文件进行修改如修改网桥名称,划分子网范围</span><br><span class="line"><span class="meta">#</span><span class="bash"> vi mynet1.xml </span></span><br><span class="line">&lt;network&gt;</span><br><span class="line">  &lt;name&gt;mynet1&lt;/name&gt;</span><br><span class="line">  &lt;bridge name='mybr1' stp='on' delay='0'/&gt;</span><br><span class="line">  &lt;ip address='12.20.20.40' netmask='255.255.255.0'&gt;</span><br><span class="line">    &lt;dhcp&gt;</span><br><span class="line">      &lt;range start='12.20.20.12' end='12.20.20.100'/&gt;</span><br><span class="line">    &lt;/dhcp&gt;</span><br><span class="line">  &lt;/ip&gt;</span><br><span class="line">&lt;/network&gt;</span><br><span class="line"></span><br><span class="line">配置文件修改完成之后即可创建网桥</span><br><span class="line"><span class="meta">#</span><span class="bash"> virsh net-create mynet1.xml</span></span><br><span class="line">查看虚拟网桥信息</span><br><span class="line"><span class="meta">#</span><span class="bash"> virsh net-list</span></span><br><span class="line"></span><br><span class="line">6.VM虚拟机添加网卡并配置网络</span><br><span class="line"><span class="meta">1&gt;</span><span class="bash">手动添加网桥并插入虚拟机</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> virsh domiflist centos7C1</span></span><br><span class="line">Interface  Type       Source     Model       MAC</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">vnet0      bridge     br0        virtio      52:54:00:8c:b8:60</span><br><span class="line"></span><br><span class="line"><span class="meta">2&gt;</span><span class="bash">成功附加接口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> virsh attach-interface centos7C1 --<span class="built_in">type</span> bridge --<span class="built_in">source</span> br0 </span></span><br><span class="line"></span><br><span class="line">永久添加网卡命令</span><br><span class="line"><span class="meta">#</span><span class="bash"> virsh attach-interface centos7C1 --<span class="built_in">type</span> bridge --<span class="built_in">source</span> br0  --config</span></span><br><span class="line"></span><br><span class="line"><span class="meta">3&gt;</span><span class="bash">查看添加网卡的信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> virsh domiflist centos7C1</span></span><br><span class="line">Interface  Type       Source     Model       MAC</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">vnet0      bridge     br0        virtio      52:54:00:8c:b8:60</span><br><span class="line">vnet1      bridge     br0        -           52:54:00:14:86:cf</span><br><span class="line">在KVM中查看添加的信息:</span><br><span class="line">ip a</span><br><span class="line"></span><br><span class="line"><span class="meta">4&gt;</span><span class="bash">命令行增加的网卡只保存在内存中，重启就失效，所以需要保存到配置文件中</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> virsh dumpxml centos7C1 &gt;/etc/libvirt/qemu/centos7C1.xml </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> virsh define /etc/libvirt/qemu/centos7C1.xml </span></span><br><span class="line"></span><br><span class="line">删除网卡命令</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> virsh detach-interface centos7C1  --<span class="built_in">type</span> bridge --mac  52:54:00:14:86:cf</span></span><br><span class="line">成功分离接口</span><br><span class="line"></span><br><span class="line">7.克隆KVM虚拟机,创建虚拟机镜像.</span><br><span class="line">暂停原始虚拟机</span><br><span class="line"><span class="meta">#</span><span class="bash"> virsh shutdown centos72</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> virt-clone -o centos72 -n centos.112 -f /home/vms/centos.112.qcow2 -m 00:00:00:00:00:01</span></span><br><span class="line"></span><br><span class="line">复制第一次安装的干净系统镜像，作为基础镜像文件，</span><br><span class="line">后面创建虚拟机使用这个基础镜像</span><br><span class="line">cp /home/vms/centos.88.qcow2 /home/vms/centos7.base.qcow2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用基础镜像文件，创建新的虚拟机镜像</span></span><br><span class="line">cp /home/vms/centos7.base.qcow2 /home/vms/centos7.113.qcow2</span><br><span class="line"></span><br><span class="line">8.热插拔网卡实现切换网桥</span><br><span class="line">查看当前宿主机网卡的状态</span><br><span class="line"><span class="meta">#</span><span class="bash"> brctl show</span></span><br><span class="line">查看KVM虚拟机的运行状态</span><br><span class="line"><span class="meta">#</span><span class="bash"> virsh list</span></span><br><span class="line">查看KVM虚拟机网卡列表</span><br><span class="line"><span class="meta">#</span><span class="bash"> virsh domiflist centos7C1</span></span><br><span class="line"></span><br><span class="line">添加一个网卡到物理桥myBr1上</span><br><span class="line"><span class="meta">#</span><span class="bash"> virsh attach-interface centos7C1 bridge myBr1</span></span><br><span class="line">撤销网卡，撤销网卡前先关闭网卡</span><br><span class="line"><span class="meta">#</span><span class="bash"> ip link <span class="built_in">set</span> dev ens10 down</span></span><br><span class="line">注意：撤销某一块网卡要指定该网卡的MAC，要不会撤销该网卡所在网桥上所有的网卡</span><br><span class="line"><span class="meta">#</span><span class="bash"> virsh detach-interface centos7C1 bridge --mac 52:54:00:f1:22:5b</span></span><br><span class="line"></span><br><span class="line">9.分布式部署LAMP</span><br><span class="line">9.1 HTTPD的实现</span><br><span class="line"><span class="meta">#</span><span class="bash"> yum -y install httpd</span></span><br><span class="line">修改主配置文件，把php的首页加上</span><br><span class="line"><span class="meta">#</span><span class="bash"> vi httpd.conf </span></span><br><span class="line">&lt;IfModule dir_module&gt;</span><br><span class="line">    DirectoryIndex index.php index.html</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line"></span><br><span class="line">新建虚拟主机文件,对php文件做解析的服务器的地址可以暂时不写.等软件部署成功之后再补上.</span><br><span class="line">[root@web-server conf.d]# vi www.conf</span><br><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">        ServerName  www.dklwj.com</span><br><span class="line">        DocumentRoot "/vhosts/www/htdocs"</span><br><span class="line">        &lt;Directory "/vhosts/www/htdocs"&gt;</span><br><span class="line">                Options FollowSymLinks</span><br><span class="line">                AllowOverride None</span><br><span class="line">                Require all granted</span><br><span class="line">        &lt;/directory&gt;</span><br><span class="line">    ProxyRequests Off</span><br><span class="line">    ProxyPassMatch ^/(.*\.php)$ fcgi://192.168.137.147:9000/vhosts/www/htdocs/$1</span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line"></span><br><span class="line">创建虚拟主机的目录</span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdir /vhosts/www/htdocs -p</span></span><br><span class="line">修改目录的所属组的权限为apache</span><br><span class="line"><span class="meta">#</span><span class="bash"> chown -R apache.apache /vhosts/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> /vhosts/www/htdocs</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"&lt;h1&gt;It works!!&lt;/h1&gt;"</span> &gt; ./index.html</span></span><br><span class="line"></span><br><span class="line">启动http服务,查看80端口有没有被监听.</span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl start httpd            </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ss -tnl </span></span><br><span class="line">State      Recv-Q Send-Q  Local Address:Port                 Peer Address:Port              </span><br><span class="line">LISTEN     0      128                 *:22                              *:*                  </span><br><span class="line">LISTEN     0      100         127.0.0.1:25                              *:*                  </span><br><span class="line">LISTEN     0      128                :::80                             :::*                  </span><br><span class="line">LISTEN     0      128                :::22                             :::*                  </span><br><span class="line">LISTEN     0      100               ::1:25                             :::*  </span><br><span class="line"></span><br><span class="line">服务启动之后可以在本机上查看访问html网页的效果,这里就不修改 hosts 文件来实现域名的跳转了</span><br><span class="line"><span class="meta">#</span><span class="bash"> curl 192.168.100.233/index.html</span></span><br><span class="line"></span><br><span class="line">9.2 php-fpm的实现</span><br><span class="line">安装php-fpm 和php-mysql模块</span><br><span class="line"><span class="meta">#</span><span class="bash"> yum -y install php-fpm php-mysql</span></span><br><span class="line"></span><br><span class="line">修改配置文件</span><br><span class="line"><span class="meta">#</span><span class="bash"> vim /etc/php-fpm.d/www.conf </span></span><br><span class="line"><span class="meta">#</span><span class="bash">作为单独服务运行需要把监听端口改成所有接口，http后续会使用反代</span></span><br><span class="line">listen = 0.0.0.0:9000  </span><br><span class="line"><span class="meta">#</span><span class="bash">只允许192.168.137.144这台服务器也就是http服务器</span></span><br><span class="line">listen.allowed_clients = 192.168.100.233</span><br><span class="line"> </span><br><span class="line">创建php程序存放路径</span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdir /vhosts/www/htdocs -p</span></span><br><span class="line"></span><br><span class="line">进入目录然后创建一个php测试页面</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> /vhosts/www/htdocs/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> vim info.php</span></span><br><span class="line">&lt;?php</span><br><span class="line">        phpinfo();</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">启动PHP服务</span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl start php-fpm</span></span><br><span class="line"></span><br><span class="line">测试对php网页的反向代理是否可以实现</span><br><span class="line"><span class="meta">#</span><span class="bash"> curl 192.168.100.233/info.php</span></span><br><span class="line"></span><br><span class="line">9.3 MariaDB的实现</span><br><span class="line"><span class="meta">#</span><span class="bash"> yum -y install mariadb-server</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">配置mariadb禁止解析反向IP地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> vi /etc/my.cnf</span></span><br><span class="line">[mysqld]</span><br><span class="line">skip_name_resolve=on</span><br><span class="line"></span><br><span class="line">修改mysql的root密码然后删除匿名用户</span><br><span class="line">[root@mysql-server ~]# mysql</span><br><span class="line">Welcome to the MariaDB monitor.  Commands end with ; or \g.</span><br><span class="line">Your MariaDB connection id is 2</span><br><span class="line">Server version: 5.5.56-MariaDB MariaDB Server</span><br><span class="line">Copyright (c) 2000, 2017, Oracle, MariaDB Corporation Ab and others.</span><br><span class="line">Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.</span><br><span class="line">MariaDB [(none)]&gt; use mysql</span><br><span class="line">Reading table information for completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line">Database changed</span><br><span class="line">MariaDB [mysql]&gt; update user set password=password('123456') where user='root';</span><br><span class="line">Query OK, 4 rows affected (0.00 sec)</span><br><span class="line">Rows matched: 4  Changed: 4  Warnings: 0</span><br><span class="line">MariaDB [mysql]&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">MariaDB [mysql]&gt; drop user ''@'localhost';</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">MariaDB [mysql]&gt; drop user ''@'mysql-server';</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">MariaDB [mysql]&gt; select user,host,password from user;</span><br><span class="line">+------+--------------+-------------------------------------------+</span><br><span class="line">| user | host         | password                                  |</span><br><span class="line">+------+--------------+-------------------------------------------+</span><br><span class="line">| root | localhost    | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 |</span><br><span class="line">| root | mysql-server | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 |</span><br><span class="line">| root | 127.0.0.1    | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 |</span><br><span class="line">| root | ::1          | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 |</span><br><span class="line">+------+--------------+-------------------------------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">在php服务器上创一个测试一个连接数据库的页面</span><br><span class="line">[root@php-server /vhosts/www/htdocs]#vim mysql.php</span><br><span class="line">&lt;?php</span><br><span class="line"><span class="meta">$</span><span class="bash">link=mysql_connect(<span class="string">"192.168.137.148"</span>,<span class="string">"root"</span>,<span class="string">"123456"</span>);  </span></span><br><span class="line">if(!$link) echo "FAILD,Error!";</span><br><span class="line">else echo "OK.......!";</span><br><span class="line"></span><br><span class="line">测试对php访问数据库模块是否可以正常工作</span><br><span class="line"><span class="meta">#</span><span class="bash"> curl 192.168.100.233/mysql.php</span></span><br><span class="line"></span><br><span class="line">9.4部署WordPress软件</span><br><span class="line"></span><br><span class="line">在php服务器上下载WordPress包，这里需要强调一下，目录需要添加写权限要不然回出现文件无法写入的情况.</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> /vhosts/www/</span></span><br><span class="line">wordpress文件自行在官网下载</span><br><span class="line"><span class="meta">#</span><span class="bash"> tar xf wordpress-4.9.4-zh_CN.tar.gz</span></span><br><span class="line">删除原有存放网页的 htdoc 文件夹并将其以软连接形式呈现</span><br><span class="line"><span class="meta">#</span><span class="bash"> rm -rf htdocs/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ln -sv wordpress htdocs</span></span><br><span class="line"></span><br><span class="line">在把软件包复制一份到http上去里面静态资源需要由HTTP来处理所以两台服务器得各放一份</span><br><span class="line"><span class="meta">#</span><span class="bash"> scp -r wordpress root@192.168.137.144:/vhosts/www/</span></span><br><span class="line"></span><br><span class="line">在数据库服务器上创建所需要的库和帐号</span><br><span class="line">MariaDB [(none)]&gt; create database blog;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">MariaDB [(none)]&gt; grant all on blog.* to 'wpuser'@'%' identified by 'wppass';</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">MariaDB [(none)]&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">在HTTP服务器上配置</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> /vhosts/www</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls</span></span><br><span class="line">htdocs  index.html  wordpress</span><br><span class="line"><span class="meta">#</span><span class="bash"> rm -rf htdocs/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ln -s wordpress/ htdocs</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ll </span></span><br><span class="line">lrwxrwxrwx. 1 root   root     10 Oct 29 21:51 htdocs -&gt; wordpress/</span><br><span class="line">drwxr-xr-x. 5 root   root   4096 Oct 29 21:50 wordpress</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> ..</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> chown -R apache.apache www/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ll </span></span><br><span class="line">lrwxrwxrwx. 1 apache apache   10 Oct 29 21:51 htdocs -&gt; wordpress/</span><br><span class="line">drwxr-xr-x. 5 apache apache 4096 Oct 29 21:50 wordpress</span><br><span class="line"></span><br><span class="line">部署完成之后即可在浏览器上访问然后配置wordpress了,配置步骤不明白的可自行google,注意在php服务器上添加</span><br><span class="line">/vhosts/www/wordpress/wp-config.php 这个文件,这是wordpress的配置文件.</span><br><span class="line"></span><br><span class="line">10.隐藏真实主机网络访问控制</span><br><span class="line">现在我们一共有4台KVM虚拟机,DB服务器和php服务器不能暴露在外网环境中而实现操控和访问的httpd服务器和跳板</span><br><span class="line">机反而要对外实现通信,因此需要对网络进行设置</span><br><span class="line">10.1 网桥的准备工作</span><br><span class="line">之前已经设置好了可以访问外网桥街的br0,接下需要新建两个内网通信的网桥</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> /etc/libvirt/qemu/networks/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> brctl show</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cp default.xml mynet1.xml</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> vi mynet1.xml</span></span><br><span class="line">&lt;network&gt;</span><br><span class="line">  &lt;name&gt;mynet1&lt;/name&gt;</span><br><span class="line">  &lt;bridge name='mybr1' stp='on' delay='0'/&gt;</span><br><span class="line">  &lt;ip address='10.10.10.1' netmask='255.255.255.0'&gt;</span><br><span class="line">    &lt;dhcp&gt;</span><br><span class="line">      &lt;range start='10.10.10.10' end='10.10.10.100'/&gt;</span><br><span class="line">    &lt;/dhcp&gt;</span><br><span class="line">  &lt;/ip&gt;</span><br><span class="line">&lt;/network&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> virsh net-create mynet1.xml </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cp mynet1.xml mynet2.xml </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> vi mynet2.xml </span></span><br><span class="line"></span><br><span class="line">&lt;network&gt;</span><br><span class="line">  &lt;name&gt;mynet2&lt;/name&gt;</span><br><span class="line">  &lt;bridge name='mybr2' stp='on' delay='0'/&gt;</span><br><span class="line">  &lt;ip address='20.20.20.1' netmask='255.255.255.0'&gt;</span><br><span class="line">    &lt;dhcp&gt;</span><br><span class="line">      &lt;range start='20.20.20.20' end='20.20.20.100'/&gt;</span><br><span class="line">    &lt;/dhcp&gt;</span><br><span class="line">  &lt;/ip&gt;</span><br><span class="line">&lt;/network&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> virsh net-create mynet2.xml </span></span><br><span class="line">10.2为虚拟机配置网桥</span><br><span class="line">主要是对网卡的插拔操作,上文中有提到如何热插拔网卡实现切换网桥</span><br><span class="line"><span class="meta">#</span><span class="bash"> virsh attach-interface centos7C1 --<span class="built_in">type</span> bridge --<span class="built_in">source</span> mybr1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> virsh attach-interface centos7C2 --<span class="built_in">type</span> bridge --<span class="built_in">source</span> mybr2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> virsh detach-interface centos7C2 --<span class="built_in">type</span> bridge --mac 52:54:00:9c:0f:b4</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> virsh attach-interface centos7C3 --<span class="built_in">type</span> bridge --<span class="built_in">source</span> mybr2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> virsh detach-interface centos7C3 --<span class="built_in">type</span> bridge --mac 52:54:00:16:a8:a6</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> virsh attach-interface centos7C4 --<span class="built_in">type</span> bridge --<span class="built_in">source</span> mybr2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> virsh attach-interface centos7C4 --<span class="built_in">type</span> bridge --<span class="built_in">source</span> mybr1</span></span><br><span class="line"></span><br><span class="line">网桥插拔完成之后对虚拟机的网络接入情况进行查看:</span><br><span class="line">[root@localhost vms]# virsh domiflist centos7C1</span><br><span class="line">Interface  Type       Source     Model       MAC</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">vnet0      bridge     br0        virtio      52:54:00:13:29:30</span><br><span class="line">vnet5      bridge     mybr1      rtl8139     52:54:00:a9:b8:6c</span><br><span class="line"></span><br><span class="line">[root@localhost vms]# virsh domiflist centos7C2</span><br><span class="line">Interface  Type       Source     Model       MAC</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">vnet1      bridge     mybr1      virtio      52:54:00:f6:c9:d0</span><br><span class="line">vnet6      bridge     mybr2      rtl8139     52:54:00:87:f1:0d</span><br><span class="line"></span><br><span class="line">[root@localhost vms]# virsh domiflist centos7C3</span><br><span class="line">Interface  Type       Source     Model       MAC</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">vnet2      bridge     mybr2      rtl8139     52:54:00:1e:ab:d6</span><br><span class="line"></span><br><span class="line">[root@localhost vms]# virsh domiflist centos7C4</span><br><span class="line">Interface  Type       Source     Model       MAC</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">vnet4      bridge     br0        virtio      52:54:00:6f:fa:c7</span><br><span class="line">vnet3      bridge     mybr2      rtl8139     52:54:00:78:ea:44</span><br><span class="line">vnet7      bridge     mybr1      rtl8139     52:54:00:c4:61:9b </span><br><span class="line"></span><br><span class="line">查看网桥及网卡的连接情况:</span><br><span class="line"><span class="meta">#</span><span class="bash"> brctl show</span></span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">br0             8000.000c29120c94       yes             ens33</span><br><span class="line">                                                        vnet0</span><br><span class="line">                                                        vnet4</span><br><span class="line">mybr1           8000.525400c30ff7       yes             mybr1-nic</span><br><span class="line">                                                        vnet1</span><br><span class="line">                                                        vnet5</span><br><span class="line">                                                        vnet7</span><br><span class="line">mybr2           8000.525400dc598f       yes             mybr2-nic</span><br><span class="line">                                                        vnet2</span><br><span class="line">                                                        vnet3</span><br><span class="line">                                                        vnet6</span><br><span class="line">virbr0          8000.525400a975d4       yes             virbr0-nic</span><br><span class="line"> </span><br><span class="line">然后按照下面定义的网络地址来配置虚拟机的网络,网卡名有改变,但是不影响操作.</span><br><span class="line">Mysql(C3)</span><br><span class="line">ens8:20.20.20.35</span><br><span class="line">FPM(C2)</span><br><span class="line">ens9:20.20.20.63</span><br><span class="line">eth0:10.10.10.12</span><br><span class="line">HTTPD(C1)</span><br><span class="line">eth8:10.10.10.95</span><br><span class="line">eth1:172.20.124.138</span><br><span class="line">JUMPS(C4):16.40.40.80</span><br><span class="line">ens9:10.10.10.73 e78fde6e-933c-4ee4-851b-4b4a5fe7e744</span><br><span class="line">ens8:20.20.20.87 8bad1d1e-2247-4c54-a4e0-60094beddcdd</span><br><span class="line">eth0:172.20.124.151</span><br><span class="line">网桥设置:</span><br><span class="line">mybr1(host only):</span><br><span class="line">ip:10.10.10.1/24</span><br><span class="line">dhcp range:10.10.10.10 10.10.10.100</span><br><span class="line">mybr2(host only):</span><br><span class="line">ip:20.20.20.1/24</span><br><span class="line">dhcp range:20.20.20.20 20.20.20.100</span><br><span class="line">br0(nat):</span><br><span class="line">ip:192.168.122.1/24</span><br><span class="line">dhcp range: 192.168.122.2 192.168.122.254</span><br><span class="line">这样设置的话不同的主机就存在与不同的网域中,外界就没法直接访问敏感服务器咯.</span><br><span class="line"></span><br><span class="line">跳板机的网络设置</span><br><span class="line"></span><br><span class="line">mysql iptables rule</span><br><span class="line">	允许跳板机的ssh</span><br><span class="line">      iptables -A INPUT -d 10.10.20.20 -s 10.10.20.100 -p tcp --dport 22 -j ACCEPT</span><br><span class="line">      iptables -A OUTPUT -s 10.10.20.20 -d 10.10.20.100 -p tcp --sport 22 -j ACCEPT</span><br><span class="line">    拒绝所有连接</span><br><span class="line">     iptables -A INPUT -j DROP</span><br><span class="line">     iptables -A OUTPUT -j DROP</span><br><span class="line">    允许php的IP连接数据库</span><br><span class="line">     iptables -I INPUT -d 10.10.20.20 -s 10.10.20.30 -p tcp --dport 3306 -j ACCEPT </span><br><span class="line">     iptables -I OUTPUT -s 10.10.20.20 -d 10.10.20.30 -p tcp --sport 3306 -j ACCEPT    	</span><br><span class="line"></span><br><span class="line">PHP iptables rule</span><br><span class="line">   允许跳板机的ssh</span><br><span class="line">     iptables -A INPUT -d 172.30.20.30 -s 172.30.20.100 -p tcp --dport 22 -j ACCEPT</span><br><span class="line">     iptables -A OUTPUT -s 172.30.20.30 -d 172.30.20.100 -p tcp --sport 22 -j ACCEPT</span><br><span class="line"></span><br><span class="line">    拒绝所有连接</span><br><span class="line">     iptables -A INPUT -j ACCEPT</span><br><span class="line">     iptables -A OUTPUT -j ACCEPT</span><br><span class="line"></span><br><span class="line">    允许httpd的反代端口9000通过</span><br><span class="line"><span class="meta">	#</span><span class="bash"> iptables -I INPUT -d 172.30.20.30 -s 172.30.20.152 -p tcp --dport 9000 -j ACCEPT</span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> iptables -I OUTPUT -s 172.30.20.30 -d 172.30.20.152 -p tcp --sport 9000 -j ACCEPT </span></span><br><span class="line">      </span><br><span class="line"><span class="meta">	#</span><span class="bash"> iptables -I OUTPUT -d 10.10.20.20 -s 10.10.20.30 -p tcp --dport 3306 -j ACCEPT</span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> iptables -I INPUT -d 10.10.20.30 -s 10.10.20.20 -p tcp --sport 3306 -j ACCEPT</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HTTPD iptables rule</span><br><span class="line"> 允许跳板机的ssh</span><br><span class="line">    # iptables -A INPUT -d 172.30.20.152 -s 172.30.20.100 -p tcp --dport 22 -j ACCEPT</span><br><span class="line">    #iptables -A OUTPUT -s 172.30.20.152 -d 172.30.20.100 -p tcp --sport 22 -j ACCEPT</span><br><span class="line"> 拒绝所有连接</span><br><span class="line">    # iptables -A INPUT -j DROP</span><br><span class="line">    # iptables -A OUTPUT -j DROP</span><br><span class="line"> 允许客户端通过外网接口访问80和443接口</span><br><span class="line"> 	进口配置</span><br><span class="line">    # iptables -I INPUT -d 192.168.137.152 -i eth0 -p tcp -m multiport --dports 80,443 -j ACCEPT</span><br><span class="line">   出口设置</span><br><span class="line">    # iptables -I OUTPUT -s 192.168.137.152 -o eth0 -p tcp -m multiport --sports 80,443 -j ACCEPT</span><br><span class="line"></span><br><span class="line">   允许http能连接到后端的PHP服务器的9000端口</span><br><span class="line">    # iptables -I OUTPUT -d 172.30.20.30 -s 172.30.20.152 -p tcp --dport 9000 -j ACCEPT</span><br><span class="line">    # iptables -I INPUT -d 172.30.20.152 -s 172.30.20.30 -p tcp --sport 9000 -j ACCEPT</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">补充:</span><br><span class="line">使用dhcp分配网络地址之后没有相应的网络配置文件</span><br><span class="line">解决方案:</span><br><span class="line">1.使用nmcli con show命令，查看网卡的UUID信息，记下UUID值</span><br><span class="line"><span class="meta">#</span><span class="bash"> nmcli con show</span></span><br><span class="line">2.使用ip addr命令查看网卡信息，记下ens37网卡的MAC地址</span><br><span class="line">3.将 /etc/sysconfig/network-scripts/目录中ifcfg-ens33文件复制一份，并命名为 ifcfg-ens37，</span><br><span class="line">重新修改配置文件，注意修改必要的硬件信息</span><br><span class="line">4.最后重启网络即可</span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl restart network</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Shell 脚本编程进阶(四)</title>
    <url>/Linux-Shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6-%E5%9B%9B/</url>
    <content><![CDATA[<h3 id="高级变量用法-有类型变量"><a href="#高级变量用法-有类型变量" class="headerlink" title="高级变量用法-有类型变量"></a>高级变量用法-有类型变量</h3><p>Shell变量一般是无类型的,但是bash Shell提供了declare和typeset两个命令用于指定变量的类型,两个命令是等价的<br>declare [选项] 变量名<br>​    -r 声明或显示只读变量<br>​    -i 将变量定义为整型数<br>​    -a 将变量定义为数组<br>​    -A 将变量定义为关联数组<br>​    -f 显示已定义的所有函数名及其内容<br>​    -F 仅显示已定义的所有函数名<br>​    -x 声明或显示环境变量和函数<br>​    -l 声明变量为小写字母 declare –l var=UPPER<br>​    -u 声明变量为大写字母 declare –u var=lower</p>
<h3 id="eval命令"><a href="#eval命令" class="headerlink" title="eval命令"></a>eval命令</h3><p>eval命令将会首先扫描命令行进行所有的置换,然后再执行该命令.该命令适用于那些一次扫描无法实现其功能的变量.该命令对变量进行两次扫描<br> 示例:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@server ~]# CMD=whoami</span><br><span class="line">[root@server ~]# echo $CMD</span><br><span class="line">whoami</span><br><span class="line">[root@server ~]# eval $CMD</span><br><span class="line">root</span><br><span class="line">[root@server ~]# n=10</span><br><span class="line">[root@server ~]# echo &#123;0..$n&#125;</span><br><span class="line">&#123;0..10&#125;</span><br><span class="line">[root@server ~]# eval echo &#123;0..$n&#125;</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 10</span><br></pre></td></tr></table></figure>



<h3 id="间接变量引用"><a href="#间接变量引用" class="headerlink" title="间接变量引用"></a>间接变量引用</h3><p>如果第一个变量的值是第二个变量的名字,从第一个变量引用第二个变量的值就称为间接变量引用<br>variable1的值是variable2,而variable2又是变量名,variable2的值为value,间接变量引用是指通过variable1获得变量值value的行为<br>​    variable1=variable2<br>​    variable2=value</p>
<p>bash Shell提供了两种格式实现间接变量引用<br>​    eval tempvar=$$variable1<br>​    tempvar=${!variable1}<br>示例:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@server ~]# N=NAME</span><br><span class="line">[root@server ~]# NAME=mark</span><br><span class="line">[root@server ~]# N1=$&#123;!N&#125;</span><br><span class="line">[root@server ~]# echo $N1</span><br><span class="line">mark</span><br><span class="line">[root@server ~]# eval N2=$$N</span><br><span class="line">[root@server ~]# echo $N2</span><br><span class="line">mark</span><br></pre></td></tr></table></figure>



<h3 id="创建临时文件"><a href="#创建临时文件" class="headerlink" title="创建临时文件"></a>创建临时文件</h3><p>mktemp命令:创建并显示临时文件,可避免冲突<br>mktemp [OPTION]… [TEMPLATE]<br>​    TEMPLATE: filenameXXX<br>​        X至少要出现三个<br>OPTION:<br>​    -d: 创建临时目录<br>​    -p DIR或–tmpdir=DIR:指明临时文件所存放目录位置<br>示例:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mktemp /tmp/testXXX</span><br><span class="line"></span><br><span class="line">tmpdir=`mktemp –d /tmp/testdirXXX`</span><br><span class="line"></span><br><span class="line">mktemp --tmpdir=/testdir testXXXXXX</span><br></pre></td></tr></table></figure>

<h3 id="安装复制文件"><a href="#安装复制文件" class="headerlink" title="安装复制文件"></a>安装复制文件</h3><p>install命令:<br>​    install [OPTION]… [-T] SOURCE DEST 单文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">install [OPTION]... SOURCE... DIRECTORY</span><br><span class="line"></span><br><span class="line">install [OPTION]... -t DIRECTORY SOURCE...</span><br><span class="line"></span><br><span class="line">install [OPTION]... -d DIRECTORY...创建空目录</span><br></pre></td></tr></table></figure>

<p>选项:<br>​    -m MODE,默认755</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-o OWNER</span><br><span class="line"></span><br><span class="line">-g GROUP</span><br></pre></td></tr></table></figure>

<p>示例:<br>​    install -m 700 -o mark -g admins srcfile desfile</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">install –m 770 –d &#x2F;testdir&#x2F;installdir</span><br></pre></td></tr></table></figure>



<h3 id="expect介绍"><a href="#expect介绍" class="headerlink" title="expect介绍"></a>expect介绍</h3><p>expect 是由Don Libes基于Tcl（ Tool Command Language ）语言开发的,主要应用于自动化交互式操作的场景,借助Expect处理交互的命令,可以将交互过程如:ssh登录,ftp登录等写在一个脚本上,使之自动化完成.尤其适用于需要对多台服务器执行相同操作的环境中,可以大大提高系统管理人员的工作效率</p>
<h4 id="expect命令"><a href="#expect命令" class="headerlink" title="expect命令"></a>expect命令</h4><p>expect 语法:<br>expect [选项][ -c cmds ] [ [ -[f|b] ] cmdfile ][ args ]<br>选项<br>​    -c:从命令行执行expect脚本,默认expect是交互地执行的<br>​    示例:expect -c ‘expect “\n” {send “pressed enter\n”}<br>​    -d:可以输出输出调试信息<br>​    示例:expect -d ssh.exp<br>expect中相关命令<br>​    spawn:启动新的进程<br>​    send:用于向进程发送字符串<br>​    expect:从进程接收字符串<br>​    interact:允许用户交互<br>​    exp_continue 匹配多个字符串在执行动作后加此命令</p>
<p> expect最常用的语法(tcl语言:模式-动作)<br> 单一分支模式语法:<br>​    expect “hi” {send “You said hi\n”}<br>​    匹配到hi后,会输出“you said hi”,并换行<br> 多分支模式语法:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">expect "hi" &#123; send "You said hi\n" &#125; \</span><br><span class="line">"hehe" &#123; send “Hehe yourself\n" &#125; \</span><br><span class="line">"bye" &#123; send “Good bye\n" &#125;</span><br></pre></td></tr></table></figure>

<p>匹配hi,hello,bye任意字符串时,执行相应输出.等同如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">expect &#123;</span><br><span class="line">"hi" &#123; send "You said hi\n"&#125;</span><br><span class="line">"hehe" &#123; send "Hehe yourself\n"&#125;</span><br><span class="line">"bye" &#123; send “Good bye\n"&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="expect例程"><a href="#expect例程" class="headerlink" title="expect例程"></a>expect例程</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line">spawn scp /etc/fstab 192.168.8.100:/app</span><br><span class="line">expect &#123;</span><br><span class="line">	"yes/no" &#123; send "yes\n";exp_continue &#125;</span><br><span class="line">	"password" &#123; send “mark\n" &#125;</span><br><span class="line">&#125;</span><br><span class="line">expect eof</span><br></pre></td></tr></table></figure>

<p>例程:变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line">set ip 192.168.8.100</span><br><span class="line">set user root</span><br><span class="line">set password mark</span><br><span class="line">set timeout 10</span><br><span class="line">spawn ssh $user@$ip</span><br><span class="line">expect &#123;</span><br><span class="line">	"yes/no" &#123; send "yes\n";exp_continue &#125;</span><br><span class="line">	"password" &#123; send "$password\n" &#125;</span><br><span class="line">&#125;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure>

<p>例程:位置参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line">set ip [lindex $argv 0]</span><br><span class="line">set user [lindex $argv 1]</span><br><span class="line">set password [lindex $argv 2]</span><br><span class="line">spawn ssh $user@$ip</span><br><span class="line">expect &#123;</span><br><span class="line"> "yes/no" &#123; send "yes\n";exp_continue &#125;</span><br><span class="line"> "password" &#123; send "$password\n" &#125;</span><br><span class="line">&#125;</span><br><span class="line">interact</span><br><span class="line"><span class="meta">#</span><span class="bash">./ssh3.exp 192.168.8.100 root mark</span></span><br></pre></td></tr></table></figure>

<p>例程:执行多个命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line">set ip [lindex $argv 0]</span><br><span class="line">set user [lindex $argv 1]</span><br><span class="line">set password [lindex $argv 2]</span><br><span class="line">set timeout 10</span><br><span class="line">spawn ssh $user@$ip</span><br><span class="line">expect &#123;</span><br><span class="line"> "yes/no" &#123; send "yes\n";exp_continue &#125;</span><br><span class="line"> "password" &#123; send "$password\n" &#125;</span><br><span class="line">&#125;</span><br><span class="line">expect "]#" &#123; send "useradd haha\n" &#125;</span><br><span class="line">expect "]#" &#123; send "echo mark |passwd --stdin haha\n" &#125;</span><br><span class="line">send "exit\n"</span><br><span class="line">expect eof</span><br><span class="line"><span class="meta">#</span><span class="bash">./ssh4.exp 192.168.8.100 root mark</span></span><br></pre></td></tr></table></figure>

<p>例程:shell脚本调用expect</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">ip=$1</span><br><span class="line">user=$2</span><br><span class="line">password=$3</span><br><span class="line">expect &lt;&lt;EOF</span><br><span class="line">set timeout 10</span><br><span class="line">spawn ssh $user@$ip</span><br><span class="line">expect &#123;</span><br><span class="line"> "yes/no" &#123; send "yes\n";exp_continue &#125;</span><br><span class="line"> "password" &#123; send "$password\n" &#125;</span><br><span class="line">&#125;</span><br><span class="line">expect "]#" &#123; send "useradd hehe\n" &#125;</span><br><span class="line">expect "]#" &#123; send "echo mark |passwd --stdin hehe\n" &#125;</span><br><span class="line">expect "]#" &#123; send "exit\n" &#125;</span><br><span class="line">expect eof</span><br><span class="line">EOF</span><br><span class="line"><span class="meta">#</span><span class="bash">./ssh5.sh 192.168.8.100 root mark</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Shell 脚本编程进阶(三)</title>
    <url>/Linux-Shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6-%E4%B8%89/</url>
    <content><![CDATA[<h3 id="信号捕捉trap"><a href="#信号捕捉trap" class="headerlink" title="信号捕捉trap"></a>信号捕捉trap</h3><p>trap ‘触发指令’ 信号<br>​    自定义进程收到系统发出的指定信号后,将执行触发指令,而不会执行原操作<br>trap ‘’ 信号<br>​    忽略信号的操作<br>trap ‘-‘ 信号<br>​    恢复原信号的操作<br>trap -p<br>​    列出自定义信号操作</p>
<p>trap例程:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"> trap 'echo “signal:SIGINT"' int</span><br><span class="line"> trap -p</span><br><span class="line"> for((i=0;i&lt;=10;i++))</span><br><span class="line"> do</span><br><span class="line"> 	sleep 1</span><br><span class="line">	echo $i</span><br><span class="line"> done</span><br><span class="line"> trap '' int</span><br><span class="line"> trap -p</span><br><span class="line"> for((i=11;i&lt;=20;i++))</span><br><span class="line"> do</span><br><span class="line"> 	sleep 1</span><br><span class="line"> 	echo $i</span><br><span class="line"> done</span><br><span class="line"> trap '-' int</span><br><span class="line"> trap -p</span><br><span class="line"> for((i=21;i&lt;=30;i++))</span><br><span class="line"> do</span><br><span class="line"> 	sleep 1</span><br><span class="line"> 	echo $i</span><br><span class="line"> done</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>变量:存储单个元素的内存空间<br>数组:存储多个元素的连续的内存空间,相当于多个变量的集合<br>数组名和索引<br>​    索引:编号从0开始,属于数值索引<br>​    注意:索引可支持使用自定义的格式,而不仅是数值格式,即为关联索引,bash4.0版本之后开始支持<br>​    bash的数组支持稀疏格式（索引不连续）<br>声明数组:<br>​    declare -a ARRAY_NAME<br>​    declare -A ARRAY_NAME: 关联数组<br>​    注意:两者不可相互转换</p>
<h4 id="数组赋值"><a href="#数组赋值" class="headerlink" title="数组赋值"></a>数组赋值</h4><p>数组元素的赋值<br>​    (1) 一次只赋值一个元素<br>​    ARRAY_NAME[INDEX]=VALUE<br>​    weekdays[0]=”Sunday”<br>​    weekdays[4]=”Thursday”<br>​    (2) 一次赋值全部元素<br>​    ARRAY_NAME=(“VAL1” “VAL2” “VAL3” …)<br>​    (3) 只赋值特定元素<br>​    ARRAY_NAME=([0]=”VAL1” [3]=”VAL2” …)<br>​    (4) 交互式数组值对赋值<br>​    read -a ARRAY<br>显示所有数组:declare -a </p>
<h4 id="引用数组"><a href="#引用数组" class="headerlink" title="引用数组"></a>引用数组</h4><p>引用数组元素:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">`$&#123;ARRAY_NAME[INDEX]&#125;`</span><br><span class="line"></span><br><span class="line">注意:省略[INDEX]表示引用下标为0的元素</span><br></pre></td></tr></table></figure>

<p>引用数组所有元素:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">`$&#123;ARRAY_NAME[\*]&#125;`</span><br><span class="line"></span><br><span class="line">`$&#123;ARRAY_NAME[@]&#125;`</span><br></pre></td></tr></table></figure>

<p>数组的长度(数组中元素的个数):</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">`$&#123;#ARRAY_NAME[\*]&#125;`</span><br><span class="line"></span><br><span class="line">`$&#123;#ARRAY_NAME[@]&#125;`</span><br></pre></td></tr></table></figure>

<p>删除数组中的某元素:导致稀疏格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">`unset ARRAY[INDEX]`</span><br></pre></td></tr></table></figure>

<p>删除整个数组:<br>​    <code>unset ARRAY</code></p>
<h4 id="数组数据处理"><a href="#数组数据处理" class="headerlink" title="数组数据处理"></a>数组数据处理</h4><p>引用数组中的元素:<br>​    数组切片:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">`$&#123;ARRAY[@]:offset:number&#125;`</span><br><span class="line"></span><br><span class="line">	offset: 要跳过的元素个数</span><br><span class="line"></span><br><span class="line">	number: 要取出的元素个数</span><br><span class="line"></span><br><span class="line">	取偏移量之后的所有元素</span><br><span class="line"></span><br><span class="line">`$&#123;ARRAY[@]:offset&#125;`</span><br></pre></td></tr></table></figure>

<p>向数组中追加元素:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">`ARRAY[$&#123;#ARRAY[*]&#125;]=value`</span><br></pre></td></tr></table></figure>

<p>关联数组:<br>​    <code>declare -A ARRAY_NAME</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">`ARRAY_NAME=([idx_name1]='val1' [idx_name2]='val2‘...)`</span><br><span class="line"></span><br><span class="line">注意:关联数组必须先声明再调用</span><br></pre></td></tr></table></figure>

<p>数组例程:</p>
<p>生成10个随机数保存于数组中,并找出其最大值和最小值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">declare -i min max</span><br><span class="line">declare -a nums</span><br><span class="line">for ((i=0;i&lt;10;i++));do</span><br><span class="line"><span class="meta">	nums[$</span><span class="bash">i]=<span class="variable">$RANDOM</span></span></span><br><span class="line">	[ $i -eq 0 ] &amp;&amp; min=$&#123;nums[$i]&#125; &amp;&amp; max=$&#123;nums[$i]&#125;&amp;&amp; continue</span><br><span class="line">	[ $&#123;nums[$i]&#125; -gt $max ] &amp;&amp; max=$&#123;nums[$i]&#125;</span><br><span class="line">	[ $&#123;nums[$i]&#125; -lt $min ] &amp;&amp; min=$&#123;nums[$i]&#125;</span><br><span class="line">done</span><br><span class="line">echo “All numbers are $&#123;nums[*]&#125;”</span><br><span class="line">echo Max is $max</span><br><span class="line">echo Min is $min</span><br></pre></td></tr></table></figure>

<p>编写脚本,定义一个数组,数组中的元素是/var/log目录下所有以.log结尾的文件;统计出其下标为偶数的文件中的行数之和</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">declare -a files</span><br><span class="line">files=(/var/log/*.log)</span><br><span class="line">declare -i lines=0</span><br><span class="line">for i in $(seq 0 $[$&#123;#files[*]&#125;-1]); do</span><br><span class="line">	if [ $[$i%2] -eq 0 ];then</span><br><span class="line">		let lines+=$(wc -l $&#123;files[$i]&#125; | cut -d' ' -f1)</span><br><span class="line">	fi</span><br><span class="line">done</span><br><span class="line">echo "Lines: $lines."</span><br></pre></td></tr></table></figure>



<h3 id="shell中的字符串"><a href="#shell中的字符串" class="headerlink" title="shell中的字符串"></a>shell中的字符串</h3><h4 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;<span class="comment">#var&#125;:返回字符串变量var的长度</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;var:offset&#125;:返回字符串变量var中从第offset个字符后（不包括第offset个字符）的字</span></span><br><span class="line">符开始，到最后的部分，offset的取值在0 到 $&#123;#var&#125;-1 之间(bash4.2后，允许为负值)</span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;var:offset:number&#125;：返回字符串变量var中从第offset个字符后（不包括第offset个</span></span><br><span class="line">字符）的字符开始，长度为number的部分</span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;var: -length&#125;：取字符串的最右侧几个字符</span></span><br><span class="line">注意：冒号后必须有一空白字符</span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;var:offset:-length&#125;：从最左侧跳过offset字符，一直向右取到距离最右侧lengh个字</span></span><br><span class="line">符之前的内容</span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;var: -length:-offset&#125;：先从最右侧向左取到length个字符开始，再向右取到距离最</span></span><br><span class="line">右侧offset个字符之间的内容</span><br><span class="line">注意：-length前空格</span><br></pre></td></tr></table></figure>

<h4 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h4><p><strong>基于模式取子串</strong><br>​    ${var#*word}:其中word可以是指定的任意字符</p>
<p>功能:自左而右,查找var变量所存储的字符串中,第一次出现的word, 删除字符串开头至第一次出现word字符之间的所有字符</p>
<p>${var##*word}:同上,贪婪模式,不同的是,删除的是字符串开头至最后一次由word指定的字符之间的所有内容    </p>
<p>示例:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">file=“var/log/messages”</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;file<span class="comment">#*/&#125;: log/messages</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;file<span class="comment">##*/&#125;: messages</span></span></span><br></pre></td></tr></table></figure>

<p><code>${var%word\*}</code>:其中word可以是指定的任意字符<br>​    功能:自右而左,查找var变量所存储的字符串中,第一次出现的word, 删除字符串最后一个字符向左至第一次出现word字符之间的所有字符<br>​    <code>file=&quot;/var/log/messages&quot;</code><br>​    <code>${file%/\*}: /var/log</code><br><code>${var%%word\*}</code>:同上,只不过删除字符串最右侧的字符向左至最后一次出现word字符之间的所有字符;<br>示例:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">url=http://www.google.com:80</span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;url<span class="comment">##*:&#125; 80</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;url%%:*&#125; http</span></span><br></pre></td></tr></table></figure>



<p><strong>查找替换</strong><br>​    ${var/pattern/substr}:查找var所表示的字符串中,第一次被pattern所匹配到的字符串,以substr替换之<br>​    ${var//pattern/substr}: 查找var所表示的字符串中,所有能被pattern所匹配到的字符串,以substr替换之<br>​    ${var/#pattern/substr}:查找var所表示的字符串中,行首被pattern所匹配到的字符串,以substr替换之<br>​    ${var/%pattern/substr}:查找var所表示的字符串中,行尾被pattern所匹配到的字符串,以substr替换之</p>
<p><strong>查找并删除</strong><br>​    ${var/pattern}:删除var表示的字符串中第一次被pattern匹配到的字符串<br>​    ${var//pattern}:删除var表示的字符串中所有被pattern匹配到的字符串<br>​    ${var/#pattern}:删除var表示的字符串中所有以pattern为行首匹配到的字符串<br>​    ${var/%pattern}:删除var所表示的字符串中所有以pattern为行尾所匹配到的字符串</p>
<p><strong>字符大小写转换</strong><br>​    ${var^^}:把var中的所有小写字母转换为大写<br>​    ${var,,}:把var中的所有大写字母转换为小写</p>
<p><strong>变量赋值</strong></p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_shell_learning_01.png" alt=""></p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言简介(三)</title>
    <url>/Go-%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B-%E4%B8%89/</url>
    <content><![CDATA[<h4 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h4><p>GoRoutine主要是使用go关键字来调用函数，还可以使用匿名函数，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(msg)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">go</span> f(<span class="string">"goroutine"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(msg)</span><br><span class="line">    &#125;(<span class="string">"going"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再来看一个示例，下面的代码中包括很多内容，包括时间处理，随机数处理，还有goroutine的代码。如果你熟悉C语言，你应该会很容易理解下面的代码。</p>
<p>你可以简单的把go关键字调用的函数想像成pthread_create。下面的代码使用for循环创建了3个线程，每个线程使用一个随机的Sleep时间，然后在routine()函数中会输出一些线程执行的时间信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"math/rand"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">routine</span><span class="params">(name <span class="keyword">string</span>, delay time.Duration)</span></span> &#123;</span><br><span class="line"> </span><br><span class="line">    t0 := time.Now()</span><br><span class="line">    fmt.Println(name, <span class="string">" start at "</span>, t0)</span><br><span class="line"> </span><br><span class="line">    time.Sleep(delay)</span><br><span class="line"> </span><br><span class="line">    t1 := time.Now()</span><br><span class="line">    fmt.Println(name, <span class="string">" end at "</span>, t1)</span><br><span class="line"> </span><br><span class="line">    fmt.Println(name, <span class="string">" lasted "</span>, t1.Sub(t0))</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//生成随机种子</span></span><br><span class="line">    rand.Seed(time.Now().Unix())</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++&#123;</span><br><span class="line">        name = fmt.Sprintf(<span class="string">"go_%02d"</span>, i) <span class="comment">//生成ID</span></span><br><span class="line">        <span class="comment">//生成随机等待时间，从0-4秒</span></span><br><span class="line">        <span class="keyword">go</span> routine(name, time.Duration(rand.Intn(<span class="number">5</span>)) * time.Second)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//让主进程停住，不然主进程退了，goroutine也就退了</span></span><br><span class="line">    <span class="keyword">var</span> input <span class="keyword">string</span></span><br><span class="line">    fmt.Scanln(&amp;input)</span><br><span class="line">    fmt.Println(<span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行的结果可能是:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">go_00  start at  <span class="number">2012</span><span class="number">-11</span><span class="number">-04</span> <span class="number">19</span>:<span class="number">46</span>:<span class="number">35.8974894</span> +<span class="number">0800</span> +<span class="number">0800</span></span><br><span class="line">go_01  start at  <span class="number">2012</span><span class="number">-11</span><span class="number">-04</span> <span class="number">19</span>:<span class="number">46</span>:<span class="number">35.8974894</span> +<span class="number">0800</span> +<span class="number">0800</span></span><br><span class="line">go_02  start at  <span class="number">2012</span><span class="number">-11</span><span class="number">-04</span> <span class="number">19</span>:<span class="number">46</span>:<span class="number">35.8974894</span> +<span class="number">0800</span> +<span class="number">0800</span></span><br><span class="line">go_01  end at  <span class="number">2012</span><span class="number">-11</span><span class="number">-04</span> <span class="number">19</span>:<span class="number">46</span>:<span class="number">36.8975894</span> +<span class="number">0800</span> +<span class="number">0800</span></span><br><span class="line">go_01  lasted  <span class="number">1.0001</span>s</span><br><span class="line">go_02  end at  <span class="number">2012</span><span class="number">-11</span><span class="number">-04</span> <span class="number">19</span>:<span class="number">46</span>:<span class="number">38.8987895</span> +<span class="number">0800</span> +<span class="number">0800</span></span><br><span class="line">go_02  lasted  <span class="number">3.0013001</span>s</span><br><span class="line">go_00  end at  <span class="number">2012</span><span class="number">-11</span><span class="number">-04</span> <span class="number">19</span>:<span class="number">46</span>:<span class="number">39.8978894</span> +<span class="number">0800</span> +<span class="number">0800</span></span><br><span class="line">go_00  lasted  <span class="number">4.0004</span>s</span><br></pre></td></tr></table></figure>

<h4 id="goroutine的并发安全性"><a href="#goroutine的并发安全性" class="headerlink" title="goroutine的并发安全性"></a>goroutine的并发安全性</h4><p>关于goroutine，我试了一下，无论是Windows还是Linux，基本上来说是用操作系统的线程来实现的。不过，goroutine有个特性，也就是说，<strong>如果一个goroutine没有被阻塞，那么别的goroutine就不会得到执行</strong>。这并不是真正的并发，如果你要真正的并发，你需要在你的main函数的第一行加上下面的这段代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"runtime"</span></span><br><span class="line">...</span><br><span class="line">runtime.GOMAXPROCS(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>还是让我们来看一个有并发安全性问题的示例（注意：我使用了C的方式来写这段Go的程序）</p>
<p>这是一个经常出现在教科书里卖票的例子，我启了5个goroutine来卖票，卖票的函数sell_tickets很简单，就是随机的sleep一下，然后对全局变量total_tickets作减一操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"math/rand"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"runtime"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> total_tickets <span class="keyword">int32</span> = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sell_tickets</span><span class="params">(i <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> total_tickets &gt; <span class="number">0</span> &#123; <span class="comment">//如果有票就卖</span></span><br><span class="line">            time.Sleep( time.Duration(rand.Intn(<span class="number">5</span>)) * time.Millisecond)</span><br><span class="line">            total_tickets-- <span class="comment">//卖一张票</span></span><br><span class="line">            fmt.Println(<span class="string">"id:"</span>, i, <span class="string">"  ticket:"</span>, total_tickets)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">4</span>) <span class="comment">//我的电脑是4核处理器，所以我设置了4</span></span><br><span class="line">    rand.Seed(time.Now().Unix()) <span class="comment">//生成随机种子</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123; <span class="comment">//并发5个goroutine来卖票</span></span><br><span class="line">         <span class="keyword">go</span> sell_tickets(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//等待线程执行完</span></span><br><span class="line">    <span class="keyword">var</span> input <span class="keyword">string</span></span><br><span class="line">    fmt.Scanln(&amp;input)</span><br><span class="line">    fmt.Println(total_tickets, <span class="string">"done"</span>) <span class="comment">//退出时打印还有多少票</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序毋庸置疑有并发安全性问题，所以执行起来你会看到下面的结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$<span class="keyword">go</span> run sell_tickets.<span class="keyword">go</span></span><br><span class="line">id: <span class="number">0</span>   ticket: <span class="number">9</span>  </span><br><span class="line">id: <span class="number">0</span>   ticket: <span class="number">8</span>  </span><br><span class="line">id: <span class="number">4</span>   ticket: <span class="number">7</span>  </span><br><span class="line">id: <span class="number">1</span>   ticket: <span class="number">6</span>  </span><br><span class="line">id: <span class="number">3</span>   ticket: <span class="number">5</span>  </span><br><span class="line">id: <span class="number">0</span>   ticket: <span class="number">4</span>  </span><br><span class="line">id: <span class="number">3</span>   ticket: <span class="number">3</span>  </span><br><span class="line">id: <span class="number">2</span>   ticket: <span class="number">2</span>  </span><br><span class="line">id: <span class="number">0</span>   ticket: <span class="number">1</span>  </span><br><span class="line">id: <span class="number">3</span>   ticket: <span class="number">0</span>  </span><br><span class="line">id: <span class="number">1</span>   ticket: <span class="number">-1</span>  </span><br><span class="line">id: <span class="number">4</span>   ticket: <span class="number">-2</span>  </span><br><span class="line">id: <span class="number">2</span>   ticket: <span class="number">-3</span>  </span><br><span class="line">id: <span class="number">0</span>   ticket: <span class="number">-4</span>  </span><br><span class="line"><span class="number">-4</span> done</span><br></pre></td></tr></table></figure>

<p>可见，我们需要使用上锁，我们可以使用互斥量来解决这个问题。下面的代码，我只列出了修改过的内容：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"math/rand"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"runtime"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> total_tickets <span class="keyword">int32</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> mutex = &amp;sync.Mutex&#123;&#125; <span class="comment">//可简写成：var mutex sync.Mutex</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sell_tickets</span><span class="params">(i <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> total_tickets&gt;<span class="number">0</span> &#123;</span><br><span class="line">        mutex.Lock()</span><br><span class="line">        <span class="keyword">if</span> total_tickets &gt; <span class="number">0</span> &#123;</span><br><span class="line">            time.Sleep( time.Duration(rand.Intn(<span class="number">5</span>)) * time.Millisecond)</span><br><span class="line">            total_tickets--</span><br><span class="line">            fmt.Println(i, total_tickets)</span><br><span class="line">        &#125;</span><br><span class="line">        mutex.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">.......</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><p>说到并发就需要说说原子操作在这里就举一个很简单的示例：下面的程序有10个goroutine，每个会对cnt变量累加20次，所以，最后的cnt应该是200。如果没有atomic的原子操作，那么cnt将有可能得到一个小于200的数。</p>
<p>下面使用了atomic操作，所以是安全的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync/atomic"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> cnt <span class="keyword">uint32</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">20</span>; i++ &#123;</span><br><span class="line">                time.Sleep(time.Millisecond)</span><br><span class="line">                atomic.AddUint32(&amp;cnt, <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Second)<span class="comment">//等一秒钟等goroutine完成</span></span><br><span class="line">    cntFinal := atomic.LoadUint32(&amp;cnt)<span class="comment">//取数据</span></span><br><span class="line">    fmt.Println(<span class="string">"cnt:"</span>, cntFinal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的函数还有很多，参看<a href="http://golang.org/pkg/sync/atomic/" target="_blank" rel="noopener">go的atomic包文档</a></p>
<h4 id="Channel信道"><a href="#Channel信道" class="headerlink" title="Channel信道"></a>Channel信道</h4><p>Channal是什么？Channal就是用来通信的，就像Unix下的管道一样，在Go中是这样使用Channel的。</p>
<p>下面的程序演示了一个goroutine和主程序通信的例程。这个程序足够简单了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//创建一个string类型的channel</span></span><br><span class="line">    channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//创建一个goroutine向channel里发一个字符串</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; channel &lt;- <span class="string">"hello"</span> &#125;()</span><br><span class="line"> </span><br><span class="line">    msg := &lt;- channel</span><br><span class="line">    fmt.Println(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>指定channel的buffer</strong></p>
<p>指定buffer的大小很简单，看下面的程序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        channel &lt;- <span class="string">"hello"</span></span><br><span class="line">        channel &lt;- <span class="string">"World"</span></span><br><span class="line">    &#125;()</span><br><span class="line"> </span><br><span class="line">    msg1 := &lt;-channel</span><br><span class="line">    msg2 := &lt;-channel</span><br><span class="line">    fmt.Println(msg1, msg2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Channel的阻塞</strong></p>
<p>注意，channel默认上是阻塞的，也就是说，如果Channel满了，就阻塞写，如果Channel空了，就阻塞读。于是，我们就可以使用这种特性来同步我们的发送和接收端。</p>
<p>下面这个例程说明了这一点，代码有点乱，不过我觉得不难理解。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> </span><br><span class="line">    channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>) <span class="comment">//注意: buffer为1</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        channel &lt;- <span class="string">"hello"</span></span><br><span class="line">        fmt.Println(<span class="string">"write \"hello\" done!"</span>)</span><br><span class="line"> </span><br><span class="line">        channel &lt;- <span class="string">"World"</span> <span class="comment">//Reader在Sleep，这里在阻塞</span></span><br><span class="line">        fmt.Println(<span class="string">"write \"World\" done!"</span>)</span><br><span class="line"> </span><br><span class="line">        fmt.Println(<span class="string">"Write go sleep..."</span>)</span><br><span class="line">        time.Sleep(<span class="number">3</span>*time.Second)</span><br><span class="line">        channel &lt;- <span class="string">"channel"</span></span><br><span class="line">        fmt.Println(<span class="string">"write \"channel\" done!"</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"> </span><br><span class="line">    time.Sleep(<span class="number">2</span>*time.Second)</span><br><span class="line">    fmt.Println(<span class="string">"Reader Wake up..."</span>)</span><br><span class="line"> </span><br><span class="line">    msg := &lt;-channel</span><br><span class="line">    fmt.Println(<span class="string">"Reader: "</span>, msg)</span><br><span class="line"> </span><br><span class="line">    msg = &lt;-channel</span><br><span class="line">    fmt.Println(<span class="string">"Reader: "</span>, msg)</span><br><span class="line"> </span><br><span class="line">    msg = &lt;-channel <span class="comment">//Writer在Sleep，这里在阻塞</span></span><br><span class="line">    fmt.Println(<span class="string">"Reader: "</span>, msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码输出的结果如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Reader Wake up...</span><br><span class="line">Reader:  hello</span><br><span class="line">write <span class="string">"hello"</span> done!</span><br><span class="line">write <span class="string">"World"</span> done!</span><br><span class="line">Write <span class="keyword">go</span> sleep...</span><br><span class="line">Reader:  World</span><br><span class="line">write <span class="string">"channel"</span> done!</span><br><span class="line">Reader:  channel</span><br></pre></td></tr></table></figure>

<p><strong>Channel阻塞的这个特性还有一个好处是，可以让我们的goroutine在运行的一开始就阻塞在从某个channel领任务，这样就可以作成一个类似于线程池一样的东西。</strong></p>
<p><strong>多个Channel的select</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//创建两个channel - c1 c2</span></span><br><span class="line">    c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//创建两个goruntine来分别向这两个channel发送数据</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">        c1 &lt;- <span class="string">"Hello"</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">        c2 &lt;- <span class="string">"World"</span></span><br><span class="line">    &#125;()</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//使用select来侦听两个channel</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> msg1 := &lt;-c1:</span><br><span class="line">            fmt.Println(<span class="string">"received"</span>, msg1)</span><br><span class="line">        <span class="keyword">case</span> msg2 := &lt;-c2:</span><br><span class="line">            fmt.Println(<span class="string">"received"</span>, msg2)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：上面的select是阻塞的，所以，才搞出ugly的for i &lt;2这种东西<strong>。</strong></p>
<p><strong>Channel select阻塞的Timeout</strong></p>
<p>解决上述那个for循环的问题，一般有两种方法：一种是阻塞但有timeout，一种是无阻塞。我们来看看如果给select设置上timeout的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    timeout_cnt := <span class="number">0</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> msg1 := &lt;-c1:</span><br><span class="line">        fmt.Println(<span class="string">"msg1 received"</span>, msg1)</span><br><span class="line">    <span class="keyword">case</span> msg2 := &lt;-c2:</span><br><span class="line">        fmt.Println(<span class="string">"msg2 received"</span>, msg2)</span><br><span class="line">    <span class="keyword">case</span>  &lt;-time.After(time.Second * <span class="number">30</span>)：</span><br><span class="line">        fmt.Println(<span class="string">"Time Out"</span>)</span><br><span class="line">        timout_cnt++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> time_cnt &gt; <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中高亮的代码主要是用来让select返回的，注意 case中的time.After事件。</p>
<p><strong>Channel的无阻塞</strong></p>
<p>好，我们再来看看无阻塞的channel，其实也很简单，就是在select中加入default，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> msg1 := &lt;-c1:</span><br><span class="line">        fmt.Println(<span class="string">"received"</span>, msg1)</span><br><span class="line">    <span class="keyword">case</span> msg2 := &lt;-c2:</span><br><span class="line">        fmt.Println(<span class="string">"received"</span>, msg2)</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">//default会导致无阻塞</span></span><br><span class="line">        fmt.Println(<span class="string">"nothing received!"</span>)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Channel的关闭</strong></p>
<p>关闭Channel可以通知对方内容发送完了，不用再等了。参看下面的例程：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"math/rand"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> </span><br><span class="line">    channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    rand.Seed(time.Now().Unix())</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//向channel发送随机个数的message</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">        cnt := rand.Intn(<span class="number">10</span>)</span><br><span class="line">        fmt.Println(<span class="string">"message cnt :"</span>, cnt)</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;cnt; i++&#123;</span><br><span class="line">            channel &lt;- fmt.Sprintf(<span class="string">"message-%2d"</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(channel) <span class="comment">//关闭Channel</span></span><br><span class="line">    &#125;()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> more <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> msg <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">for</span> more &#123;</span><br><span class="line">        <span class="keyword">select</span>&#123;</span><br><span class="line">        <span class="comment">//channel会返回两个值，一个是内容，一个是还有没有内容</span></span><br><span class="line">        <span class="keyword">case</span> msg, more = &lt;- channel:</span><br><span class="line">            <span class="keyword">if</span> more &#123;</span><br><span class="line">                fmt.Println(msg)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                fmt.Println(<span class="string">"channel closed!"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考自:</p>
<p>GO 语言简介（下）— 特性</p>
<p><a href="https://coolshell.cn/articles/8489.html" target="_blank" rel="noopener">https://coolshell.cn/articles/8489.html</a></p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言简介(二)</title>
    <url>/Go-%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B-%E4%BA%8C/</url>
    <content><![CDATA[<h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><p><strong>new</strong> 是一个分配内存的内建函数，但不同于其他语言中同名的new所作的工作，<strong>它只是将内存清零，而不是初始化内存</strong>。new(T)为一个类型为T的新项目分配了值为零的存储空间并返回其地址，也就是一个类型为<em>T的值。用Go的术语来说，就是*</em>它返回了一个指向新分配的类型为T的零值的指针**。</p>
<p><code>**make**(T,</code><em>args</em><code>)</code>函数的目的与<code>new(T)</code>不同。它仅用于创建切片、map和chan（消息管道），并返回类型<code>T</code>（不是<code>*T</code>）的一个<strong>被初始化了的</strong>（不是<strong>零</strong>）实例。这种差别的出现是由于这三种类型实质上是对在使用前必须进行初始化的数据结构的引用。例如，切片是一个具有三项内容的描述符，包括指向数据（在一个数组内部）的指针、长度以及容量，在这三项内容被初始化之前，切片值为<code>nil</code>。对于切片、映射和信道，<code>make</code>初始化了其内部的数据结构并准备了将要使用的值。如：</p>
<p>下面的代码分配了一个整型数组，长度为10，容量为100，并返回前10个数组的切片</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>以下示例说明了<code>new</code>和<code>make</code>的不同。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p *[]<span class="keyword">int</span> = <span class="built_in">new</span>([]<span class="keyword">int</span>)   <span class="comment">// 为切片结构分配内存；*p == nil；很少使用</span></span><br><span class="line"><span class="keyword">var</span> v  []<span class="keyword">int</span> = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>) <span class="comment">// 切片v现在是对一个新的有10个整数的数组的引用</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 不必要地使问题复杂化：</span></span><br><span class="line"><span class="keyword">var</span> p *[]<span class="keyword">int</span> = <span class="built_in">new</span>([]<span class="keyword">int</span>)</span><br><span class="line">fmt.Println(p) <span class="comment">//输出：&amp;[]</span></span><br><span class="line">*p = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(p) <span class="comment">//输出：&amp;[0 0 0 0 0 0 0 0 0 0]</span></span><br><span class="line">fmt.Println((*p)[<span class="number">2</span>]) <span class="comment">//输出： 0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 习惯用法:</span></span><br><span class="line">v := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(v) <span class="comment">//输出：[0 0 0 0 0 0 0 0 0 0]</span></span><br></pre></td></tr></table></figure>

<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>要注意Go语言这种声明变量类型和函数返回值是反过来的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="comment">//注意参数和返回值是怎么声明的</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(max(<span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数返回多个值</strong></p>
<p>Go中很多Package 都会返回两个值，一个是正常值，一个是错误，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    v, e := multi_ret(<span class="string">"one"</span>)</span><br><span class="line">    fmt.Println(v,e) <span class="comment">//输出 1 true</span></span><br><span class="line"> </span><br><span class="line">    v, e = multi_ret(<span class="string">"four"</span>)</span><br><span class="line">    fmt.Println(v,e) <span class="comment">//输出 0 false</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//通常的用法(注意分号后有e)</span></span><br><span class="line">    <span class="keyword">if</span> v, e = multi_ret(<span class="string">"four"</span>); e &#123;</span><br><span class="line">        <span class="comment">// 正常返回</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 出错返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multi_ret</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span>&#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"one"</span>: <span class="number">1</span>, <span class="string">"two"</span>: <span class="number">2</span>, <span class="string">"three"</span>: <span class="number">3</span>&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> err <span class="keyword">bool</span></span><br><span class="line">    <span class="keyword">var</span> val <span class="keyword">int</span></span><br><span class="line"> </span><br><span class="line">    val, err = m[key]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> val, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数不定参数</strong></p>
<p>例子很清楚了，我就不多说了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(nums ...<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Print(nums, <span class="string">" "</span>)  <span class="comment">//输出如 [1, 2, 3] 之类的数组</span></span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123; <span class="comment">//要的是值而不是下标</span></span><br><span class="line">        total += num</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(total)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sum(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//传数组</span></span><br><span class="line">    nums := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    sum(nums...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数闭包</strong></p>
<p>nextNum这个函数返回了一个匿名函数，这个匿名函数记住了nextNum中i+j的值，并改变了i,j的值，于是形成了一个闭包的用法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextNum</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    i,j := <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> tmp = i+j</span><br><span class="line">        i, j = j, tmp</span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main函数中是对nextNum的调用，其主要是打出下一个斐波拉契数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    nextNumFunc := nextNum()</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(nextNumFunc())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数的递归</strong></p>
<p>和c基本是一样的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fact</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n * fact(n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(fact(<span class="number">7</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p>Go的结构体和C的基本上一样，不过在初始化时有些不一样，Go支持带名字的初始化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">    email <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    person := Person&#123;<span class="string">"Tom"</span>, <span class="number">30</span>, <span class="string">"tom@gmail.com"</span>&#125;</span><br><span class="line">    person = Person&#123;name:<span class="string">"Tom"</span>, age: <span class="number">30</span>, email:<span class="string">"tom@gmail.com"</span>&#125;</span><br><span class="line"> </span><br><span class="line">    fmt.Println(person) <span class="comment">//输出 &#123;Tom 30 tom@gmail.com&#125;</span></span><br><span class="line"> </span><br><span class="line">    pPerson := &amp;person</span><br><span class="line"> </span><br><span class="line">    fmt.Println(pPerson) <span class="comment">//输出 &amp;&#123;Tom 30 tom@gmail.com&#125;</span></span><br><span class="line"> </span><br><span class="line">    pPerson.age = <span class="number">40</span></span><br><span class="line">    person.name = <span class="string">"Jerry"</span></span><br><span class="line">    fmt.Println(person) <span class="comment">//输出 &#123;Jerry 40 tom@gmail.com&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结构体方法"><a href="#结构体方法" class="headerlink" title="结构体方法"></a>结构体方法</h4><p>注意：Go语言中没有public, protected, private的关键字，所以，<strong>如果想让一个方法可以被别的包访问的话，需要把这个方法的第一个字母大写。这是一种约定</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> rect <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *rect)</span> <span class="title">area</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="comment">//求面积</span></span><br><span class="line">    <span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *rect)</span> <span class="title">perimeter</span><span class="params">()</span> <span class="title">int</span></span>&#123; <span class="comment">//求周长</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*(r.width + r.height)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := rect&#123;width: <span class="number">10</span>, height: <span class="number">15</span>&#125;</span><br><span class="line"> </span><br><span class="line">    fmt.Println(<span class="string">"面积: "</span>, r.area())</span><br><span class="line">    fmt.Println(<span class="string">"周长: "</span>, r.perimeter())</span><br><span class="line"> </span><br><span class="line">    rp := &amp;r</span><br><span class="line">    fmt.Println(<span class="string">"面积: "</span>, rp.area())</span><br><span class="line">    fmt.Println(<span class="string">"周长: "</span>, rp.perimeter())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接口和多态"><a href="#接口和多态" class="headerlink" title="接口和多态"></a>接口和多态</h4><p>接口意味着多态，下面是一个经典的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//---------- 接 口 --------//</span></span><br><span class="line"><span class="keyword">type</span> shape <span class="keyword">interface</span> &#123;</span><br><span class="line">    area() <span class="keyword">float64</span> <span class="comment">//计算面积</span></span><br><span class="line">    perimeter() <span class="keyword">float64</span> <span class="comment">//计算周长</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//--------- 长方形 ----------//</span></span><br><span class="line"><span class="keyword">type</span> rect <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *rect)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span> &#123; <span class="comment">//面积</span></span><br><span class="line">    <span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *rect)</span> <span class="title">perimeter</span><span class="params">()</span> <span class="title">float64</span></span> &#123; <span class="comment">//周长</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*(r.width + r.height)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//----------- 圆  形 ----------//</span></span><br><span class="line"><span class="keyword">type</span> circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    radius <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *circle)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span> &#123; <span class="comment">//面积</span></span><br><span class="line">    <span class="keyword">return</span> math.Pi * c.radius * c.radius</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *circle)</span> <span class="title">perimeter</span><span class="params">()</span> <span class="title">float64</span></span> &#123; <span class="comment">//周长</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * math.Pi * c.radius</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ----------- 接口的使用 -----------//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">interface_test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := rect &#123;width:<span class="number">2.9</span>, height:<span class="number">4.8</span>&#125;</span><br><span class="line">    c := circle &#123;radius:<span class="number">4.3</span>&#125;</span><br><span class="line"> </span><br><span class="line">    s := []shape&#123;&amp;r, &amp;c&#125; <span class="comment">//通过指针实现</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> _, sh := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Println(sh)</span><br><span class="line">        fmt.Println(sh.area())</span><br><span class="line">        fmt.Println(sh.perimeter())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="错误处理-Error接口"><a href="#错误处理-Error接口" class="headerlink" title="错误处理 - Error接口"></a>错误处理 - Error接口</h4><p>函数错误返回可能是C/C++时最让人纠结的东西的，Go的多值返回可以让我们更容易的返回错误，其可以在返回一个常规的返回值之外，还能轻易地返回一个详细的错误描述。通常情况下，错误的类型是error，它有一个内建的接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看一个错误处理的示例:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"errors"</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//自定义的出错结构</span></span><br><span class="line"><span class="keyword">type</span> myError <span class="keyword">struct</span> &#123;</span><br><span class="line">    arg  <span class="keyword">int</span></span><br><span class="line">    errMsg <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现Error接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *myError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%d - %s"</span>, e.arg, e.errMsg)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//两种出错</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">error_test</span><span class="params">(arg <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> arg &lt; <span class="number">0</span>  &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>, errors.New(<span class="string">"Bad Arguments - negtive!"</span>)</span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span> arg &gt;<span class="number">256</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, &amp;myError&#123;arg, <span class="string">"Bad Arguments - too large!"</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arg*arg, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//相关的测试</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, i := <span class="keyword">range</span> []<span class="keyword">int</span>&#123;<span class="number">-1</span>, <span class="number">4</span>, <span class="number">1000</span>&#125; &#123;</span><br><span class="line">        <span class="keyword">if</span> r, e := error_test(i); e != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"failed:"</span>, e)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"success:"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行后输出:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">failed: Bad Arguments - negtive!</span><br><span class="line">success: <span class="number">16</span></span><br><span class="line">failed: <span class="number">1000</span> - Bad Arguments - too large!</span><br></pre></td></tr></table></figure>

<h4 id="错误处理-Defer"><a href="#错误处理-Defer" class="headerlink" title="错误处理-Defer"></a>错误处理-Defer</h4><p>下面的程序对于每一个熟悉C语言的人来说都不陌生（有资源泄露的问题），C++使用RAII来解决这种问题。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyFile</span><span class="params">(dstName, srcName <span class="keyword">string</span>)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span> &#123;</span><br><span class="line">    src, err := os.Open(srcName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    dst, err := os.Create(dstName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    written, err = io.Copy(dst, src)</span><br><span class="line">    dst.Close()</span><br><span class="line">    src.Close()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go语言引入了Defer来确保那些被打开的文件能被关闭。如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyFile</span><span class="params">(dstName, srcName <span class="keyword">string</span>)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span> &#123;</span><br><span class="line">    src, err := os.Open(srcName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> src.Close()</span><br><span class="line"> </span><br><span class="line">    dst, err := os.Create(dstName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> dst.Close()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> io.Copy(dst, src)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go的defer语句预设一个函数调用（延期的函数），该调用在函数执行defer返回时立刻运行。该方法显得不同常规，但却是处理上述情况很有效，无论函数怎样返回，都必须进行资源释放。</p>
<p>来看一个defer函数的示例:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Printf(<span class="string">"%d "</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被延期的函数以后进先出（LIFO）的顺行执行，因此以上代码在返回时将打印4 3 2 1 0。</p>
<h4 id="错误处理-Panic-Recover"><a href="#错误处理-Panic-Recover" class="headerlink" title="错误处理-Panic/Recover"></a>错误处理-Panic/Recover</h4><p>对于不可恢复的错误，Go提供了一个内建的panic函数，它将创建一个运行时错误并使程序停止（相当暴力）。该函数接收一个任意类型（往往是字符串）作为程序死亡时要打印的东西。当编译器在函数的结尾处检查到一个panic时，就会停止进行常规的return语句检查。</p>
<p>下面的仅仅是一个示例。实际的库函数应避免panic。如果问题可以容忍，最好是让事情继续下去而不是终止整个程序。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = os.Getenv(<span class="string">"USER"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> user == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"no value for $USER"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当panic被调用时，它将立即停止当前函数的执行并开始逐级解开函数堆栈，同时运行所有被defer的函数。如果这种解开达到堆栈的顶端，程序就死亡了。但是，也可以使用内建的recover函数来重新获得Go程的控制权并恢复正常的执行。 对recover的调用会通知解开堆栈并返回传递到panic的参量。由于仅在解开期间运行的代码处在被defer的函数之内，recover仅在被延期的函数内部才是有用的。</p>
<p>你可以简单地理解为recover就是用来捕捉Painc的，防止程序一下子就挂掉了。</p>
<p>下面是一个很简单的例程:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i&gt;<span class="number">1</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Panic!"</span>)</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"%v"</span>, i))</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Recovered in f"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Calling g with "</span>, i)</span><br><span class="line">        g(i)</span><br><span class="line">        fmt.Println(<span class="string">"Returned normally from g."</span>)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f()</span><br><span class="line">    fmt.Println(<span class="string">"Returned normally from f."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：（我们可以看到Painc后的for循环就没有往下执行了，但是main的程序还在往下走）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Calling g with  <span class="number">0</span></span><br><span class="line">Returned normally from g.</span><br><span class="line">Calling g with  <span class="number">1</span></span><br><span class="line">Returned normally from g.</span><br><span class="line">Calling g with  <span class="number">2</span></span><br><span class="line">Panic!</span><br><span class="line">Recovered in f <span class="number">2</span></span><br><span class="line">Returned normally from f.</span><br></pre></td></tr></table></figure>

<p>参考自:</p>
<p>GO 语言简介（上）— 语法</p>
<p><a href="https://coolshell.cn/articles/8460.html" target="_blank" rel="noopener">https://coolshell.cn/articles/8460.html</a></p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux shell基础部分</title>
    <url>/Linux-shell%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<h4 id="编程基础"><a href="#编程基础" class="headerlink" title="编程基础"></a>编程基础</h4><p>程序:指令+数据 </p>
<p>程序编程风格: </p>
<p>​    过程式:以指令为中心,数据服务于指令 </p>
<p>​    对象式:以数据为中心,指令服务于数据 </p>
<p>shell程序:提供了编程能力,解释执行 </p>
<h4 id="程序的执行方式"><a href="#程序的执行方式" class="headerlink" title="程序的执行方式"></a>程序的执行方式</h4><p>编程逻辑处理方式: </p>
<p>​    顺序执行 </p>
<p>​    循环执行 </p>
<p>​    选择执行 </p>
<p>shell编程:过程式、解释执行 </p>
<p>​    编程语言的基本结构: </p>
<p>​        各种系统命令的组合 </p>
<p>​        数据存储:变量、数组 </p>
<p>​        表达式: a + b </p>
<p>​        语句:if  </p>
<h4 id="shell脚本基础"><a href="#shell脚本基础" class="headerlink" title="shell脚本基础"></a>shell脚本基础</h4><p>shell脚本: </p>
<p>​    包含一些命令或声明,并符合一定格式的文本文件 </p>
<p>格式要求:首行shebang机制 </p>
<p>​    #!/bin/bash </p>
<p>​    #!/usr/bin/python </p>
<p>​    #!/usr/bin/perl </p>
<p>shell脚本的用途有: </p>
<p>​     自动化常用命令 </p>
<p>​     执行系统管理和故障排除 </p>
<p>​     创建简单的应用程序 </p>
<p>​     处理文本或文件 </p>
<h4 id="创建shell脚本"><a href="#创建shell脚本" class="headerlink" title="创建shell脚本"></a>创建shell脚本</h4><p>第一步:使用文本编辑器来创建文本文件 </p>
<p>​    第一行必须包括shell声明序列:#! </p>
<p>​        #!/bin/bash </p>
<p>​    添加注释 </p>
<p>​        注释以#开头 </p>
<p>​    第二步:运行脚本 </p>
<p>​        给予执行权限,在命令行上指定脚本的绝对或相对路径 </p>
<p>​        直接运行解释器,将脚本作为解释器程序的参数运行 </p>
<h4 id="脚本规范"><a href="#脚本规范" class="headerlink" title="脚本规范"></a>脚本规范</h4><p>脚本代码开头约定 </p>
<p>​    1、第一行一般为调用使用的语言 </p>
<p>​    2、程序名,避免更改文件名为无法找到正确的文件 </p>
<p>​    3、版本号 </p>
<p>​    4、更改后的时间 </p>
<p>​    5、作者相关信息 </p>
<p>​    6、该程序的作用,及注意事项 </p>
<p>​    7、最后是各版本的更新简要说明</p>
<h4 id="脚本的基本结构"><a href="#脚本的基本结构" class="headerlink" title="脚本的基本结构"></a>脚本的基本结构</h4><p> #!SHEBANG </p>
<p>CONFIGURATION_VARIABLES </p>
<p>FUNCTION_DEFINITIONS </p>
<p>MAIN_CODE </p>
<h4 id="脚本调试"><a href="#脚本调试" class="headerlink" title="脚本调试"></a>脚本调试</h4><p>检测脚本中的语法错误 </p>
<p>​    bash -n /path/to/some_script </p>
<p>调试执行 </p>
<p>​    bash -x /path/to/some_script </p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>变量:命名的内存空间 </p>
<p>​    数据存储方式: </p>
<p>​        字符: </p>
<p>​        数值:整型,浮点型 </p>
<p>变量:变量类型 </p>
<p>​    作用: </p>
<p>​        1、数据存储格式 </p>
<p>​        2、参与的运算 </p>
<p>​        3、表示的数据范围 </p>
<p>​    类型: </p>
<p>​        字符 </p>
<p>​        数值:整型、浮点型 </p>
<p>强类型:变量不经过强制转换,它永远是这个数据类型,不允许隐式的类型转 换.一般定义变量时必须指定类型、参与运算必须符合类型要求;调用未声明 变量会产生错误 </p>
<p>​    如 java,c# </p>
<p>弱类型:语言的运行时会隐式做数据类型转换.无须指定类型,默认均为字符 型;参与运算会自动进行隐式类型转换;变量无须事先定义可直接调用 </p>
<p>​    如:bash 不支持浮点数,php </p>
<p>变量命名法则: </p>
<p>​    1、不能使程序中的保留字:例如if, for </p>
<p>​    2、只能使用数字、字母及下划线,且不能以数字开头 </p>
<p>​    3、见名知义 </p>
<p>​    4、统一命名规则:驼峰命名法 </p>
<h4 id="bash中变量的种类"><a href="#bash中变量的种类" class="headerlink" title="bash中变量的种类"></a>bash中变量的种类</h4><p>根据变量的生效范围等标准划分下面变量类型: </p>
<p>​    局部变量:生效范围为当前shell进程;对当前shell之外的其它shell进程,包括 当前shell的子shell进程均无效 </p>
<p>​    环境(全局)变量:生效范围为当前shell进程及其子进程 </p>
<p>​    本地变量:生效范围为当前shell进程中某代码片断,通常指函数 </p>
<p>​    位置变量:$1, $2, …来表示,用于让脚本在脚本代码中调用通过命令行传递给它 的参数 </p>
<p>​    特殊变量:$?, $0, $*, $@, $#,$$ </p>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>变量赋值:name=‘value’ </p>
<p>可以使用引用value: </p>
<p>​    (1) 可以是直接字串; name=“root” </p>
<p>​    (2) 变量引用:name=”$USER” </p>
<p>​    (3) 命令引用:name=`COMMAND` name=$(COMMAND) </p>
<p>变量引用:${name} $name</p>
<p>​     &quot;“:弱引用,其中的变量引用会被替换为变量值</p>
<p>​     &#39;‘:强引用,其中的变量引用不会被替换为变量值,而保持原字符串 </p>
<p>显示已定义的所有变量:set </p>
<p>删除变量:unset name </p>
<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>变量声明、赋值: </p>
<p>​    export name=VALUE </p>
<p>​    declare -x name=VALUE </p>
<p>变量引用:$name, ${name} </p>
<p>显示所有环境变量: </p>
<p>​    env </p>
<p>​    printenv </p>
<p>​    export </p>
<p>​    declare -x </p>
<p>删除变量: </p>
<p>​    unset name </p>
<p>bash内建的环境变量: </p>
<p>​    PATH </p>
<p>​    SHELL </p>
<p>​    USER </p>
<p>​    UID </p>
<p>​    HOME </p>
<p>​    PWD </p>
<p>​    SHLVL </p>
<p>​    LANG </p>
<p>​     MAIL </p>
<p>​    HOSTNAME </p>
<p>​    HISTSIZE </p>
<h4 id="只读和位置变量"><a href="#只读和位置变量" class="headerlink" title="只读和位置变量"></a>只读和位置变量</h4><p>只读变量:只能声明,但不能修改和删除 </p>
<p>​     声明只读变量: </p>
<p>​        readonly name </p>
<p>​        declare -r name </p>
<p>​     查看只读变量: </p>
<p>​        readonly –p </p>
<p> 位置变量:在脚本代码中调用通过命令行传递给脚本的参数 </p>
<p>​    $1, $2, …:对应第1、第2等参数,shift [n]换位置 </p>
<p>​    $0: 命令本身 </p>
<p>​    $*: 传递给脚本的所有参数,全部参数合为一个字符串 </p>
<p>​    $@: 传递给脚本的所有参数,每个参数为独立字符串 </p>
<p>​    $#: 传递给脚本的参数的个数 </p>
<p>​        $@ $* 只在被双引号包起来的时候才会有差异 </p>
<p>​    set – 清空所有位置变量 </p>
<h4 id="退出状态"><a href="#退出状态" class="headerlink" title="退出状态"></a>退出状态</h4><p>进程使用退出状态来报告成功或失败 </p>
<p>​    • 0 代表成功,1－255代表失败 </p>
<p>​    • $? 变量保存最近的命令退出状态 </p>
<p>例如: </p>
<p>​    ping -c1 -W1 hostdown &amp;&gt; /dev/null </p>
<p>​    echo $? </p>
<h4 id="退出状态码"><a href="#退出状态码" class="headerlink" title="退出状态码"></a>退出状态码</h4><p>bash自定义退出状态码 </p>
<p>​    exit [n]:自定义退出状态码 </p>
<p>注意:脚本中一旦遇到exit命令,脚本会立即终止;终止退出状态取决于exit命 令后面的数字                                                         注意:如果未给脚本指定退出状态码,整个脚本的退出状态码取决于脚本中执行 的最后一条命令的状态码 </p>
<h4 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h4><p>bash中的算术运算:help let </p>
<p>​    +, -, *, /, %取模(取余), **(乘方)</p>
<p>​    实现算术运算: </p>
<p>​    (1) let var=算术表达式 </p>
<p>​    (2) var=$[算术表达式] </p>
<p>​    (3) var=$((算术表达式)) </p>
<p>​    (4) var=$(expr arg1 arg2 arg3 …) </p>
<p>​    (5) declare –i var = 数值 </p>
<p>​    (6) echo ‘算术表达式’ | bc </p>
<p>乘法符号有些场景中需要转义,如* </p>
<p>bash有内建的随机数生成器:$RANDOM(0-32767) </p>
<p>​    echo $[$RANDOM%50] :0-49之间随机数 </p>
<h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>增强型赋值: </p>
<p>​    +=, -=, *=, /=, %= </p>
<p>let varOPERvalue </p>
<p>​    例如:let count+=3 自加3后自赋值 </p>
<p>自增,自减: </p>
<p>​    let var+=1 </p>
<p>​    let var++ let </p>
<p>​    var-=1 </p>
<p>​    let var– </p>
<h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><p>true, false </p>
<p>​    1, 0 </p>
<p>与(and): </p>
<p>​    1 与 1 = 1 </p>
<p>​    1 与 0 = 0 </p>
<p>​    0 与 1 = 0 </p>
<p>​    0 与 0 = 0 </p>
<p>或(or): </p>
<p>​    1 或 1 = 1 </p>
<p>​    1 或 0 = 1 </p>
<p>​    0 或 1 = 1 </p>
<p>​    0 或 0 = 0 </p>
<p>非(not):！ </p>
<p>​    ! 1 = 0 </p>
<p>​    ! 0 = 1 </p>
<p>短路运算 </p>
<p>​    短路与 </p>
<p>​    第一个为0,结果必定为0 </p>
<p>​    第一个为1,第二个必须要参与运算 </p>
<p>短路或 </p>
<p>​    第一个为1,结果必定为1 </p>
<p>​    第一个为0,第二个必须要参与运算 </p>
<p>异或:</p>
<p>​    ^ 异或的两个值,相同为假,不同为真 </p>
<h4 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h4><p>判断某需求是否满足,需要由测试机制来实现 </p>
<p>专用的测试表达式需要由测试命令辅助完成测试过程 </p>
<p>评估布尔声明,以便用在条件性执行中 </p>
<p>​    • 若真,则返回0 </p>
<p>​    • 若假,则返回1 </p>
<p>测试命令: </p>
<p>​    • test EXPRESSION </p>
<p>​    • [ EXPRESSION ] </p>
<p>​    • [[ EXPRESSION ]] </p>
<p>​    注意:EXPRESSION前后必须有空白字符 </p>
<h4 id="条件性的执行操作符"><a href="#条件性的执行操作符" class="headerlink" title="条件性的执行操作符"></a>条件性的执行操作符</h4><p>根据退出状态而定,命令可以有条件地运行 </p>
<p>​    • &amp;&amp; 代表条件性的AND THEN </p>
<p>​    • || 代表条件性的OR ELSE </p>
<p>例如:</p>
<p>grep -q no_such_user /etc/passwd \ </p>
<p>|| echo &#39;No such user&#39; </p>
<p>No such user </p>
<p>ping -c1 -W2 station1 &amp;&gt; /dev/null \ </p>
<p>&gt; &amp;&amp; echo “station1 is up&quot; \ </p>
<p>&gt; || (echo ‘station1 is unreachable’; exit 1) </p>
<p>station1 is up </p>
<h4 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a>test命令</h4><p>长格式的例子: </p>
<p>​    test “$A” = “$B” &amp;&amp; echo “Strings are equal” </p>
<p>​    test “$A”-eq “$B” &amp;&amp; echo “Integers are equal” </p>
<p> 简写格式的例子: </p>
<p>​    [ “$A” = “$B” ] &amp;&amp; echo “Strings are equal” </p>
<p>​    [ “$A” -eq “$B” ] &amp;&amp; echo “Integers are equal” </p>
<h4 id="bash的数值测试"><a href="#bash的数值测试" class="headerlink" title="bash的数值测试"></a>bash的数值测试</h4><p>-v VAR </p>
<p>​    变量VAR是否设置 </p>
<p>数值测试: </p>
<p>​    -gt 是否大于 </p>
<p>​    -ge 是否大于等于 </p>
<p>​    -eq 是否等于 </p>
<p>​    -ne 是否不等于 </p>
<p>​    -lt 是否小于 </p>
<p>​    -le 是否小于等于 </p>
<h4 id="bash-的字符串测试"><a href="#bash-的字符串测试" class="headerlink" title="bash 的字符串测试"></a>bash 的字符串测试</h4><p>字符串测试: </p>
<p>​    = 是否等于 </p>
<p>​    &gt; ascii码是否大于ascii码 </p>
<p>​    &lt; 是否小于 </p>
<p>​    != 是否不等于 </p>
<p>​    =~ 左侧字符串是否能够被右侧的PATTERN所匹配,注意: 此表达式一般用于[[ ]]中;扩展的正则表达式 </p>
<p>​    -z “STRING“ 字符串是否为空,空为真,不空为假 </p>
<p>​    -n “STRING“ 字符串是否不空,不空为真,空为假 </p>
<p> 注意:用于字符串比较时的用到的操作数都应该使用引号 </p>
<h4 id="bash的文件测试"><a href="#bash的文件测试" class="headerlink" title="bash的文件测试"></a>bash的文件测试</h4><p>存在性测试 </p>
<p>​    -a FILE:同-e </p>
<p>​    -e FILE: 文件存在性测试,存在为真,否则为假 </p>
<p>存在性及类别测试 </p>
<p>​    -b FILE:是否存在且为块设备文件 </p>
<p>​    -c FILE:是否存在且为字符设备文件 </p>
<p>​    -d FILE:是否存在且为目录文件 </p>
<p>​    -f FILE:是否存在且为普通文件 </p>
<p>​    -h FILE 或 -L FILE:存在且为符号链接文件 </p>
<p>​    -p FILE:是否存在且为命名管道文件 </p>
<p>​    -S FILE:是否存在且为套接字文件</p>
<h4 id="bash的文件权限测试"><a href="#bash的文件权限测试" class="headerlink" title="bash的文件权限测试"></a>bash的文件权限测试</h4><p>文件权限测试: </p>
<p>​    -r FILE:是否存在且可读 </p>
<p>​    -w FILE: 是否存在且可写 </p>
<p>​    -x FILE: 是否存在且可执行 </p>
<p>文件特殊权限测试: </p>
<p>​    -u FILE:是否存在且拥有suid权限 </p>
<p>​    -g FILE:是否存在且拥有sgid权限 </p>
<p>​    -k FILE:是否存在且拥有sticky权限 </p>
<h4 id="bash的文件属性测试"><a href="#bash的文件属性测试" class="headerlink" title="bash的文件属性测试"></a>bash的文件属性测试</h4><p>文件大小测试: </p>
<p>​    -s FILE: 是否存在且非空 </p>
<p>文件是否打开: </p>
<p>​    -t fd: fd 文件描述符是否在某终端已经打开 </p>
<p>​    -N FILE:文件自从上一次被读取之后是否被修改过 </p>
<p>​    -O FILE:当前有效用户是否为文件属主 </p>
<p>​    -G FILE:当前有效用户是否为文件属组</p>
<p>双目测试: </p>
<p>​    FILE1 -ef FILE2: FILE1是否是FILE2的硬链接 </p>
<p>​    FILE1 -nt FILE2: FILE1是否新于FILE2(mtime) </p>
<p>​    FILE1 -ot FILE2: FILE1是否旧于FILE2 </p>
<h4 id="bash的组合测试条件"><a href="#bash的组合测试条件" class="headerlink" title="bash的组合测试条件"></a>bash的组合测试条件</h4><p>第一种方式: </p>
<p>​    COMMAND1 &amp;&amp; COMMAND2 并且 </p>
<p>​    COMMAND1 || COMMAND2 或者 </p>
<p>​    ! COMMAND 非 </p>
<p>​    如:[[ -r FILE ]] &amp;&amp; [[ -w FILE ]] </p>
<p>第二种方式: </p>
<p>​    EXPRESSION1 -a EXPRESSION2 并且 </p>
<p>​    EXPRESSION1 -o EXPRESSION2 或者 </p>
<p>​    ! EXPRESSION </p>
<p>​    必须使用测试命令进行 </p>
<h4 id="使用read命令来接受输入"><a href="#使用read命令来接受输入" class="headerlink" title="使用read命令来接受输入"></a>使用read命令来接受输入</h4><p>使用read来把输入值分配给一个或多个shell变量 </p>
<p>​    -p 指定要显示的提示 </p>
<p>​    -s 静默输入,一般用于密码 </p>
<p>​    -n N 指定输入的字符长度N </p>
<p>​    -d ‘字符’ 输入结束符 </p>
<p>​    -t N TIMEOUT为N秒 </p>
<p>​    read 从标准输入中读取值,给每个单词分配一个变量 </p>
<p>​    所有剩余单词都被分配给最后一个变量 </p>
<p>​    read -p “Enter a filename: “ FILE </p>
<h4 id="bash展开命令行的顺序"><a href="#bash展开命令行的顺序" class="headerlink" title="bash展开命令行的顺序"></a>bash展开命令行的顺序</h4><p>把命令行分成单个命令词 </p>
<p>展开别名 </p>
<p>展开大括号的声明({}) </p>
<p>展开波浪符声明(~) </p>
<p>命令替换$() 和 (``) </p>
<p>再次把命令行分成命令词 </p>
<p>展开文件通配(* 、?、[abc]等等) </p>
<p>准备I/0重导向(&lt;、&gt;) </p>
<p>运行命令 </p>
<h4 id="防止扩展"><a href="#防止扩展" class="headerlink" title="防止扩展"></a>防止扩展</h4><p>反斜线()会使随后的字符按原意解释 </p>
<p>​    $ echo Your cost: \$5.00 </p>
<p>​    Your cost: $5.00 </p>
<p>加引号来防止扩展 </p>
<p>​    • 单引号(’)防止所有扩展 </p>
<p>​    • 双引号(”)也防止所有扩展,但是以下情况例外: </p>
<p>​        $(美元符号) － 变量扩展 </p>
<p>​        `(反引号) － 命令替换 </p>
<p>​        (反斜线) － 禁止单个字符扩展 </p>
<p>​        !(叹号) － 历史命令替换 </p>
<h4 id="bash的配置文件"><a href="#bash的配置文件" class="headerlink" title="bash的配置文件"></a>bash的配置文件</h4><p>按生效范围划分,存在两类: </p>
<p>全局配置: </p>
<p>​    /etc/profile </p>
<p>​    /etc/profile.d/*.sh </p>
<p>​    /etc/bashrc </p>
<p>个人配置: </p>
<p>​    ~/.bash_profile </p>
<p>​    ~/.bashrc </p>
<h4 id="Profile类"><a href="#Profile类" class="headerlink" title="Profile类"></a>Profile类</h4><p>按功能划分,存在两类: </p>
<p>​    profile类和bashrc类 </p>
<p>profile类:为交互式登录的shell提供配置 </p>
<p>​    全局:/etc/profile, /etc/profile.d/*.sh </p>
<p>​    个人:~/.bash_profile </p>
<p>​    功用: </p>
<p>​    (1) 用于定义环境变量 </p>
<p>​    (2) 运行命令或脚本 </p>
<h4 id="bashrc类"><a href="#bashrc类" class="headerlink" title="bashrc类"></a>bashrc类</h4><p>bashrc类:为非交互式和交互式登录的shell提供配置 </p>
<p>​    全局:/etc/bashrc </p>
<p>​    个人:~/.bashrc </p>
<p>​    功用: </p>
<p>​    (1) 定义命令别名和函数 </p>
<p>​    (2) 定义本地变量 </p>
<h4 id="编辑配置文件生效"><a href="#编辑配置文件生效" class="headerlink" title="编辑配置文件生效"></a>编辑配置文件生效</h4><p>修改profile和bashrc文件后需生效 </p>
<p>​    两种方法: </p>
<p>​    1重新启动shell进程 </p>
<p>​    2 . 或source </p>
<p>​    例: </p>
<p>​    . ~/.bashrc </p>
<h4 id="bash退出任务"><a href="#bash退出任务" class="headerlink" title="bash退出任务"></a>bash退出任务</h4><p>保存在~/.bash_logout文件中(用户) </p>
<p>在退出登录shell时运行 </p>
<p>用于 </p>
<p>​    • 创建自动备份 </p>
<p>​    • 清除临时文件 </p>
<h4 id="变量-1"><a href="#变量-1" class="headerlink" title="$-变量"></a>$-变量</h4><p>h:hashall,打开这个选项后,Shell 会将命令所在的路径hash下来,避免每次 都要查询.通过set +h将h选项关闭 </p>
<p>i:interactive-comments,包含这个选项说明当前的 shell 是一个交互式的 shell.所谓的交互式shell,在脚本中,i选项是关闭的. </p>
<p>m:monitor,打开监控模式,就可以通过Job control来控制进程的停止、继 续,后台或者前台执行等. </p>
<p>B:braceexpand,大括号扩展 </p>
<p>H:history,H选项打开,可以展开历史列表中的命令,可以通过!感叹号来完 成,例如“!!”返回上最近的一个历史命令,“!n”返回第 n 个历史命令 </p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言简介(四)</title>
    <url>/Go-%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B-%E5%9B%9B/</url>
    <content><![CDATA[<h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p>Go语言中可以使用time.NewTimer或time.NewTicker来设置一个定时器，这个定时器会绑定在你的当前channel中，通过channel的阻塞通知机器来通知你的程序。</p>
<p>下面是一个timer的示例。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    timer := time.NewTimer(<span class="number">2</span>*time.Second)</span><br><span class="line"> </span><br><span class="line">    &lt;- timer.C</span><br><span class="line">    fmt.Println(<span class="string">"timer expired!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例程看起来像一个Sleep，是的，不过Timer是可以Stop的。你需要注意Timer只通知一次。如果你要像C中的Timer能持续通知的话，你需要使用Ticker。下面是Ticker的例程：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ticker := time.NewTicker(time.Second)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> t := <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Tick at"</span>, t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的这个ticker会让你程序进入死循环，我们应该放其放在一个goroutine中。下面这个程序结合了timer和ticker</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> </span><br><span class="line">    ticker := time.NewTicker(time.Second)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> t := <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">            fmt.Println(t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//设置一个timer，10钞后停掉ticker</span></span><br><span class="line">    timer := time.NewTimer(<span class="number">10</span>*time.Second)</span><br><span class="line">    &lt;- timer.C</span><br><span class="line"> </span><br><span class="line">    ticker.Stop()</span><br><span class="line">    fmt.Println(<span class="string">"timer expired!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h4><p>下面是我尝试的一个Echo Server的Socket代码，感觉还是挺简单的。</p>
<p>SERVER端</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> RECV_BUF_LEN = <span class="number">1024</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"0.0.0.0:6666"</span>)<span class="comment">//侦听在6666端口</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"error listening:"</span>+err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"Starting the server"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := listener.Accept() <span class="comment">//接受连接</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">"Error accept:"</span>+err.Error())</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">"Accepted the Connection :"</span>, conn.RemoteAddr())</span><br><span class="line">        <span class="keyword">go</span> EchoServer(conn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EchoServer</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, RECV_BUF_LEN)</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        n, err := conn.Read(buf);</span><br><span class="line">        <span class="keyword">switch</span> err &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">                conn.Write( buf[<span class="number">0</span>:n] )</span><br><span class="line">            <span class="keyword">case</span> io.EOF:</span><br><span class="line">                fmt.Printf(<span class="string">"Warning: End of data: %s \n"</span>, err);</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                fmt.Printf(<span class="string">"Error: Reading data : %s \n"</span>, err);</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CLIENT端</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> RECV_BUF_LEN = <span class="number">1024</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    conn,err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:6666"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line"> </span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, RECV_BUF_LEN)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="comment">//准备要发送的字符串</span></span><br><span class="line">        msg := fmt.Sprintf(<span class="string">"Hello World, %03d"</span>, i)</span><br><span class="line">        n, err := conn.Write([]<span class="keyword">byte</span>(msg))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">"Write Buffer Error:"</span>, err.Error())</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(msg)</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//从服务器端收字符串</span></span><br><span class="line">        n, err = conn.Read(buf)</span><br><span class="line">        <span class="keyword">if</span> err !=<span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">"Read Buffer Error:"</span>, err.Error())</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="keyword">string</span>(buf[<span class="number">0</span>:n]))</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//等一秒钟</span></span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>Go语言那么C，所以，一定会有一些系统调用。Go语言主要是通过两个包完成的。一个是<a href="http://golang.org/pkg/os/" target="_blank" rel="noopener">os包</a>，一个是<a href="http://golang.org/pkg/syscall/" target="_blank" rel="noopener">syscall包</a>。（注意，链接被墙）</p>
<p>这两个包里提供都是Unix-Like的系统调用，</p>
<ul>
<li>syscall里提供了什么Chroot/Chmod/Chmod/Chdir…，Getenv/Getgid/Getpid/Getgroups/Getpid/Getppid…，还有很多如Inotify/Ptrace/Epoll/Socket/…的系统调用。</li>
<li>os包里提供的东西不多，主要是一个跨平台的调用。它有三个子包，Exec（运行别的命令）, Signal（捕捉信号）和User（通过uid查name之类的）</li>
</ul>
<p>syscall包的东西我不举例了，大家可以看看《Unix高级环境编程》一书。</p>
<p>os里的取几个例：</p>
<p><strong>环境变量</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">"os"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"strings"</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    os.Setenv(<span class="string">"WEB"</span>, <span class="string">"https://coolshell.cn"</span>) <span class="comment">//设置环境变量</span></span><br><span class="line">    <span class="built_in">println</span>(os.Getenv(<span class="string">"WEB"</span>)) <span class="comment">//读出来</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> _, env := <span class="keyword">range</span> os.Environ() &#123; <span class="comment">//穷举环境变量</span></span><br><span class="line">        e := strings.Split(env, <span class="string">"="</span>)</span><br><span class="line">        <span class="built_in">println</span>(e[<span class="number">0</span>], <span class="string">"="</span>, e[<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="执行命令行"><a href="#执行命令行" class="headerlink" title="执行命令行"></a>执行命令行</h4><p>下面是一个比较简单的示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"os/exec"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cmd := exec.Command(<span class="string">"ping"</span>, <span class="string">"127.0.0.1"</span>)</span><br><span class="line">    out, err := cmd.Output()</span><br><span class="line">    <span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"Command Error!"</span>, err.Error())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(out))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正规一点的用来处理标准输入和输出的示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os/exec"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cmd := exec.Command(<span class="string">"tr"</span>, <span class="string">"a-z"</span>, <span class="string">"A-Z"</span>)</span><br><span class="line">    cmd.Stdin = strings.NewReader(<span class="string">"some input"</span>)</span><br><span class="line">    <span class="keyword">var</span> out bytes.Buffer</span><br><span class="line">    cmd.Stdout = &amp;out</span><br><span class="line">    err := cmd.Run()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"in all caps: %q\n"</span>, out.String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h4><p>Go语言中处理命令行参数很简单：(使用os的Args就可以了)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    args := os.Args</span><br><span class="line">    fmt.Println(args) <span class="comment">//带执行文件的</span></span><br><span class="line">    fmt.Println(args[<span class="number">1</span>:]) <span class="comment">//不带执行文件的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Windows下，如果运行结果如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C:\Projects\Go&gt;go run args.go aaa bbb ccc ddd[<span class="type">C</span>:\<span class="type">Users</span>\<span class="type">haoel</span>\<span class="type">AppData</span>\<span class="type">Local</span>\<span class="type">Temp</span>\<span class="type">go</span>-<span class="type">build742679827</span>\<span class="type">command</span>-<span class="type">line</span>-<span class="type">arguments</span>\<span class="type">_obj</span>\<span class="type">a.out.exe</span> <span class="type">aaa</span> <span class="type">bbb</span> <span class="type">ccc</span> <span class="type">ddd</span>]</span><br><span class="line">[<span class="type">aaa</span> <span class="type">bbb</span> <span class="type">ccc</span> <span class="type">ddd</span>]</span><br></pre></td></tr></table></figure>

<p>那么，如果我们要搞出一些像 mysql -uRoot -hLocalhost -pPwd 或是像 cc -O3 -Wall -o a a.c 这样的命令行参数我们怎么办？Go提供了一个package叫flag可以容易地做到这一点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"flag"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//第一个参数是“参数名”，第二个是“默认值”，第三个是“说明”。返回的是指针</span></span><br><span class="line">    host := flag.String(<span class="string">"host"</span>, <span class="string">"coolshell.cn"</span>, <span class="string">"a host name "</span>)</span><br><span class="line">    port := flag.Int(<span class="string">"port"</span>, <span class="number">80</span>, <span class="string">"a port number"</span>)</span><br><span class="line">    debug := flag.Bool(<span class="string">"d"</span>, <span class="literal">false</span>, <span class="string">"enable/disable debug mode"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//正式开始Parse命令行参数</span></span><br><span class="line">    flag.Parse()</span><br><span class="line"> </span><br><span class="line">    fmt.Println(<span class="string">"host:"</span>, *host)</span><br><span class="line">    fmt.Println(<span class="string">"port:"</span>, *port)</span><br><span class="line">    fmt.Println(<span class="string">"debug:"</span>, *debug)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行起来会是这个样子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">#如果没有指定参数名，则使用默认值</span><br><span class="line">$ <span class="keyword">go</span> run flagtest.<span class="keyword">go</span></span><br><span class="line">host: coolshell.cn</span><br><span class="line">port: <span class="number">80</span></span><br><span class="line">debug: <span class="literal">false</span></span><br><span class="line"> </span><br><span class="line">#指定了参数名后的情况</span><br><span class="line">$ <span class="keyword">go</span> run flagtest.<span class="keyword">go</span> -host=localhost -port=<span class="number">22</span> -d</span><br><span class="line">host: localhost</span><br><span class="line">port: <span class="number">22</span></span><br><span class="line">debug: <span class="literal">true</span></span><br><span class="line"> </span><br><span class="line">#用法出错了（如：使用了不支持的参数，参数没有=）</span><br><span class="line">$ <span class="keyword">go</span> build flagtest.<span class="keyword">go</span></span><br><span class="line">$ ./flagtest -debug -host localhost -port=<span class="number">22</span></span><br><span class="line">flag provided but not defined: -debug</span><br><span class="line">Usage of flagtest:</span><br><span class="line">  -d=<span class="literal">false</span>: enable/disable debug mode</span><br><span class="line">  -host=<span class="string">"coolshell.cn"</span>: a host name</span><br><span class="line">  -port=<span class="number">80</span>: a port number</span><br><span class="line">exit status <span class="number">2</span></span><br></pre></td></tr></table></figure>



<h4 id="一个简单的HTTP-Server"><a href="#一个简单的HTTP-Server" class="headerlink" title="一个简单的HTTP Server"></a>一个简单的HTTP Server</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"path/filepath"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> http_root = <span class="string">"/home/haoel/coolshell.cn/"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, rootHandler)</span><br><span class="line">    http.HandleFunc(<span class="string">"/view/"</span>, viewHandler)</span><br><span class="line">    http.HandleFunc(<span class="string">"/html/"</span>, htmlHandler)</span><br><span class="line"> </span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//读取一些HTTP的头</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rootHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"rootHandler: %s\n"</span>, r.URL.Path)</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"URL: %s\n"</span>, r.URL)</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Method: %s\n"</span>, r.Method)</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"RequestURI: %s\n"</span>, r.RequestURI )</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Proto: %s\n"</span>, r.Proto)</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"HOST: %s\n"</span>, r.Host) </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//特别的URL处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">viewHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"viewHandler: %s"</span>, r.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//一个静态网页的服务示例。（在http_root的html目录下）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">htmlHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"htmlHandler: %s\n"</span>, r.URL.Path)</span><br><span class="line">     </span><br><span class="line">    filename := http_root + r.URL.Path</span><br><span class="line">    fileext := filepath.Ext(filename)</span><br><span class="line"> </span><br><span class="line">    content, err := ioutil.ReadFile(filename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"   404 Not Found!\n"</span>)</span><br><span class="line">        w.WriteHeader(http.StatusNotFound)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> contype <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">switch</span> fileext &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">".html"</span>, <span class="string">"htm"</span>:</span><br><span class="line">            contype = <span class="string">"text/html"</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">".css"</span>:</span><br><span class="line">            contype = <span class="string">"text/css"</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">".js"</span>:</span><br><span class="line">            contype = <span class="string">"application/javascript"</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">".png"</span>:</span><br><span class="line">            contype = <span class="string">"image/png"</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">".jpg"</span>, <span class="string">".jpeg"</span>:</span><br><span class="line">            contype = <span class="string">"image/jpeg"</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">".gif"</span>:</span><br><span class="line">            contype = <span class="string">"image/gif"</span></span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">            contype = <span class="string">"text/plain"</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"ext %s, ct = %s\n"</span>, fileext, contype)</span><br><span class="line">     </span><br><span class="line">    w.Header().Set(<span class="string">"Content-Type"</span>, contype)</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"%s"</span>, content)</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go的功能库有很多，大家自己慢慢看吧。</p>
<p>参考自:</p>
<p>GO 语言简介（下）— 特性</p>
<p><a href="https://coolshell.cn/articles/8489.html" target="_blank" rel="noopener">https://coolshell.cn/articles/8489.html</a></p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux shell 脚本编程进阶(一)</title>
    <url>/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6-%E4%B8%80/</url>
    <content><![CDATA[<p>Shell 脚本也是学习Linux中必须要掌握的基础之一,掌握了 Shell 脚本之后可以轻松控制自动化及重复的任务,大大减少重复的劳动.</p>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>过程式编程语言: </p>
<pre><code>顺序执行 </code></pre><p>​    选择执行 </p>
<pre><code>循环执行 </code></pre><h4 id="条件选择-if-语句"><a href="#条件选择-if-语句" class="headerlink" title="条件选择 if 语句"></a>条件选择 if 语句</h4><p>选择执行: </p>
<p>注意:if语句可嵌套 </p>
<p>单分支 </p>
<pre><code>if 判断条件;then 

    条件为真的分支代码 

fi </code></pre><p>双分支 </p>
<pre><code>if 判断条件; then 

    条件为真的分支代码 

else 

    条件为假的分支代码 

fi </code></pre><h5 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h5><p>多分支 </p>
<pre><code>if 判断条件1; then 

    条件1为真的分支代码 

elif 判断条件2; then 

    条件2为真的分支代码 </code></pre><p>​    elif 判断条件3; then </p>
<pre><code>    条件3为真的分支代码 

else 

    以上条件都为假的分支代码 

fi </code></pre><p>逐条件进行判断,第一次遇为“真”条件时,执行其分支,而后结束整个if语句 </p>
<h5 id="if示例"><a href="#if示例" class="headerlink" title="if示例"></a>if示例</h5><p>根据命令的退出状态来执行命令 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if ping -c1 -W2 station1 &amp;&gt; /dev/null; then </span><br><span class="line"></span><br><span class="line">	echo 'Station1 is UP' </span><br><span class="line"></span><br><span class="line">elif grep "station1" ~/maintenance.txt &amp;&gt; /dev/null; then </span><br><span class="line"></span><br><span class="line">	echo 'Station1 is undergoing maintenance‘ </span><br><span class="line"></span><br><span class="line">else </span><br><span class="line"></span><br><span class="line">	echo 'Station1 is unexpectedly DOWN!' </span><br><span class="line"></span><br><span class="line">	exit 1 </span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h4 id="条件判断-case-语句"><a href="#条件判断-case-语句" class="headerlink" title="条件判断 case 语句"></a>条件判断 case 语句</h4><p>case 变量引用 in </p>
<p>PAT1) </p>
<pre><code>分支1 

;; </code></pre><p>PAT2) </p>
<pre><code>分支2 

;; </code></pre><p>… </p>
<p>*) </p>
<pre><code>默认分支 

;; </code></pre><p>esac </p>
<p>case支持glob风格的通配符: </p>
<pre><code>*: 任意长度任意字符 </code></pre><p>​    ?: 任意单个字符 </p>
<pre><code>[]:指定范围内的任意单个字符 

a|b: a或b </code></pre><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>循环执行 </p>
<pre><code>将某代码段重复运行多次 

重复运行多少次 

    循环次数事先已知 

    循环次数事先未知 

有进入条件和退出条件 </code></pre><p>for, while, until </p>
<h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><p>for 变量名 in 列表;do </p>
<pre><code>循环体 </code></pre><p>done </p>
<p>执行机制: </p>
<pre><code>依次将列表中的元素赋值给“变量名”; 每次赋值后即执行一次循环体; 直 到列表中的元素耗尽,循环结束 </code></pre><p>列表生成方式: </p>
<pre><code>(1) 直接给出列表 

(2) 整数列表: 

    (a) {start..end} 

    (b) $(seq [start [step]] end) 

(3) 返回列表的命令 

    $(COMMAND) 

(4) 使用glob,如:*.sh</code></pre><p>​    (5) 变量引用; </p>
<p>​        $@, $* </p>
<h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><p>while CONDITION; do<br>​    循环体<br>done<br>CONDITION:循环控制条件;进入循环之前,先做一次判断;每一次循环之后会再次做判断;条件为“true”,则执行一次循环;直到条件测试状态为“false”终止循环<br>因此:CONDTION一般应该有循环控制变量;而此变量的值会在循环体不断地被修正<br>进入条件:CONDITION为true<br>退出条件:CONDITION为false</p>
<h5 id="until循环"><a href="#until循环" class="headerlink" title="until循环"></a>until循环</h5><p>until CONDITION; do<br>​    循环体<br>done<br>进入条件: CONDITION 为false<br>退出条件: CONDITION 为true</p>
<h5 id="循环控制语句continue"><a href="#循环控制语句continue" class="headerlink" title="循环控制语句continue"></a>循环控制语句continue</h5><p>用于循环体中<br>continue [N]:提前结束第N层的本轮循环,而直接进入下一轮判断;最内层为第1层</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while CONDTIITON1; do</span><br><span class="line">	CMD1</span><br><span class="line">	...</span><br><span class="line">	if CONDITION2; then</span><br><span class="line">		continue</span><br><span class="line">	fi</span><br><span class="line">	CMDn</span><br><span class="line">	...</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<h5 id="循环控制语句break"><a href="#循环控制语句break" class="headerlink" title="循环控制语句break"></a>循环控制语句break</h5><p>用于循环体中<br>break [N]:提前结束第N层循环,最内层为第1层</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while CONDTIITON1; do</span><br><span class="line">	CMD1</span><br><span class="line">	...</span><br><span class="line">	if CONDITION2; then</span><br><span class="line">		break</span><br><span class="line">	fi</span><br><span class="line">	CMDn</span><br><span class="line">	...</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<h5 id="循环控制shift命令"><a href="#循环控制shift命令" class="headerlink" title="循环控制shift命令"></a>循环控制shift命令</h5><p>shift [n]<br>用于将参量列表 list 左移指定次数,缺省为左移一次.<br>参量列表 list 一旦被移动,最左端的那个参数就从列表中删除.while 循环遍<br>历位置参量列表时,常用到 shift<br><code>./doit.sh a b c d e f g h</code></p>
<p><code>./shfit.sh a b c d e f g h</code></p>
<h5 id="命令示例"><a href="#命令示例" class="headerlink" title="命令示例"></a>命令示例</h5><p><strong>doit.sh</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Name: doit.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Purpose: <span class="built_in">shift</span> through <span class="built_in">command</span> line arguments</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Usage: doit.sh [args]</span></span><br><span class="line">while [ $# -gt 0 ] # or (( $# &gt; 0 ))</span><br><span class="line">do</span><br><span class="line">	echo $*</span><br><span class="line">	shift</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p><strong>shift.sh</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">step through all the positional parameters</span></span><br><span class="line">until [ -z "$1" ]</span><br><span class="line">do</span><br><span class="line"> 	echo "$1"</span><br><span class="line"> 	shift</span><br><span class="line">done</span><br><span class="line">echo</span><br></pre></td></tr></table></figure>

<h5 id="创建无限循环"><a href="#创建无限循环" class="headerlink" title="创建无限循环"></a>创建无限循环</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while true; do</span><br><span class="line">	循环体</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">until false; do</span><br><span class="line">	循环体</span><br><span class="line">Done</span><br></pre></td></tr></table></figure>



<h5 id="循环的特殊用法"><a href="#循环的特殊用法" class="headerlink" title="循环的特殊用法"></a>循环的特殊用法</h5><p>while循环的特殊用法（遍历文件的每一行）:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while read line; do</span><br><span class="line">	循环体</span><br><span class="line">done &lt; /PATH/FROM/SOMEFILE</span><br></pre></td></tr></table></figure>


<p>依次读取/PATH/FROM/SOMEFILE文件中的每一行,且将行赋值给变量line</p>
<p><strong>双小括号方法</strong>,即<code>((…))</code>格式,也可以用于算术运算<br>双小括号方法也可以使bash Shell实现C语言风格的变量操作<br>​    <code>I=10</code><br>​    <code>((I++))</code></p>
<p><strong>for循环的特殊格式:</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for ((控制变量初始化;条件判断表达式;控制变量的修正表达式))</span><br><span class="line">do	</span><br><span class="line">	循环体</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>控制变量初始化:仅在运行到循环代码段时执行一次<br>控制变量的修正表达式:每轮循环结束会先进行控制变量修正运算,而后再做条件判断</p>
<h5 id="select循环与菜单"><a href="#select循环与菜单" class="headerlink" title="select循环与菜单"></a>select循环与菜单</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">select variable in list</span><br><span class="line">	do</span><br><span class="line">		循环体命令</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>

<p>select 循环主要用于创建菜单,按数字顺序排列的菜单项将显示在<br>标准错误上,并显示 PS3 提示符,等待用户输入<br> 用户输入菜单列表中的某个数字,执行相应的命令<br> 用户输入被保存在内置变量 REPLY 中</p>
<h5 id="select与case"><a href="#select与case" class="headerlink" title="select与case"></a>select与case</h5><p>select 是个无限循环,因此要记住用 break 命令退出循环,或用<br>exit 命令终止脚本.也可以按 ctrl+c 退出循环<br>select 经常和 case 联合使用<br>与 for 循环类似,可以省略 in list,此时使用位置参量</p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux shell 脚本编程进阶(二)</title>
    <url>/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6-%E4%BA%8C/</url>
    <content><![CDATA[<h3 id="shell中的函数"><a href="#shell中的函数" class="headerlink" title="shell中的函数"></a>shell中的函数</h3><p>函数function是由若干条shell命令组成的语句块,实现代码重用和模块化编程<br>它与shell程序形式上是相似的,不同的是它不是一个单独的进程,不能独立运行,而是shell程序的一部分<br> 函数和shell程序比较相似,区别在于:<br>​    <strong>Shell程序在子Shell中运行</strong><br>​    <strong>而Shell函数在当前Shell中运行.因此在当前Shell中,函数可以对shell中变量进行修改</strong></p>
<h4 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h4><p> 函数由两部分组成:函数名和函数体<br><code>help function</code><br> 语法一:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">f_name （）&#123;</span><br><span class="line">	...函数体...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 语法二:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function f_name &#123;</span><br><span class="line">	...函数体...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 语法三:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function f_name （） &#123;</span><br><span class="line">	...函数体...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="函数使用"><a href="#函数使用" class="headerlink" title="函数使用"></a>函数使用</h4><p>函数的定义和使用:<br>​    可在交互式环境下定义函数<br>​    可将函数放在脚本文件中作为它的一部分<br>​    可放在只包含函数的单独文件中<br>调用:函数只有被调用才会执行<br>​    调用:给定函数名<br>​    函数名出现的地方,会被自动替换为函数代码<br>函数的生命周期:被调用时创建,返回时终止</p>
<h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><p>函数有两种返回值:<br>函数的执行结果返回值:<br>​    (1) 使用echo等命令进行输出<br>​    (2) 函数体中调用命令的输出结果<br>函数的退出状态码:<br>​    (1) 默认取决于函数中执行的最后一条命令的退出状态码<br>​    (2) 自定义退出状态码,其格式为:<br>​    return 从函数中返回,用最后状态命令决定返回值<br>​    return 0 无错误返回.<br>​    return 1-255 有错误返回</p>
<h4 id="交互式环境下定义和使用函数"><a href="#交互式环境下定义和使用函数" class="headerlink" title="交互式环境下定义和使用函数"></a>交互式环境下定义和使用函数</h4><p>示例:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dir() &#123;</span><br><span class="line"><span class="meta"> &gt;</span><span class="bash"> ls -l</span></span><br><span class="line"><span class="meta"> &gt;</span><span class="bash"> &#125;</span></span><br></pre></td></tr></table></figure>

<p>定义该函数后,若在$后面键入dir,其显示结果同ls -l的作用相同<br><code>$ dir</code></p>
<p>该dir函数将一直保留到用户从系统退出,或执行了如下所示的unset命令<br><code>unset dir</code></p>
<h4 id="在脚本中定义及使用函数"><a href="#在脚本中定义及使用函数" class="headerlink" title="在脚本中定义及使用函数"></a>在脚本中定义及使用函数</h4><p>函数在使用前必须定义,因此应将函数定义放在脚本开始部分,直至shell首次发现它<br>后才能使用<br>调用函数仅使用其函数名即可<br>示例:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat func1</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> func1</span></span><br><span class="line">hello()</span><br><span class="line">&#123;</span><br><span class="line">	echo "Hello there today's date is `date +%F`"</span><br><span class="line">&#125;</span><br><span class="line">echo "now going to the function hello"</span><br><span class="line">hello</span><br><span class="line">echo “back from the function”</span><br></pre></td></tr></table></figure>



<h4 id="使用函数文件"><a href="#使用函数文件" class="headerlink" title="使用函数文件"></a>使用函数文件</h4><p>可以将经常使用的函数存入函数文件,然后将函数文件载入shell<br>文件名可任意选取,但最好与相关任务有某种联系.例如:functions.main<br>一旦函数文件载入shell,就可以在命令行或脚本中调用函数.可以使用set命<br>令查看所有定义的函数,其输出列表包括已经载入shell的所有函数<br>若要改动函数,首先用unset命令从shell中删除函数.改动完毕后,再重新载<br>入此文件</p>
<h4 id="创建函数文件"><a href="#创建函数文件" class="headerlink" title="创建函数文件"></a>创建函数文件</h4><p>函数文件示例:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat functions.main</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">functions.main</span></span><br><span class="line">findit()</span><br><span class="line">&#123;</span><br><span class="line"> 	if [ $# -lt 1 ] ; then</span><br><span class="line"> 		echo "Usage:findit file"</span><br><span class="line"> 		return 1</span><br><span class="line"> 	fi</span><br><span class="line"> 	find / -name $1 –print</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="载入函数"><a href="#载入函数" class="headerlink" title="载入函数"></a>载入函数</h4><p>函数文件已创建好后,要将它载入shell<br>定位函数文件并载入shell的格式<br>​    <code>. filename</code> 或 <code>source filename</code><br>注意:此即&lt;点&gt; &lt;空格&gt; &lt;文件名&gt;这里的文件名要带正确路径<br>示例:<br>​    上例中的函数,可使用如下命令:<br>​    <code>. functions.main</code>    </p>
<h4 id="检查载入函数"><a href="#检查载入函数" class="headerlink" title="检查载入函数"></a>检查载入函数</h4><p>使用set命令检查函数是否已载入.set命令将在shell中显示所有的载入函数<br>示例:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set</span><br><span class="line"> findit=( )</span><br><span class="line"> &#123;</span><br><span class="line"> 	if [ $# -lt 1 ]; then</span><br><span class="line"> 	echo "usage :findit file";</span><br><span class="line"> 	return 1</span><br><span class="line"> 	fi</span><br><span class="line"> 	find / -name $1 -print</span><br><span class="line"> &#125;</span><br><span class="line"> …</span><br></pre></td></tr></table></figure>



<h4 id="执行shell函数"><a href="#执行shell函数" class="headerlink" title="执行shell函数"></a>执行shell函数</h4><p>要执行函数,简单地键入函数名即可<br>示例:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">findit groups</span><br><span class="line">/usr/bin/groups</span><br><span class="line">/usr/local/backups/groups.bak</span><br></pre></td></tr></table></figure>



<h4 id="删除shell函数"><a href="#删除shell函数" class="headerlink" title="删除shell函数"></a>删除shell函数</h4><p>现在对函数做一些改动后,需要先删除函数,使其对shell不可用.使用unset命<br>令完成删除函数<br>命令格式为:<br>​    <code>unset function_name</code><br>示例:<br>​    <code>unset findit</code><br>​    再键入set命令,函数将不再显示<br>环境函数<br>使子进程也可使用<br>声明:export -f function_name<br>查看:export -f 或 declare -xf</p>
<h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><p>函数可以接受参数:<br>​    传递参数给函数:调用函数时,在函数名后面以空白分隔给定参数列表即可;例如“testfunc arg1 arg2 …”<br>​    在函数体中当中,可使用$1, $2, …调用这些参数;还可以使用$@, $*, $#等特殊变量</p>
<h4 id="函数变量"><a href="#函数变量" class="headerlink" title="函数变量"></a>函数变量</h4><p>变量作用域:<br>​    环境变量:当前shell和子shell有效<br>​    本地变量:只在当前shell进程有效,为执行脚本会启动专用子shell进程;因此,本地变量的作用范围是当前shell脚本程序文件,包括脚本中的函数<br>​    局部变量:函数的生命周期;函数结束时变量被自动销毁<br>注意:如果函数中有局部变量,如果其名称同本地变量,使用局部变量<br>在函数中定义局部变量的方法<br>​    <code>local NAME=VALUE</code></p>
<h4 id="函数递归示例"><a href="#函数递归示例" class="headerlink" title="函数递归示例"></a>函数递归示例</h4><p>函数递归:<br>​    函数直接或间接调用自身<br>​    注意递归层数<br>递归实例:<br>阶乘是基斯顿·卡曼于 1808 年发明的运算符号,是数学术语<br>一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积,并且有0的阶乘为1,自然数n的阶乘写作n!<br>​    n!=1×2×3×…×n<br>​    阶乘亦可以递归方式定义:0!=1,n!=(n-1)!×n<br>​    n!=n(n-1)(n-2)…1<br>​    n(n-1)! = n(n-1)(n-2)!</p>
<p>例程:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">fact() &#123;</span><br><span class="line">	if [ $1 -eq 0 -o $1 -eq 1 ]; then</span><br><span class="line">		echo 1</span><br><span class="line">	else</span><br><span class="line">		echo $[$1*$(fact $[$1-1])]</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line">fact $1</span><br></pre></td></tr></table></figure>



<h4 id="fork炸弹"><a href="#fork炸弹" class="headerlink" title="fork炸弹"></a>fork炸弹</h4><p>fork炸弹是一种恶意程序,它的内部是一个不断在fork进程的无限循环,实质是一个简单的递归程序.由于程序是递归的,如果没有任何限制,这会导致这个简单的程序迅速耗尽系统里面的所有资源<br>函数实现<br><code>:(){ :|:&amp; };:</code></p>
<p><code>bomb() { bomb | bomb &amp; }; bomb</code></p>
<p>脚本实现</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat Bomb.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">./$0|./$0&amp;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 中的进程和计划任务(三)</title>
    <url>/Linux-%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1-%E4%B8%89/</url>
    <content><![CDATA[<h2 id="Linux-中进程的管理"><a href="#Linux-中进程的管理" class="headerlink" title="Linux 中进程的管理"></a>Linux 中进程的管理</h2><h3 id="进程管理工具-kill"><a href="#进程管理工具-kill" class="headerlink" title="进程管理工具 kill"></a>进程管理工具 kill</h3><p><strong>kill命令:</strong> </p>
<pre><code>向进程发送控制信号,以实现对进程管理,每个信号对应一个数字,信号名称以SIG开头 (可省略),不区分大小写 

显示当前系统可用信号: kill –l,trap -l </code></pre><p>​    常用信号:man 7 signal </p>
<p>​    1) SIGHUP: 无须关闭进程而让其重读配置文件 </p>
<p>​    2) SIGINT: 中止正在运行的进程;相当于Ctrl+c </p>
<p>​    3) SIGQUIT:相当于ctrl+\ </p>
<pre><code>9) SIGKILL: 强制杀死正在运行的进程 </code></pre><p>​    15) SIGTERM:终止正在运行的进程 </p>
<p>​    18) SIGCONT:继续运行 </p>
<p>​    19) SIGSTOP:后台休眠 </p>
<pre><code>指定信号的方法: 

(1) 信号的数字标识:1, 2, 9 

(2) 信号完整名称:SIGHUP 

(3) 信号的简写名称:HUP </code></pre><p>按PID:kill [-SIGNAL] pid … </p>
<pre><code>kill –n SIGNAL pid;kill –s SIGNAL pid </code></pre><p>按名称:killall [-SIGNAL] comm… </p>
<p>按模式:pkill [options] pattern </p>
<pre><code>-SIGNAL </code></pre><p>​    -u uid: effective user,生效者 </p>
<pre><code>-U uid: real user,真正发起运行命令者 </code></pre><p>​    -t terminal: 与指定终端相关的进程 </p>
<pre><code>-l: 显示进程名(pgrep可用) 

-a: 显示完整格式的进程名(pgrep可用) </code></pre><p>​    -P pid: 显示指定进程的子进程 </p>
<h3 id="作业管理"><a href="#作业管理" class="headerlink" title="作业管理"></a>作业管理</h3><p> Linux的作业控制 </p>
<pre><code>前台作业:通过终端启动,且启动后一直占据终端 

后台作业:可通过终端启动,但启动后即转入后台运行(释放终端) </code></pre><p> 让作业运行于后台 </p>
<pre><code>(1) 运行中的作业: Ctrl+z 

(2) 尚未启动的作业: COMMAND &amp; </code></pre><p> 后台作业虽然被送往后台运行,但其依然与终端相关;退出终端,将关闭后台作业。如果希望 送往后台后,剥离与终端的关系 </p>
<pre><code>nohup COMMAND &amp;&gt;/dev/null &amp; 

screen;COMMAND </code></pre><p> 查看当前终端所有作业:jobs </p>
<p> 作业控制: </p>
<pre><code>fg [[%]JOB_NUM]:把指定的后台作业调回前台 

bg [[%]JOB_NUM]:让送往后台的作业在后台继续运行 

kill [%JOB_NUM]: 终止指定的作业 </code></pre><h3 id="并行运行"><a href="#并行运行" class="headerlink" title="并行运行"></a>并行运行</h3><p>同时运行多个进程,提高效率 </p>
<p>方法1 </p>
<pre><code>vi all.sh 

f1.sh&amp; 

f2.sh&amp; 

f3.sh&amp; </code></pre><p>方法2 </p>
<pre><code>(f1.sh&amp;);(f2.sh&amp;);(f3.sh&amp;) </code></pre><p>方法3 </p>
<pre><code>{ f1.sh&amp; f2.sh&amp; f3.sh&amp; } </code></pre><h3 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h3><p>Linux任务计划、周期性任务执行 </p>
<pre><code>• 未来的某时间点执行一次任务 

    at 

    batch:系统自行选择空闲时间去执行此处指定的任务 

• 周期性运行某任务 

    cron </code></pre><h4 id="at任务"><a href="#at任务" class="headerlink" title="at任务"></a>at任务</h4><p>包:at </p>
<p> at命令:at [option] TIME </p>
<p> 常用选项: </p>
<pre><code>-V 显示版本信息: 

-l 列出指定队列中等待运行的作业;相当于atq 

-d 删除指定的作业;相当于atrm 

-c 查看具体作业任务 

-f /path/file 指定的文件中读取任务 

-m 当任务被完成之后,将给用户发送邮件,即使没有标准输出 </code></pre><p> 注意:作业执行命令的结果中的标准输出和错误以邮件通知给相关用户 </p>
<p> TIME:定义出什么时候进行 at 这项任务的时间 </p>
<pre><code>HH:MM [YYYY-mm-dd] 

noon, midnight, teatime(4pm) 

tomorrow 

now+#{minutes,hours,days, OR weeks} </code></pre><h4 id="at时间格式"><a href="#at时间格式" class="headerlink" title="at时间格式"></a>at时间格式</h4><p>HH:MM 02:00 </p>
<pre><code>在今日的 HH:MM 进行,若该时刻已过,则明天此时执行任务 </code></pre><p>HH:MM YYYY-MM-DD 02:00 2016-09-20 </p>
<pre><code>规定在某年某月的某一天的特殊时刻进行该项任务 HH:MM[am|pm]/[Month]/[Date] 0

4pm March 17 

17:20 tomorrow </code></pre><p>HH:MM[am|pm] + number [minutes|hours|days|weeks]</p>
<pre><code>在某个时间点再加几个时间后才进行该项任务 

now + 5 min 

02pm + 3 days </code></pre><h4 id="at任务-1"><a href="#at任务-1" class="headerlink" title="at任务"></a>at任务</h4><p>执行方式: </p>
<pre><code>1)交互式 2)输入重定向 3)at –f 文件 </code></pre><p>依赖与atd服务,需要启动才能实现at任务 </p>
<p>at队列存放在/var/spool/at目录中 </p>
<p>/etc/at.{allow,deny}控制用户是否能执行at任务 </p>
<pre><code>白名单:/etc/at.allow 默认不存在,只有该文件中的用户才能执行at命令 

黑名单:/etc/at.deny 默认存在,拒绝该文件中用户执行at命令,而没有在 at.deny 文件中的使用者则可执行 

如果两个文件都不存在,只有 root 可以执行 at 命令 </code></pre><hr>
<h4 id="周期性任务计划-cron"><a href="#周期性任务计划-cron" class="headerlink" title="周期性任务计划 cron"></a>周期性任务计划 cron</h4><p>相关的程序包: </p>
<pre><code>cronie: 主程序包,提供crond守护进程及相关辅助工具 

cronie-anacron:cronie的补充程序,用于监控cronie任务执行状况,如 cronie中的任务在过去该运行的时间点未能正常运行,则anacron会随后启动一次 此任务 

crontabs:包含CentOS提供系统维护任务 </code></pre><h4 id="计划任务-1"><a href="#计划任务-1" class="headerlink" title="计划任务"></a>计划任务</h4><p>确保crond守护处于运行状态: </p>
<pre><code>CentOS 7: 

    systemctl status crond 

CentOS 6: 

    service crond status </code></pre><p>计划周期性执行的任务提交给crond,到指定时间会自动运行 </p>
<pre><code>系统cron任务:系统维护作业 

    /etc/crontab 

用户cron任务: 

    crontab命令 </code></pre><p>日志:/var/log/cron </p>
<p>系统cron任务:/etc/crontab<br>注释行以 # 开头<br>详情参见 man 5 crontab</p>
<p>#Example of job definition:</p>
<p>#.—————- minute (0 - 59)</p>
<p>#| .————- hour (0 - 23)</p>
<p>#| | .———- day of month (1 - 31)</p>
<p>#| | | .——- month (1 - 12) OR jan,feb,mar,apr …</p>
<p>#| | | | .—- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</p>
<p>#| | | | |</p>
<p>#* * * * * user-name command to be executed</p>
<p>例如:晚上9点10分运行echo命令<br>10 21 * * * wang /bin/echo “Howdy!”</p>
<p>时间表示法: </p>
<pre><code>(1) 特定值 给定时间点有效取值范围内的值 

(2) 给定时间点上有效取值范围内的所有值 表示“每...” 

(3) 离散取值 

   #,#,# 

(4) 连续取值 

   #-# 

(5) 在指定时间范围上,定义步长 

   /#: #即为步长 </code></pre><h4 id="时间格式"><a href="#时间格式" class="headerlink" title="时间格式"></a>时间格式</h4><p>@reboot         Run once after reboot </p>
<p>@yearly         0 0 1 1 * </p>
<p>@annually         0 0 1 1 * </p>
<p>@monthly         0 0 1 * * </p>
<p>@weekly         0 0 * * 0 </p>
<p>@daily         0 0 * * * </p>
<p>@hourly         0 * * * * </p>
<p>示例:每3小时echo和wall命令 </p>
<pre><code>0 */3 * * * centos /bin/echo “howdy”;/usr/bin/wall “show time!” </code></pre><p><strong>系统的计划任务</strong></p>
<p>/etc/crontab             配置文件 </p>
<p>/etc/cron.d/             配置文件 </p>
<p>/etc/cron.hourly/         脚本 </p>
<p>/etc/cron.daily/         脚本 </p>
<p>/etc/cron.weekly/     脚本 </p>
<p>/etc/cron.monthly/     脚本 </p>
<h4 id="anacron-系统"><a href="#anacron-系统" class="headerlink" title="anacron 系统"></a>anacron 系统</h4><p>运行计算机关机时cron不运行的任务,CentOS6以后版本取消anacron服务,由 crond服务管理 </p>
<p>对笔记本电脑、台式机、工作站、偶尔要关机的服务器及其它不一直开机的系统 很重要对很有用 </p>
<p>配置文件:/etc/anacrontab,负责执行/etc/ cron.daily /etc/cron.weekly /etc/cron.monthly中系统任务 </p>
<pre><code>• 字段1:如果在这些日子里没有运行这些任务…… 

• 字段2:在重新引导后等待这么多分钟后运行它 

• 字段3:任务识别器,在日志文件中标识 

• 字段4:要执行的任务 </code></pre><p>由/etc/cron.hourly/0anacron执行 </p>
<p>当执行任务时,更新/var/spool/anacron/cron.daily 文件的时间戳 </p>
<h4 id="管理临时文件"><a href="#管理临时文件" class="headerlink" title="管理临时文件"></a>管理临时文件</h4><p>CentOS6使用</p>
<pre><code>/etc/cron.daily/tmpwatch定时清除临时文件 </code></pre><p>CentOS7使用</p>
<pre><code>systemd-tmpfiles-setup服务实现 </code></pre><p>配置文件: </p>
<pre><code>/etc/tmpfiles.d/*.conf *

/run/tmpfiles.d/*.conf *

/usr/lib/tmpfiles/*.conf </code></pre><p>/usr/lib/tmpfiles.d/tmp.conf </p>
<pre><code>d /tmp 1777 root root 10d 

d /var/tmp 1777 root root 30d </code></pre><p>命令: </p>
<pre><code>systemd-tmpfiles –clean|remove|create configfile </code></pre><h4 id="用户计划任务"><a href="#用户计划任务" class="headerlink" title="用户计划任务"></a>用户计划任务</h4><p>crontab命令定义 </p>
<pre><code>每个用户都有专用的cron任务文件: 

    /var/spool/cron/USERNAME </code></pre><p>crontab命令: </p>
<pre><code>crontab [-u user]/[-l | -r | -e]/[-i] 

-l: 列出所有任务 

-e: 编辑任务 

-r: 移除所有任务 

-i:同-r一同使用,以交互式模式移除指定任务 

-u user: 仅root可运行,指定用户管理cron任务 </code></pre><p>控制用户执行计划任务: </p>
<pre><code>/etc/cron.{allow,deny} </code></pre><p><strong>at和crontab</strong></p>
<p>一次性作业使用 at </p>
<p>重复性作业使用crontab </p>
<p>Create         at time             crontab -e </p>
<p>List             at -l             crontab -l </p>
<p>Details         at -c jobnum     N/A </p>
<p>Remove         at -d jobnum     crontab -r </p>
<p>Edit         N/A             crontab -e </p>
<p>没有被重定向的输出会被邮寄给用户 </p>
<p>root能够修改其它用户的作业 </p>
<p>注意:运行结果的标准输出和错误以邮件通知给相关用户 </p>
<pre><code>(1) COMMAND &gt; /dev/null 

(2) COMMAND &amp;&gt; /dev/null </code></pre><p>对于cron任务来讲,%有特殊用途;如果在命令中要使用%,则需要转义,将% 放置于单引号中,则可不用转义 </p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 中的进程和计划任务(一)</title>
    <url>/Linux-%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1-%E4%B8%80/</url>
    <content><![CDATA[<h2 id="Linux-中进程的查看"><a href="#Linux-中进程的查看" class="headerlink" title="Linux 中进程的查看"></a>Linux 中进程的查看</h2><h3 id="进程的相关概念"><a href="#进程的相关概念" class="headerlink" title="进程的相关概念"></a>进程的相关概念</h3><p>内核的功用:进程管理、文件系统、网络功能、内存管理、驱动程序、安全功能等 </p>
<p>Process: 运行中的程序的一个副本,是被载入内存的一个指令集合 </p>
<p>​    进程ID(Process ID,PID)号码被用来标记各个进程UID、GID、和SELinux语境决定对文件系统的存取和访问权限,通常从执行进程的用户来继承存在生命周期 </p>
<p>task struct:Linux内核存储进程信息的数据结构格式 </p>
<p>task list:多个任务的的task struct组成的链表 </p>
<p>进程创建: </p>
<p>​    init:第一个进程 </p>
<p>​    进程:都由其父进程创建,父子关系,CoW fork(), clone() </p>
<h4 id="进程的基本状态和转换"><a href="#进程的基本状态和转换" class="headerlink" title="进程的基本状态和转换"></a>进程的基本状态和转换</h4><p><strong>创建状态:</strong></p>
<p>​    进程在创建时需要申请一个空白PCB(process control block进程控 制块),向其中填写控制和管理进程的信息,完成资源分配.如果创建工作无法完 成,比如资源无法满足,就无法被调度运行,把此时进程所处状态称为创建状态 </p>
<p><strong>就绪状态:</strong></p>
<p>​    进程已准备好,已分配到所需资源,只要分配到CPU就能够立即运行 </p>
<p><strong>执行状态:</strong></p>
<p>​    进程处于就绪状态被调度后,进程进入执行状态 </p>
<p><strong>阻塞状态:</strong></p>
<p>​    正在执行的进程由于某些事件(I/O请求,申请缓存区失败)而暂时 无法运行,进程受到阻塞.在满足请求时进入就绪状态等待系统调用 </p>
<p><strong>终止状态:</strong></p>
<p>​    进程结束,或出现错误,或被系统终止,进入终止状态.无法再执行 </p>
<h4 id="进程之间转换六种情况"><a href="#进程之间转换六种情况" class="headerlink" title="进程之间转换六种情况"></a>进程之间转换六种情况</h4><p>运行——&gt;就绪:</p>
<p>​    1,主要是进程占用CPU的时间过长,而系统分配给该进程占 用CPU的时间是有限的:</p>
<p>​    2,在采用抢先式优先级调度算法的系统中,当有更高 优先级的进程要运行时,该进程就被迫让出CPU,该进程便由执行状态转变为 就绪状态 </p>
<p>就绪——&gt;运行:运行的进程的时间片用完,调度就转到就绪队列中选择合适 的进程分配CPU </p>
<p>运行——&gt;阻塞:正在执行的进程因发生某等待事件而无法执行,则进程由执 行状态变为阻塞状态,如发生了I/O请求 </p>
<p>阻塞——&gt;就绪:进程所等待的事件已经发生,就进入就绪队列 </p>
<p>以下两种状态是不可能发生的: </p>
<p>​    阻塞——&gt;运行:即使给阻塞进程分配CPU,也无法执行,操作系统在进行调 度时不会从阻塞队列进行挑选,而是从就绪队列中选取 </p>
<p>​    就绪——&gt;阻塞:就绪态根本就没有执行,谈不上进入阻塞态 </p>
<h4 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h4><p>进程优先级: </p>
<p>​    系统优先级:数字越小,优先级越高 </p>
<p>​        0-139(CentOS4,5) </p>
<p>​            各有140个运行队列和过期队列 </p>
<p>​        0-98,99(CentOS6) </p>
<p>​    实时优先级: 99-0 值最大优先级最高 </p>
<p>​    nice值:-20到19,对应系统优先级100-139或99 </p>
<p>Big O:时间复杂度,用时和规模的关系 </p>
<p>​    O(1), O(logn), O(n)线性, O(n^2)抛物线, O(2^n) </p>
<h4 id="进程相关概念"><a href="#进程相关概念" class="headerlink" title="进程相关概念"></a>进程相关概念</h4><p>进程内存: </p>
<p>​    Page Frame: 页框,用存储页面数据,存储Page 4k </p>
<p>​    LRU:Least Recently Used 近期最少使用算法,释放内存物理地址空间和线性地址空间 </p>
<p>​    MMU:Memory Management Unit负责转换线性和物理地址 </p>
<p>​    TLB:Translation Lookaside Buffer 翻译后备缓冲器,用于保存虚拟地址和物理地址映射关系的缓存 </p>
<p>IPC: Inter Process Communication </p>
<p>​    同一主机:</p>
<p>​        signal:信号 </p>
<p>​        shm: shared memory </p>
<p>​        semaphore:信号量,一种计数器 </p>
<p>​    不同主机:</p>
<p>​        socket: IP和端口号 </p>
<p>​        RPC: remote procedure call </p>
<p>​        MQ:消息队列,Kafka,ActiveMQ </p>
<h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p>Linux内核:抢占式多任务 </p>
<p>进程类型: </p>
<p>​    守护进程: daemon,在系统引导过程中启动的进程,和终端无关进程 </p>
<p>​    前台进程:跟终端相关,通过终端启动的进程 </p>
<p>​    注意:两者可相互转化 </p>
<p>进程状态: </p>
<p>​    运行态:running </p>
<p>​    就绪态:ready </p>
<p>​    睡眠态: </p>
<p>​        可中断:interruptable </p>
<p>​        不可中断:uninterruptable </p>
<p>​    停止态:stopped,暂停于内存,但不会被调度,除非手动启动 </p>
<p>​    僵死态:zombie,结束进程,父进程结束前,子进程不关闭 </p>
<hr>
<h3 id="系统管理工具"><a href="#系统管理工具" class="headerlink" title="系统管理工具"></a>系统管理工具</h3><p>进程的分类: </p>
<p>​    CPU-Bound:CPU密集型,非交互 </p>
<p>​    IO-Bound:IO密集型,交互 </p>
<p>Linux系统状态的查看及管理工具:pstree, ps, pidof, pgrep, top, htop, glance, pmap, vmstat, dstat, kill, pkill, job, bg, fg, nohup </p>
<p>pstree命令: </p>
<p>​    pstree - display a tree of processes </p>
<p>ps: process state </p>
<p>​    ps - report a snapshot of the current processes </p>
<p>​    Linux系统各进程的相关信息均保存在/proc/PID目录下的各文件中 </p>
<h4 id="查看系统进程-ps"><a href="#查看系统进程-ps" class="headerlink" title="查看系统进程 ps"></a>查看系统进程 ps</h4><p>ps [OPTION]… </p>
<p>支持三种选项: </p>
<p>​    UNIX选项 如-A -e </p>
<p>​    BSD选项 如a </p>
<p>​    GNU选项 如–help </p>
<p>• 选项:默认显示当前终端中的进程 </p>
<p>• a 选项包括所有终端中的进程 </p>
<p>• x 选项包括不链接终端的进程 </p>
<p>• u 选项显示进程所有者的信息 </p>
<p>• f 选项显示进程树,相当于 –forest </p>
<p>• k|–sort 属性 对属性排序,属性前加- 表示倒序 </p>
<p>• o 属性… 选项显示定制的信息 pid、cmd、%cpu、%mem </p>
<p>• L 显示支持的属性列表 </p>
<h5 id="ps常见选项"><a href="#ps常见选项" class="headerlink" title="ps常见选项"></a>ps常见选项</h5><p>-C cmdlist 指定命令,多个命令用,分隔 </p>
<p>-L 显示线程 </p>
<p>-e: 显示所有进程,相当于-A </p>
<p>-f: 显示完整格式程序信息 </p>
<p>-F: 显示更完整格式的进程信息 </p>
<p>-H: 以进程层级格式显示进程相关信息 </p>
<p>-u userlist 指定有效的用户ID或名称 </p>
<p>-U userlist 指定真正的用户ID或名称 </p>
<p>-g gid或groupname 指定有效的gid或组名称 </p>
<p>-G gid或groupname 指定真正的gid或组名称 </p>
<p>-p pid 显示指pid的进程 </p>
<p>–ppid pid 显示属于pid的子进程 </p>
<p>-M 显示SELinux信息,相当于Z </p>
<h5 id="ps输出属性"><a href="#ps输出属性" class="headerlink" title="ps输出属性"></a>ps输出属性</h5><p>VSZ: Virtual memory SiZe,虚拟内存集,线性内存 </p>
<p>RSS: ReSident Size, 常驻内存集 </p>
<p>STAT:进程状态 </p>
<p>​    R:running </p>
<p>​    S: interruptable sleeping </p>
<p>​    D: uninterruptable sleeping </p>
<p>​    T: stopped </p>
<p>​    Z: zombie </p>
<p>​    +: 前台进程 </p>
<p>​    l: 多线程进程 </p>
<p>​    L:内存分页并带锁 </p>
<p>​    N:低优先级进程 </p>
<p>​    &lt;: 高优先级进程 </p>
<p>​    s: session leader,会话(子进程)发起者 </p>
<h4 id="ps-输出及常见示例"><a href="#ps-输出及常见示例" class="headerlink" title="ps 输出及常见示例"></a>ps 输出及常见示例</h4><p>ni: nice值 </p>
<p>pri: priority 优先级 </p>
<p>psr: processor CPU编号 </p>
<p>rtprio: 实时优先级 </p>
<p>示例: </p>
<p>​    ps axo pid,cmd,psr,ni,pri,rtprio </p>
<p>常用组合: </p>
<p>​    aux </p>
<p>​    -ef </p>
<p>​    -eFH </p>
<p>​    -eo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,comm </p>
<p>​    axo stat,euid,ruid,tty,tpgid,sess,pgrp,ppid,pid,pcpu,comm </p>
<h5 id="ps示例"><a href="#ps示例" class="headerlink" title="ps示例"></a>ps示例</h5><p>查询你拥有的所有进程: </p>
<p>​    ps -x </p>
<p>显示指定用户名(RUID)或用户ID的进程: </p>
<p>​    ps -fU apache </p>
<p>​    ps -fu 48 </p>
<p>显示指定用户名(EUID)或用户ID的进程: </p>
<p>​    ps -fu mark </p>
<p>​    ps -fu 1000 </p>
<p>查看以root用户权限(实际和有效ID)运行的每个进程: </p>
<p>​    ps -U root -u root </p>
<p>列出某个组拥有的所有进程(实际组ID,RGID或名称): </p>
<p>​    ps -fG nginx </p>
<p>列出有效组名称(或会话)所拥有的所有进程: </p>
<p>​    ps -fg mysql </p>
<p>​    ps -fG 27 </p>
<p>通过进程ID来显示所属的进程: </p>
<p>​    ps -fp 1234 </p>
<p>以父进程ID来显示其下所有的进程,如显示父进程为1154的所有进程: </p>
<p>​    ps -f –ppid 1234 </p>
<p>显示指定PID的多个进程: </p>
<p>​    ps -fp 1204,1239,1263 </p>
<p>要按tty显示所属进程: </p>
<p>​    ps -ft pst/0 </p>
<p>以进程树显示系统中的进程如何相互链接: </p>
<p>​    ps -e –forest </p>
<p>以进程树显示指定的进程 </p>
<p>​    ps -f –forest -C sshd </p>
<p>​    ps -ef –forest | grep -v grep | grep sshd </p>
<p>要显示一个进程的所有线程,将显示LWP(轻量级进程)以及NLWP(轻量级进 程数)列: </p>
<p>​    ps -fL -C nginx </p>
<p>要列出所有格式说明符: </p>
<p>​    ps L </p>
<p>查看进程的PID,PPID,用户名和命令: </p>
<p>​    ps -eo pid,ppid,user,cmd </p>
<p>自定义格式显示文件系统组,ni值开始时间和进程的时间: </p>
<p>​    ps -p 1234 -o pid,ppid,fgroup,ni,lstart,etime </p>
<p>使用其PID查找进程名称: </p>
<p>​    ps -p 1244 -o comm= </p>
<p>要以其名称选择特定进程,显示其所有子进程 </p>
<p>​    ps -C sshd,bash </p>
<p>查找指定进程名所有的所属PID,在编写需要从std输出或文件读取PID的脚本时 这个参数很有用: </p>
<p>​    ps -C httpd,sshd -o pid= </p>
<p>检查一个进程的执行时间 </p>
<p>​    ps -eo comm,etime,user | grep nginx </p>
<p>查找占用最多内存和CPU的进程: </p>
<p>​    ps -eo pid,ppid,cmd,%mem,%cpu –sort=-%mem | head</p>
<p>​    ps -eo pid,ppid,cmd,%mem,%cpu –sort=-%cpu | head </p>
<p>显示安全信息: </p>
<p>​    ps -eM </p>
<p>​    ps –context </p>
<p>使用以下命令以用户定义的格式显示安全信息. </p>
<p>​    ps -eo euser,ruser,suser,fuser,f,comm,label </p>
<p>使用watch实用程序执行重复的输出以实现对就程进行实时的监视,如下面的命 令显示每秒钟的监视: </p>
<p>​    watch -n 1 ‘ps -eo pid,ppid,cmd,%mem,%cpu –sort=-%mem | head’ </p>
<hr>
<h3 id="进程优先级-1"><a href="#进程优先级-1" class="headerlink" title="进程优先级"></a>进程优先级</h3><p>进程优先级调整: </p>
<p>​    静态优先级:100-139 </p>
<p>​    进程默认启动时的nice值为0,优先级为120 </p>
<p>​    只有根用户才能降低nice值(提高优先性) </p>
<p>nice命令: </p>
<p>​    nice [OPTION]/[COMMAND /[ARG]…] </p>
<p>renice命令: </p>
<p>​    renice [-n] priority pid… </p>
<p>查看: </p>
<p>​    ps axo pid,comm,ni </p>
<h4 id="搜索进程"><a href="#搜索进程" class="headerlink" title="搜索进程"></a>搜索进程</h4><p>最灵活:</p>
<p>​    ps 选项 | 其它命令 </p>
<p>按预定义的模式:pgrep </p>
<p>​    pgrep [options] pattern </p>
<p>​    -u uid: effective user,生效者 </p>
<p>​    -U uid: real user,真正发起运行命令者 </p>
<p>​    -t terminal: 与指定终端相关的进程 </p>
<p>​    -l: 显示进程名 </p>
<p>​    -a: 显示完整格式的进程名 </p>
<p>​    -P pid: 显示指定进程的子进程 </p>
<p>按确切的程序名称:/sbin/pidof </p>
<p>​    pidof bash </p>
<h4 id="系统工具"><a href="#系统工具" class="headerlink" title="系统工具"></a>系统工具</h4><p><strong>uptime</strong></p>
<p>显示当前时间,系统已启动的时间、当前上线人数,系统平均负载(1、5、10 分钟的平均负载,一般不会超过1) </p>
<p>系统平均负载: </p>
<p>指在特定时间间隔内运行队列中的平均进程数 </p>
<p>通常每个CPU内核的当前活动进程数不大于3,那么系统的性能良好.如果每 个CPU内核的任务数大于5,那么此主机的性能有严重问题 </p>
<p>如果linux主机是1个双核CPU,当Load Average 为6的时候说明机器已经被 充分使用 </p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 启动和内核管理(一)</title>
    <url>/Linux-%E5%90%AF%E5%8A%A8%E5%92%8C%E5%86%85%E6%A0%B8%E7%AE%A1%E7%90%86-%E4%B8%80/</url>
    <content><![CDATA[<h3 id="Linux组成"><a href="#Linux组成" class="headerlink" title="Linux组成"></a>Linux组成</h3><p>Linux: kernel+rootfs<br>    kernel: 进程管理、内存管理、网络管理、驱动程序、文件系统、安全功能<br>    rootfs:程序和glibc<br>    库：函数集合, function, 调用接口（头文件负责描述）<br>        过程调用：procedure,无返回值<br>        函数调用：function<br>    程序：二进制执行文件<br>内核设计流派：<br>    单内核(monolithic kernel)：Linux<br>        把所有功能集成于同一个程序<br>    微内核(micro kernel)：Windows, Solaris<br>        每种功能使用一个单独子系统实现</p>
<h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><p>Linux内核特点：<br>    支持模块化：.ko（内核对象）<br>        如：文件系统,硬件驱动,网络协议等<br>    支持内核模块的动态装载和卸载<br>组成部分：<br>核心文件：/boot/vmlinuz-VERSION-release<br>    ramdisk：辅助的伪根系统<br>    CentOS 5: /boot/initrd-VERSION-release.img<br>    CentOS 6,7: /boot/initramfs-VERSION-release.img<br>模块文件：/lib/modules/VERSION-release</p>
<h3 id="CentOS6启动流程"><a href="#CentOS6启动流程" class="headerlink" title="CentOS6启动流程"></a>CentOS6启动流程</h3><p>1.加载BIOS的硬件信息,获取第一个启动设备<br>2.读取第一个启动设备MBR的引导加载程序(grub)的启动信息<br>3.加载核心操作系统的核心信息,核心开始解压缩,并尝试驱动所有的硬件设备<br>4.核心执行init程序,并获取默认的运行信息<br>5.init程序执行/etc/rc.d/rc.sysinit文件<br>6.启动核心的外挂模块<br>7.init执行运行的各个批处理文件(scripts)<br>8.init执行/etc/rc.d/rc.local<br>9.执行/bin/login程序,等待用户登录<br>10.登录之后开始以Shell控制主机</p>
<h4 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h4><p> POST：Power-On-Self-Test,加电自检,是BIOS功能的一个主要部分.负责完成对CPU、主板、内存、硬盘子系统、显示子系统、串并行接口、键盘等硬件情况的检测<br>    ROM：BIOS,Basic Input and Output System,保存着有关计算机系统最重要的基本输入输出程序,系统信息设置、开机加电自检程序和系统启动自举程序等<br>    RAM：CMOS互补金属氧化物半导体,保存各项参数的设定<br>    按次序查找引导设备,第一个有引导程序的设备为本次启动设备<br> bootloader: 引导加载器,引导程序<br>    windows: ntloader,仅是启动OS<br>    Linux：功能丰富,提供菜单,允许用户选择要启动系统或不同的内核版本；把用户选定的内核装载到内存中的特定空间中,解压、展开,并把系统控制权移交给内核<br>        LILO：LInux LOader<br>        GRUB: GRand Unified Bootloader<br>            GRUB 0.X: GRUB Legacy, GRUB2</p>
<p>MBR:<br>    446: bootloader, 64: 分区表, 2: 55AA<br>GRUB:<br>    primary boot loader : 1st stage,1.5 stage<br>    secondary boot loader ：2nd stage,分区文件<br>kernel：<br>自身初始化：<br>    探测可识别到的所有硬件设备<br>    加载硬件驱动程序（借助于ramdisk加载驱动）<br>    以只读方式挂载根文件系统<br>    运行用户空间的第一个应用程序：/sbin/init</p>
<p>ramdisk：<br>内核中的特性之一：使用缓冲和缓存来加速对磁盘上的文件访问,并加载相应的硬件驱动<br>    ramdisk –&gt; ramfs 提高速度<br>    CentOS 5: initrd<br>        工具程序：mkinitrd<br>    CentOS 6,7: initramfs<br>        工具程序：mkinitrd, dracut<br>系统初始化：<br>POST –&gt; BootSequence (BIOS) –&gt; Bootloader(MBR) –&gt; kernel(ramdisk) –&gt; rootfs(只读) –&gt; init（systemd）</p>
<h3 id="ramdisk管理"><a href="#ramdisk管理" class="headerlink" title="ramdisk管理"></a>ramdisk管理</h3><p>ramdisk文件的制作：<br>(1) mkinitrd命令<br>    为当前正在使用的内核重新制作ramdisk文件<br>    mkinitrd /boot/initramfs-$(uname -r).img $(uname -r)<br>(2) dracut命令<br>    为当前正在使用的内核重新制作ramdisk文件<br>    dracut /boot/initramfs-$(uname -r).img $(uname -r) </p>
<h3 id="系统启动流程"><a href="#系统启动流程" class="headerlink" title="系统启动流程"></a>系统启动流程</h3><p>init程序的类型：</p>
<p>SysV: init, CentOS 5之前</p>
<pre><code>配置文件：/etc/inittab</code></pre><p>Upstart: init,CentOS 6</p>
<pre><code>配置文件：/etc/inittab, /etc/init/*.conf</code></pre><p>Systemd：systemd, CentOS 7</p>
<pre><code>配置文件：

    /usr/lib/systemd/system

    /etc/systemd/system</code></pre><h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><p>/sbin/init CentOS6之前<br>运行级别：为系统运行或维护等目的而设定；0-6：7个级别<br>    0：关机<br>    1：单用户模式(root自动登录), single, 维护模式<br>    2: 多用户模式,启动网络功能,但不会启动NFS；维护模式<br>    3：多用户模式,正常模式；文本界面<br>    4：预留级别；可同3级别<br>    5：多用户模式,正常模式；图形界面<br>    6：重启<br>默认级别：3, 5<br>切换级别：init #<br>查看级别：runlevel : who -r</p>
<h3 id="init初始化"><a href="#init初始化" class="headerlink" title="init初始化"></a>init初始化</h3><p>init读取其初始化文件：/etc/inittab<br>初始运行级别(RUN LEVEL)<br>系统初始化脚本<br>对应运行级别的脚本目录<br>捕获某个关键字顺序<br>定义UPS电源终端/恢复脚本<br>在虚拟控制台生成getty<br>在运行级别5初始化X</p>
<h3 id="CentOS-5-的inittab文件"><a href="#CentOS-5-的inittab文件" class="headerlink" title="CentOS 5 的inittab文件"></a>CentOS 5 的inittab文件</h3><p>配置文件：</p>
<pre><code>/etc/inittab</code></pre><p> 每一行格式： </p>
<pre><code>id:runlevel:action:process

id：是惟一标识该项的字符序列

runlevels： 定义了操作所使用的运行级别

action： 指定了要执行的特定操作

    wait: 切换至此级别运行一次</code></pre><p>​        respawn：此process终止,就重新启动之</p>
<pre><code>    initdefault：设定默认运行级别；process省略

    sysinit：设定系统初始化方式

process：定义了要执行的进程</code></pre><p> 示例：</p>
<pre><code>id:3:initdefault:

si::sysinit:/etc/rc.d/rc.sysinit

l0:0:wait:/etc/rc.d/rc 0

l1:1:wait:/etc/rc.d/rc 1...

l6:6:wait:/etc/rc.d/rc 6

ca::ctrlaltdel:/sbin/shutdown -t3 -r now</code></pre><p>CentOS 6 /etc/inittab和相关文件</p>
<p>/etc/inittab</p>
<pre><code>设置系统默认的运行级别

id:3:initdefault:</code></pre><p> 示例：</p>
<pre><code>破解CentOS5和6的root口令</code></pre><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/init/control-alt-delete.conf</span><br><span class="line"></span><br><span class="line">/etc/init/tty.conf</span><br><span class="line"></span><br><span class="line">/etc/init/start-ttys.conf</span><br><span class="line"></span><br><span class="line">/etc/init/rc.conf</span><br><span class="line"></span><br><span class="line">/etc/init/prefdm.conf</span><br></pre></td></tr></table></figure>



<h3 id="启动流程-1"><a href="#启动流程-1" class="headerlink" title="启动流程"></a>启动流程</h3><p>/etc/rc.d/rc.sysinit: 系统初始化脚本<br>    (1) 设置主机名<br>    (2) 设置欢迎信息<br>    (3) 激活udev和selinux<br>    (4) 挂载/etc/fstab文件中定义的文件系统<br>    (5) 检测根文件系统,并以读写方式重新挂载根文件系统<br>    (6) 设置系统时钟<br>    (7) 激活swap设备<br>    (8) 根据/etc/sysctl.conf文件设置内核参数<br>    (9) 激活lvm及software raid设备<br>    (10) 加载额外设备的驱动程序<br>    (11) 清理操作</p>
<p>说明：rc N –&gt; 意味着读取/etc/rc.d/rcN.d/<br>    K<em>: K##*：##运行次序；数字越小,越先运行；数字越小的服务,通常为依赖到别的服务<br>    S</em>: S##<em>：##运行次序；数字越小,越先运行；数字越小的服务,通常为被依赖到的服务<br>    for srv in /etc/rc.d/rcN.d/K</em>: do<br>        $srv stop<br>    done<br>    for srv in /etc/rc.d/rcN.d/S*: do<br>        $srv start<br>    done</p>
<h3 id="chkconfig命令"><a href="#chkconfig命令" class="headerlink" title="chkconfig命令"></a>chkconfig命令</h3><p>ntsysv命令<br> chkconfig命令<br> 查看服务在所有级别的启动或关闭设定情形：<br>    chkconfig [–list][name]<br> 添加：<br>    SysV的服务脚本放置于/etc/rc.d/init.d (/etc/init.d)<br>    chkconfig –add name<br>        #!/bin/bash</p>
<p>​        #LLLL 表示初始在哪个级别下启动,-表示都不启动</p>
<pre><code># chkconfig: LLLL nn nn</code></pre><p> 删除：<br>    chkconfig –del name<br> 修改指定的链接类型<br>    chkconfig [–level levels] name<br>        –level LLLL: 指定要设置的级别；省略时表示2345</p>
<h3 id="xinetd管理的服务"><a href="#xinetd管理的服务" class="headerlink" title="xinetd管理的服务"></a>xinetd管理的服务</h3><p>service 命令：手动管理服务<br>    service 服务 start|stop|restart<br>    service –status-all<br>瞬态（Transient）服务被xinetd进程所管理<br>进入的请求首先被xinetd代理<br>配置文件：/etc/xinetd.conf、/etc/xinetd.d/<br>与libwrap.so文件链接<br>用chkconfig控制的服务：<br>示例：chkconfig tftp on</p>
<h3 id="启动流程-2"><a href="#启动流程-2" class="headerlink" title="启动流程"></a>启动流程</h3><p>注意：正常级别下,最后启动一个服务S99local没有链接至/etc/rc.d/init.d一个<br>服务脚本,而是指向了/etc/rc.d/rc.local脚本<br>不便或不需写为服务脚本放置于/etc/rc.d/init.d/目录,且又想开机时自动运行<br>的命令,可直接放置于/etc/rc.d/rc.local文件中<br>• /etc/rc.d/rc.local在指定运行级别脚本后运行<br>• 可以根据情况,进行自定义修改</p>
<p>1:2345:respawn:/usr/sbin/mingetty tty1<br>2:2345:respawn:/usr/sbin/mingetty tty2<br>…<br>6:2345:respawn:/usr/sbin/mingetty tty6<br>    mingetty会自动调用login程序<br>x:5:respawn:/etc/X11/prefdm -nodaemon</p>
<h3 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h3><p>总结：/sbin/init –&gt; (/etc/inittab) –&gt; 设置默认运行级别 –&gt; 运行系统初始脚本、完成系统初始化 –&gt; (关闭对应下需要关闭的服务)启动需要启动服务 –&gt; 设置登录终端<br>CentOS 6 init程序为: upstart, 其配置文件：<br>/etc/inittab, /etc/init/*.conf,配置文件的语法 遵循 upstart配置文件语法格式,和CentOS5不同</p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 启动和内核管理(三)</title>
    <url>/Linux-%E5%90%AF%E5%8A%A8%E5%92%8C%E5%86%85%E6%A0%B8%E7%AE%A1%E7%90%86-%E4%B8%89/</url>
    <content><![CDATA[<h3 id="内核编译"><a href="#内核编译" class="headerlink" title="内核编译"></a>内核编译</h3><p>单内核体系设计、但充分借鉴了微内核设计体系的优点,为内核引入模块化机制<br>内核组成部分：<br>    kernel: 内核核心,一般为bzImage,通常在/boot目录下,名称为vmlinuzVERSION-RELEASE<br>    kernel object: 内核对象,一般放置于<br>        /lib/modules/VERSION-RELEASE/</p>
<pre><code>\[]:N

\[M]:M

\[*]:Y

辅助文件：</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ramdisk</span><br><span class="line">initrd</span><br><span class="line">initramfs</span><br></pre></td></tr></table></figure>



<h3 id="内核版本"><a href="#内核版本" class="headerlink" title="内核版本"></a>内核版本</h3><p>运行中的内核：<br>    uname命令：<br>        uname - print system information<br>        uname [OPTION]…<br>            -n: 显示节点名称<br>            -r: 显示VERSION-RELEASE<br>            -a:显示所有信息</p>
<h3 id="内核模块命令"><a href="#内核模块命令" class="headerlink" title="内核模块命令"></a>内核模块命令</h3><p>lsmod命令：<br>    显示由核心已经装载的内核模块<br>    显示的内容来自于: /proc/modules文件<br>modinfo命令：<br>    显示模块的详细描述信息<br>    modinfo [ -k kernel ][ modulename|filename… ]<br>        -n: 只显示模块文件路径<br>        -p: 显示模块参数<br>        -a: author<br>        -d: description<br>        -l: license<br>lsmod |grep xfs:modinfo xfs</p>
<h3 id="内核模块管理"><a href="#内核模块管理" class="headerlink" title="内核模块管理"></a>内核模块管理</h3><p>modprobe命令：<br>装载或卸载内核模块<br>modprobe [ -C config-file ][ modulename ][ module parame-ters… ]</p>
<p>配置文件：/etc/modprobe.conf, /etc/modprobe.d/*.conf</p>
<p>modprobe [ -r ] modulename…</p>
<p>depmod命令：<br>    内核模块依赖关系文件及系统信息映射文件的生成工具<br>装载或卸载内核模块：<br>insmod命令：指定模块文件,不自动解决依赖模块<br>    insmod [ filename ][ module options… ]<br>    insmod `modinfo –n exportfs`<br>    lnsmod `modinfo –n xfs`<br>rmmod命令：卸载模块<br>    rmmod [ modulename ]<br>    rmmod xfs<br>    rmmod exportfs</p>
<h3 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h3><p>前提：<br>    (1) 准备好开发环境<br>    (2) 获取目标主机上硬件设备的相关信息<br>    (3) 获取目标主机系统功能的相关信息<br>        例如:需要启用相应的文件系统<br>    (4) 获取内核源代码包<br>        <a href="http://www.kernel.org" target="_blank" rel="noopener">www.kernel.org</a></p>
<h3 id="开发环境准备"><a href="#开发环境准备" class="headerlink" title="开发环境准备"></a>开发环境准备</h3><p>包组(CentOS 6)：<br>    Server Platform Development<br>    Development Tools<br>目标主机硬件设备相关信息：<br>    CPU：<br>    cat /proc/cpuinfo<br>    x86info -a<br>    lscpu</p>
<h3 id="硬件设备"><a href="#硬件设备" class="headerlink" title="硬件设备"></a>硬件设备</h3><p>PCI设备：<br>    lspci<br>        -v<br>        -vv<br>    lsusb<br>        -v<br>        -vv<br>    lsblk 块设备<br>了解全部硬件设备信息<br>    hal-device:CentOS6</p>
<h3 id="内核编译安装系统"><a href="#内核编译安装系统" class="headerlink" title="内核编译安装系统"></a>内核编译安装系统</h3><p>安装开发包组<br>下载源码文件<br>.config：准备文本配置文件<br>make menuconfig：配置内核选项<br>make [-j #]<br>make modules_install：安装模块<br>make install ：安装内核相关文件<br>    安装bzImage为/boot/vmlinuz-VERSION-RELEASE<br>    生成initramfs文件<br>    编辑grub的配置文件</p>
<h3 id="编译安装内核示例"><a href="#编译安装内核示例" class="headerlink" title="编译安装内核示例"></a>编译安装内核示例</h3><p>tar xf linux-3.10.67.tar.xz -C /usr/src<br>cd /usr/src<br>ln -sv linux-3.10.67 linux<br>cd /usr/src/linux<br>cp /boot/config-$(uname -r) ./.config<br>make help<br>make menuconfig<br>make -j 2<br>make modules_install<br>make install<br>reboot </p>
<h3 id="编译内核-1"><a href="#编译内核-1" class="headerlink" title="编译内核"></a>编译内核</h3><p>(1) 配置内核选项<br>    支持”更新”模式进行配置：make help<br>    (a) make config：基于命令行以遍历的方式配置内核中可配置的每个选项<br>    (b) make menuconfig：基于curses的文本窗口界面<br>    (c) make gconfig：基于GTK (GNOME）环境窗口界面<br>    (d) make xconfig：基于QT(KDE)环境的窗口界面<br>    支持”全新配置”模式进行配置<br>    (a) make defconfig：基于内核为目标平台提供的”默认”配置进行配置<br>    (b) make allyesconfig: 所有选项均回答为”yes”<br>    (c) make allnoconfig: 所有选项均回答为”no”</p>
<p>(2) 编译<br>全编译:make [-j #]<br>编译内核的一部分功能：<br>    (a) 只编译某子目录中的相关代码<br>        cd /usr/src/linux<br>        make dir/<br>    (b) 只编译一个特定的模块<br>        cd /usr/src/linux<br>        make dir/file.ko<br>        例如：只为e1000编译驱动：<br>    make drivers/net/ethernet/intel/e1000/e1000.ko</p>
<p>如何交叉编译内核：<br>    编译的目标平台与当前平台不相同<br>    make ARCH=arch_name<br>要获取特定目标平台的使用帮助<br>    make ARCH=arch_name help<br>    make ARCH=arm help</p>
<h3 id="内核编译-1"><a href="#内核编译-1" class="headerlink" title="内核编译"></a>内核编译</h3><p>在已经执行过编译操作的内核源码树做重新编译<br>需要事先清理操作：<br>    make clean：清理大多数编译生成的文件,但会保留config文件等<br>    make mrproper: 清理所有编译生成的文件、config及某些备份文件<br>    make distclean：mrproper、patches以及编辑器备份文件</p>
<h3 id="卸载内核"><a href="#卸载内核" class="headerlink" title="卸载内核"></a>卸载内核</h3><p>删除/lib/modules/目录下不需要的内核库文件<br>删除/usr/src/linux/目录下不需要的内核源码<br>删除/boot目录下启动的内核和内核映像文件<br>更改grub的配置文件,删除不需要的内核启动列表</p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-基础和帮助</title>
    <url>/Linux-%E5%9F%BA%E7%A1%80%E5%92%8C%E5%B8%AE%E5%8A%A9-1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Linux 启动和内核管理(四)</title>
    <url>/Linux-%E5%90%AF%E5%8A%A8%E5%92%8C%E5%86%85%E6%A0%B8%E7%AE%A1%E7%90%86-%E5%9B%9B/</url>
    <content><![CDATA[<h3 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h3><p>POST –&gt; Boot Sequence –&gt; Bootloader –&gt; kernel + initramfs(initrd) –&gt; rootfs –&gt; /sbin/init<br>    init:     CentOS 5: SysV init<br>            CentOS 6: Upstart<br>            CentOS 7: Systemd<br>Systemd：系统启动和服务器守护进程管理器,负责在系统启动或运行时,激活系统资源,服务器进程和其它进程<br>Systemd新特性：<br>    系统引导时实现服务并行启动<br>    按需启动守护进程<br>    自动化的服务依赖关系管理<br>    同时采用socket式与D-Bus总线式激活服务<br>    系统状态快照</p>
<p>核心概念：unit<br>    unit表示不同类型的systemd对象,通过配置文件进行标识和配置；文件中主要包含了系统服务、监听socket、保存的系统快照以及其它与init相关的信息<br>配置文件：<br>    /usr/lib/systemd/system:每个服务最主要的启动脚本设置,类似于之前的/etc/init.d/<br>    /run/systemd/system：系统执行过程中所产生的服务脚本,比上面目录优先运行<br>    /etc/systemd/system：管理员建立的执行脚本,类似于/etc/rc.d/rcN.d/Sxx类的功能,比上面目录优先运行</p>
<h3 id="Unit类型"><a href="#Unit类型" class="headerlink" title="Unit类型"></a>Unit类型</h3><p>Systemctl –t help 查看unit类型<br>Service unit: 文件扩展名为.service, 用于定义系统服务<br>Target unit: 文件扩展名为.target,用于模拟实现运行级别<br>Device unit: .device, 用于定义内核识别的设备<br>Mount unit: .mount, 定义文件系统挂载点<br>Socket unit: .socket, 用于标识进程间通信用的socket文件,也可在系统启动时,延迟启动服务,实现按需启动<br>Snapshot unit: .snapshot, 管理系统快照<br>Swap unit: .swap, 用于标识swap设备<br>Automount unit: .automount,文件系统的自动挂载点<br>Path unit: .path,用于定义文件系统中的一个文件或目录使用,常用于当文件系统变化时,延迟激活服务,如：spool 目录</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>关键特性：<br>    基于socket的激活机制：socket与服务程序分离<br>    基于d-bus的激活机制：<br>    基于device的激活机制：<br>    基于path的激活机制：<br>    系统快照：保存各unit的当前状态信息于持久存储设备中<br>    向后兼容sysv init脚本<br>不兼容：<br>    systemctl命令固定不变,不可扩展<br>    非由systemd启动的服务,systemctl无法与之通信和控制</p>
<h3 id="管理服务"><a href="#管理服务" class="headerlink" title="管理服务"></a>管理服务</h3><p>管理系统服务：<br>    CentOS 7: service unit<br>    注意：能兼容早期的服务脚本<br>命令：systemctl COMMAND name.service<br>启动：service name start ==&gt; systemctl start name.service<br>停止：service name stop ==&gt; systemctl stop name.service<br>重启：service name restart ==&gt; systemctl restart name.service<br>状态：service name status ==&gt; systemctl status name.service</p>
<p>条件式重启：已启动才重启,否则不做操作</p>
<pre><code>service name condrestart ==&gt; systemctl try-restart name.service</code></pre><p>重载或重启服务：先加载,再启动</p>
<pre><code>systemctl reload-or-restart name.service</code></pre><p>重载或条件式重启服务：</p>
<pre><code>systemctl reload-or-try-restart name.service</code></pre><p>禁止自动和手动启动：</p>
<pre><code>systemctl mask name.service</code></pre><p>取消禁止：</p>
<pre><code>systemctl unmask name.service</code></pre><h3 id="服务查看"><a href="#服务查看" class="headerlink" title="服务查看"></a>服务查看</h3><p>查看某服务当前激活与否的状态：</p>
<pre><code>systemctl is-active name.service</code></pre><p>查看所有已经激活的服务：</p>
<pre><code>systemctl list-units --type|-t service</code></pre><p>查看所有服务：</p>
<pre><code>systemctl list-units --type service --all|-a</code></pre><p>chkconfig命令的对应关系：</p>
<p>设定某服务开机自启：</p>
<pre><code>chkconfig name on ==&gt; systemctl enable name.service</code></pre><p>设定某服务开机禁止启动：</p>
<pre><code>chkconfig name off ==&gt; systemctl disable name.service</code></pre><p>查看所有服务的开机自启状态：<br>    chkconfig –list ==&gt; systemctl list-unit-files –type service</p>
<p>用来列出该服务在哪些运行级别下启用和禁用<br>    chkconfig sshd –list ==&gt;<br>    ls /etc/systemd/system/*.wants/sshd.service</p>
<p>查看服务是否开机自启：<br>    systemctl is-enabled name.service</p>
<p>其它命令：<br>    查看服务的依赖关系：<br>    systemctl list-dependencies name.service</p>
<p>杀掉进程：<br>    systemctl kill unitname</p>
<h3 id="服务状态"><a href="#服务状态" class="headerlink" title="服务状态"></a>服务状态</h3><p>systemctl list-unit-files –type service –all显示状态<br>loaded:Unit配置文件已处理<br>active(running):一次或多次持续处理的运行<br>active(exited):成功完成一次性的配置<br>active(waiting):运行中,等待一个事件<br>inactive:不运行<br>enabled:开机启动<br>disabled:开机不启动<br>static:开机不启动,但可被另一个启用的服务激活</p>
<h3 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h3><p>显示所有单元状态<br>    systemctl 或 systemctl list-units<br>只显示服务单元的状态<br>    systemctl –type=service<br>显示sshd服务单元<br>    systemctl –l status sshd.service<br>验证sshd服务当前是否活动<br>    systemctl is-active sshd<br>启动,停止和重启sshd服务<br>    systemctl start sshd.service<br>    systemctl stop sshd.service<br>    systemctl restart sshd.service</p>
<p>重新加载配置<br>    systemctl reload sshd.service<br>列出活动状态的所有服务单元<br>    systemctl list-units –type=service<br>列出所有服务单元<br>    systemctl list-units –type=service –all<br>查看服务单元的启用和禁用状态<br>    systemctl list-unit-files –type=service<br>列出失败的服务<br>    systemctl –failed –type=service</p>
<p>列出依赖的单元<br>    systemctl list-dependencies sshd<br>验证sshd服务是否开机启动<br>    systemctl is-enabled sshd<br>禁用network,使之不能自动启动,但手动可以<br>    systemctl disable network<br>启用network<br>    systemctl enable network<br>禁用network,使之不能手动或自动启动<br>    systemctl mask network<br>启用network<br>    systemctl unmask network</p>
<h3 id="service-unit文件格式"><a href="#service-unit文件格式" class="headerlink" title="service unit文件格式"></a>service unit文件格式</h3><p>/etc/systemd/system：系统管理员和用户使用/usr/lib/systemd/system：发行版打包者使用<br>以 “#” 开头的行后面的内容会被认为是注释<br>相关布尔值,1、yes、on、true 都是开启,0、no、off、false 都是关闭<br>时间单位默认是秒,所以要用毫秒（ms）分钟（m）等须显式说明<br>service unit file文件通常由三部分组成：<br>    [Unit]：定义与Unit类型无关的通用选项；用于提供unit的描述信息、unit行为及依赖关系等<br>    [Service]：与特定类型相关的专用选项；此处为Service类型<br>    [Install]：定义由”systemctl enable”以及”systemctl disable”命令在实现服务启用或禁用时用到的一些选项</p>
<p>Unit段的常用选项：<br>Description：描述信息<br>After：定义unit的启动次序,表示当前unit应该晚于哪些unit启动,其功能与Before相反<br>Requires：依赖到的其它units,强依赖,被依赖的units无法激活时,当前unit也无法激活<br>Wants：依赖到的其它units,弱依赖<br>Conflicts：定义units间的冲突关系</p>
<p>Service段的常用选项：<br>Type：定义影响ExecStart及相关参数的功能的unit进程启动类型<br>• simple：默认值,这个daemon主要由ExecStart接的指令串来启动,启动后常驻于内存中<br>• forking：由ExecStart启动的程序透过spawns延伸出其他子程序来作为此daemon的主要服务.原生父程序在启动结束后就会终止<br>• oneshot：与simple类似,不过这个程序在工作完毕后就结束了,不会常驻在内存中<br>• dbus：与simple类似,但这个daemon必须要在取得一个D-Bus的名称后,才会继续运作.因此通常也要同时设定BusNname= 才行<br>• notify：在启动完成后会发送一个通知消息.还需要配合 NotifyAccess 来让Systemd 接收消息<br>• idle：与simple类似,要执行这个daemon必须要所有的工作都顺利执行完毕后才会执行.这类的daemon通常是开机到最后才执行即可的服务</p>
<p>EnvironmentFile：环境配置文件<br>ExecStart：指明启动unit要运行命令或脚本的绝对路径<br>ExecStartPre： ExecStart前运行<br>ExecStartPost： ExecStart后运行<br>ExecStop：指明停止unit要运行的命令或脚本<br>Restart：当设定Restart=1 时,则当次daemon服务意外终止后,会再次自动启动此服务</p>
<p>Install段的常用选项：<br>• Alias：别名,可使用systemctl command Alias.service<br>• RequiredBy：被哪些units所依赖,强依赖<br>• WantedBy：被哪些units所依赖,弱依赖<br>• Also：安装本服务的时候还要安装别的相关服务<br>注意：对于新创建的unit文件,或者修改了的unit文件,要通知systemd重载此配置文件,而后可以选择重启<br>    systemctl daemon-reload</p>
<h3 id="服务Unit文件示例"><a href="#服务Unit文件示例" class="headerlink" title="服务Unit文件示例:"></a>服务Unit文件示例:</h3><p>vim /etc/systemd/system/bak.service<br>[Unit]<br>Description=backup /etc<br>Requires=atd.service<br>[Service]<br>Type=simple<br>ExecStart=/bin/bash -c “echo /testdir/bak.sh|at now”<br>[Install]<br>WantedBy=multi-user.target<br>systemctl daemon-reload<br>systemctl start bak</p>
<h3 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h3><p>target units：<br>    unit配置文件：.target<br>    ls /usr/lib/systemd/system/*.target<br>    systemctl list-unit-files –type target –all<br>运行级别：<br>    0 ==&gt; runlevel0.target, poweroff.target<br>    1 ==&gt; runlevel1.target, rescue.target<br>    2 ==&gt; runlevel2.target, multi-user.target<br>    3 ==&gt; runlevel3.target, multi-user.target<br>    4 ==&gt; runlevel4.target, multi-user.target<br>    5 ==&gt; runlevel5.target, graphical.target<br>    6 ==&gt; runlevel6.target, reboot.target<br>查看依赖性：<br>    systemctl list-dependencies graphical.target</p>
<p>级别切换：init N ==&gt; systemctl isolate name.target<br>    systemctl isolate multi-user.target<br>    注：只有/lib/systemd/system/*.target文件中AllowIsolate=yes 才能切换(修改文件需执行systemctl daemon-reload才能生效)<br>查看target：<br>    runlevel :who -r<br>    systemctl list-units –type target<br>获取默认运行级别：<br>    /etc/inittab ==&gt; systemctl get-default<br>修改默认级别：<br>/etc/inittab ==&gt; systemctl set-default name.target<br>    systemctl set-default multi-user.target<br>    ls –l /etc/systemd/system/default.target</p>
<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><p>切换至紧急救援模式：<br>    systemctl rescue<br>切换至emergency模式：<br>    systemctl emergency<br>其它常用命令：<br>    传统命令init,poweroff,halt,reboot都成为<br>    systemctl的软链接<br>    关机：systemctl halt、systemctl poweroff<br>    重启：systemctl reboot<br>    挂起：systemctl suspend<br>    休眠：systemctl hibernate<br>    休眠并挂起：systemctl hybrid-sleep</p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 启动和内核管理(二)</title>
    <url>/Linux-%E5%90%AF%E5%8A%A8%E5%92%8C%E5%86%85%E6%A0%B8%E7%AE%A1%E7%90%86-%E4%BA%8C/</url>
    <content><![CDATA[<h3 id="grub-legacy"><a href="#grub-legacy" class="headerlink" title="grub legacy"></a>grub legacy</h3><p>CentOS 6启动流程：<br>POST –&gt; Boot Sequence(BIOS) –&gt; Boot Loader –&gt; Kernel(ramdisk)<br>–&gt; rootfs –&gt; switchroot –&gt; /sbin/init –&gt;(/etc/inittab, /etc/init/*.conf) –&gt; 设定默认运行级别 –&gt; 系统初始化脚本rc.sysinit –&gt; 关闭或启动对应级别的服务 –&gt; 启动终端<br>grub: GRand Unified Bootloader<br>    grub 0.97: grub legacy<br>    grub 2.x: grub2<br>    grub legacy:<br>        stage1: mbr<br>        stage1_5: mbr之后的扇区,让stage1中的bootloader能识别stage2所在的分区上的文件系统<br>        stage2：磁盘分区(/boot/grub/)</p>
<p>配置文件：/boot/grub/grub.conf &lt;– /etc/grub.conf<br>stage2及内核等通常放置于一个基本磁盘分区<br>功用：<br>(1) 提供启动菜单、并提供交互式接口<br>    a：内核参数<br>    e: 编辑模式,用于编辑菜单<br>    c: 命令模式,交互式接口<br>(2) 加载用户选择的内核或操作系统<br>    允许传递参数给内核<br>    可隐藏启动菜单<br>(3) 为菜单提供了保护机制<br>    为编辑启动菜单进行认证<br>    为启用内核或操作系统进行认证</p>
<p>grub的命令行接口<br>    help: 获取帮助列表<br>    help KEYWORD: 详细帮助信息<br>    find (hd#,#)/PATH/TO/SOMEFILE：<br>    root (hd#,#)<br>    kernel /PATH/TO/KERNEL_FILE: 设定本次启动时用到的内核文件；额外还可添加许多内核支持使用的cmdline参数<br>    例如：max_loop=100 selinux=0 init=/path/to/init<br>    initrd /PATH/TO/INITRAMFS_FILE: 设定为选定的内核提供额外文件的ramdisk<br>    boot: 引导启动选定的内核<br> cat /proc/cmdline 内核参数<br> 内核参数文档:/usr/share/doc/kernel-doc-.6.32/Documentation/kernelparameters.txt</p>
<p>识别硬盘设备<br>    (hd#,#)<br>    hd#: 磁盘编号,用数字表示；从0开始编号<br>    #: 分区编号,用数字表示: 从0开始编号<br>    (hd0,0) 第一块硬盘,第一个分区<br>手动在grub命令行接口启动系统<br>    grub&gt; root (hd#,#)<br>    grub&gt; kernel /vmlinuz-VERSION-RELEASE ro root=/dev/DEVICE<br>    grub&gt; initrd /initramfs-VERSION-RELEASE.img<br>    grub&gt; boot</p>
<h3 id="grub-安装"><a href="#grub-安装" class="headerlink" title="grub 安装"></a>grub 安装</h3><p>安装grub：<br>    (1) grub-install<br>    安装grub stage1和stage1_5到/dev/DISK磁盘上,并复制GRUB相关文件到 DIR/boot目录下<br>    grub-install –root-directory=DIR /dev/DISK<br>    (2) grub<br>    grub&gt; root (hd#,#)<br>    grub&gt; setup (hd#)</p>
<h3 id="grub-legacy配置文件"><a href="#grub-legacy配置文件" class="headerlink" title="grub legacy配置文件"></a>grub legacy配置文件</h3><p>配置文件：/boot/grub/grub.conf<br>default=#: 设定默认启动的菜单项；落单项(title)编号从0开始<br>timeout=#：指定菜单项等待选项选择的时长<br>splashimage=(hd#,#)/PATH/XPM_FILE：菜单背景图片文件路径<br>password [–md5] STRING: 启动菜单编辑认证<br>hiddenmenu：隐藏菜单<br>title TITLE：定义菜单项”标题”, 可出现多次<br>root (hd#,#)：查找stage2及kernel文件所在设备分区；为grub的根<br>kernel /PATH/TO/VMLINUZ_FILE [PARAMETERS]：启动的内核<br>initrd /PATH/TO/INITRAMFS_FILE: 内核匹配的ramfs文件<br>password [–md5|–encrypted ] STRING: 启动选定的内核或操作系统时进行认证</p>
<h3 id="自制linux系统"><a href="#自制linux系统" class="headerlink" title="自制linux系统"></a>自制linux系统</h3><p>分区并创建文件系统<br>    fdisk /dev/sdb<br>    分两个必要的分区<br>    /dev/sdb1对应/boot /dev/sdb2对应根 /<br>    mkfs.ext4 /dev/sdb1<br>    mkfs.ext4 /dev/sdb2<br>挂载boot<br>    mkdir /mnt/boot 子目录必须为boot<br>    mount /dev/sdb1 /mnt/boot<br>安装grub<br>    grub-install –root-directory=/mnt /dev/sdb</p>
<p>恢复内核和initramfs文件<br>    cp /boot/vmlinuz-2.6.32-642.el6.x86_64 /mnt/boot/<br>    cp /boot/initramfs-2.6.32-642.el6.x86_64.img /mnt/boot<br>建立grub.conf<br>    vim /mnt/boot/grub.conf<br>        title wanglinux<br>        root (hd0,0)<br>        kernel /vmlinuz-2.6.32-642.el6.x86_64 root=/dev/sda2 selinux=0 init=/bin/bash<br>        initrd /initramfs-2.6.32-642.el6.x86_64.img<br>chroot /mnt/sysroot</p>
<p>创建一级目录<br>    mkdir /mnt/sysroot<br>    mount /dev/sdb2 /mnt/sysroot<br>    mkdir –pv<br>/mnt/sysroot/{etc,lib,lib64,bin,sbin,tmp,var,usr,sys,proc,opt,home,root,boot,dev,mnt,media}<br>复制bash和相关库文件<br>复制相关命令及相关库文件<br>    如：ifconfig,insmod,ping,mount,ls,cat,df,lsblk,blkid等</p>
<h3 id="救援环境"><a href="#救援环境" class="headerlink" title="救援环境"></a>救援环境</h3><p>在根文件系统无法使用时需要,如/bin/mount删除<br>对系统没有特殊要求<br>从光盘引导（boot.iso或者安装光盘#1）<br>从USB盘（可由boot.iso制作）引导</p>
<p>文件系统重组<br>Anaconda将会询问是否应该挂载文件系统<br>/mnt/sysimage/*<br>/mnt/stage2<br>$PATH包括硬盘的目录<br>文件系统节点<br>提供系统特定的设备文件<br>mknod了解major/minor </p>
<h3 id="系统配置文件丢失修复"><a href="#系统配置文件丢失修复" class="headerlink" title="系统配置文件丢失修复"></a>系统配置文件丢失修复</h3><p>系统在引导期间,很重要的一个过程就是init进程读取其配置文件/etc/inittab,启动系统基本服务程序及默认运行级别的服务程序完成系统引导,如果/etc/inittab误删除或修改错误,Linux将无法正常启动.此时,只有通过救援模式才可以解决此类问题.<br>• 有备份文件的回复方法<br>• 没有备份文件的恢复办法</p>
<h4 id="有备份文件的恢复办法："><a href="#有备份文件的恢复办法：" class="headerlink" title="有备份文件的恢复办法："></a>有备份文件的恢复办法：</h4><p>进入救援模式,执行chroot命令后,如果有此文件的备份（强烈建议系统中的重要数据目录,如/etc、/boot等要进行备份）,直接将备份文件拷贝回去,退出重启即可.如果是配置文件修改错误,如比较典型的/boot/grub/grub.conf及/etc/passwd的文件修改错误,也可以直接修正恢复.假设有备份文件/etc/inittab.bak,则在救援模式下执行：<br>    chroot /mnt/sysimage<br>    cp /etc/inittab.bak /etc/inittab</p>
<h4 id="没有备份文件的恢复办法"><a href="#没有备份文件的恢复办法" class="headerlink" title="没有备份文件的恢复办法"></a>没有备份文件的恢复办法</h4><p>如果一些配置文件丢失或软件误删除,且无备份,可以通过重新安装软件包来恢复,首先查找到/etc/inittab属于哪一个RPM包<br>    chroot /mnt/sysimage</p>
<pre><code>rpm -qf /etc/inittab 查询到此文件来自initscripts包

exit 退出chroot模式

mount /dev/sr0 /mnt/source 挂载存放RPM包的安装光盘

rpm -ivh --replacepkgs | force /mnt/source/Packages/</code></pre><p>initscripts-9.03.49-1.el6.centos.x86_64.rpm CentOS6系统的要修复的硬盘系统的根目录在/mnt/sysimage下,需要使用–root选项指定其位置.覆盖安装/etc/inittab文件所在的RPM包,使用选项”—replacepkgs 或—force 表示覆盖安装</p>
<p>如果想只提取RPM包中的/etc/inittab文件进行恢复,可以在进入救援模式后,执行命令：</p>
<pre><code>rpm2cpio /mnt/source/Packages/initscripts-9.03.49-1.el6.centos.x86_64.rpm| cpio -idv ./etc/inittab

cp etc/inittab /mnt/sysimage/etc</code></pre><p>注意此命令执行时不能将文件直接恢复至/etc目录,只能提取到当前目录下,且恢复的文件名称所在路径要写完整的路径.提取文件成功后,将其复制到根分区所在的/mnt/sysimage目录下相应位置即可</p>
<h3 id="proc-目录"><a href="#proc-目录" class="headerlink" title="/proc 目录"></a>/proc 目录</h3><p>/proc目录：</p>
<p>内核把自己内部状态信息及统计信息,以及可配置参数通过proc伪文件系统加以输出</p>
<p>参数：</p>
<pre><code>只读：输出信息

可写：可接受用户指定&quot;新值&quot;来实现对内核某功能或特性的配置</code></pre><p>/proc/sys<br>    (1) sysctl命令用于查看或设定此目录中诸多参数</p>
<pre><code>sysctl -w path.to.parameter=VALUE

sysctl -w kernel.hostname=mail.magedu.com

(2) echo命令通过重定向方式也可以修改大多数参数的值

echo &quot;VALUE&quot; &gt; /proc/sys/path/to/parameter

echo &quot;websrv&quot; &gt; /proc/sys/kernel/hostname</code></pre><h3 id="sysctl命令"><a href="#sysctl命令" class="headerlink" title="sysctl命令"></a>sysctl命令</h3><p>sysctl命令：<br>    默认配置文件：/etc/sysctl.conf<br>    (1) 设置某参数<br>        sysctl -w parameter=VALUE<br>    (2) 通过读取配置文件设置参数<br>        sysctl -p [/path/to/conf_file]<br>    (3) 查看所有生效参数<br>        sysctl -a<br>常用的几个参数：<br>    net.ipv4.ip_forward<br>    net.ipv4.icmp_echo_ignore_all<br>    vm.drop_caches</p>
<h3 id="sys-目录"><a href="#sys-目录" class="headerlink" title="/sys 目录"></a>/sys 目录</h3><p>/sys目录：<br>    sysfs：为用户使用的伪文件系统,输出内核识别出的各硬件设备的相关属性信息,也有内核对硬件特性的设定信息；有些参数是可以修改的,用于调整硬件工作特性<br>    udev通过此路径下输出的信息动态为各设备创建所需要设备文件,udev是运行用户空间程序<br>    专用工具：udevadmin, hotplug<br>    udev为设备创建设备文件时,会读取其事先定义好的规则文件,一般在/etc/udev/rules.d及/usr/lib/udev/rules.d目录下</p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 中的进程和计划任务(二)</title>
    <url>/Linux-%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1-%E4%BA%8C/</url>
    <content><![CDATA[<h2 id="Linux-中系统资源的管理"><a href="#Linux-中系统资源的管理" class="headerlink" title="Linux 中系统资源的管理"></a>Linux 中系统资源的管理</h2><h3 id="进程管理工具"><a href="#进程管理工具" class="headerlink" title="进程管理工具"></a>进程管理工具</h3><h4 id="top-命令"><a href="#top-命令" class="headerlink" title="top 命令"></a>top 命令</h4><p>top:有许多内置命令 </p>
<p>​    排序: </p>
<p>​        P:以占据的CPU百分比,%CPU </p>
<p>​        M:占据内存百分比,%MEM </p>
<p>​        T:累积占据CPU时长,TIME+ </p>
<p>​    首部信息显示: </p>
<p>​        uptime信息:l命令 </p>
<p>​        tasks及cpu信息:t命令 </p>
<p>​        cpu分别显示:1 (数字) </p>
<p>​        memory信息:m命令 </p>
<p>​    退出命令:q </p>
<p>​    修改刷新时间间隔:s </p>
<p>​    终止指定进程:k </p>
<p>​    保存文件:W </p>
<h4 id="top-命令栏位简介"><a href="#top-命令栏位简介" class="headerlink" title="top 命令栏位简介"></a>top 命令栏位简介</h4><p>​    us:用户空间 </p>
<p>​    sy:内核空间 </p>
<p>​    ni:调整nice时间 </p>
<p>​    id:空闲 </p>
<p>​    wa:等待IO时间 </p>
<p>​    hi:硬中断 </p>
<p>​    si:软中断(模式切换) </p>
<p>​    st:虚拟机偷走的时间 </p>
<h4 id="top命令扩展"><a href="#top命令扩展" class="headerlink" title="top命令扩展"></a>top命令扩展</h4><p>选项: </p>
<p>​    -d # 指定刷新时间间隔，默认为3秒 </p>
<p>​    -b 全部显示所有进程 </p>
<p>​    -n # 刷新多少次后退出 </p>
<p>​    -H 线程模式，示例:top -H -p `pidof mysqld`</p>
<p>htop命令:EPEL源 </p>
<p>​    选项: </p>
<p>​        -d #: 指定延迟时间；</p>
<p>​        -u UserName: 仅显示指定用户的进程 </p>
<p>​        -s COLUME: 以指定字段进行排序 </p>
<p>​    子命令: </p>
<p>​        s:跟踪选定进程的系统调用 </p>
<p>​        l:显示选定进程打开的文件列表 </p>
<p>​        a:将选定的进程绑定至某指定CPU核心 </p>
<p>​        t:显示进程树 </p>
<hr>
<h3 id="内存空间管理"><a href="#内存空间管理" class="headerlink" title="内存空间管理"></a>内存空间管理</h3><h4 id="查看内存空间的使用状态"><a href="#查看内存空间的使用状态" class="headerlink" title="查看内存空间的使用状态:"></a>查看内存空间的使用状态:</h4><p>free [OPTION] </p>
<p>​    -b 以字节为单位 </p>
<p>​    -m 以MB为单位 </p>
<p>​    -g 以GB为单位 </p>
<p>​    -h 易读格式 </p>
<p>​    -o 不显示-/+buffers/cache行 </p>
<p>​    -t 显示RAM + swap的总和 </p>
<p>​    -s n 刷新间隔为n秒 </p>
<p>​    -c n 刷新n次后即退出 </p>
<p>free命令中参数的意义:</p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/images/post_Linux_Network_1.png" alt=""></p>
<hr>
<h3 id="内存工具"><a href="#内存工具" class="headerlink" title="内存工具"></a>内存工具</h3><h4 id="vmstat命令"><a href="#vmstat命令" class="headerlink" title="vmstat命令"></a>vmstat命令</h4><p>vmstat命令:</p>
<p>​    查看虚拟内存信息 </p>
<p>​    vmstat [options]/[delay [count]] </p>
<p>​    vmstat 2 5  </p>
<p><strong>vmstat参数:</strong></p>
<p>procs: </p>
<p>​    r:可运行(正运行或等待运行)进程的个数，和核心数有关 </p>
<p>​    b:处于不可中断睡眠态的进程个数(被阻塞的队列的长度) </p>
<p>memory: </p>
<p>​    swpd: 交换内存的使用总量 </p>
<p>​    free:空闲物理内存总量 </p>
<p>​    buffer:用于buffer的内存总量 </p>
<p>​    cache:用于cache的内存总量 </p>
<p>swap: </p>
<p>​    si:从磁盘交换进内存的数据速率(kb/s) </p>
<p>​    so:从内存交换至磁盘的数据速率(kb/s) 内存工具 </p>
<p>io: </p>
<p>​    bi:从块设备读入数据到系统的速率(kb/s) </p>
<p>​    bo: 保存数据至块设备的速率 </p>
<p>system: </p>
<p>​    in: interrupts 中断速率，包括时钟 </p>
<p>​    cs: context switch 进程切换速率 </p>
<p>cpu: </p>
<p>​    us:Time spent running non-kernel code </p>
<p>​    sy: Time spent running kernel code </p>
<p>​    id: Time spent idle. Linux 2.5.41前,包括IO-wait time. </p>
<p>​    wa: Time spent waiting for IO. 2.5.41前，包括in idle. </p>
<p>​    st: Time stolen from a virtual machine. 2.6.11前, unknown. </p>
<p>选项:</p>
<p>​     -s: 显示内存的统计数据 </p>
<h4 id="其他内存工具"><a href="#其他内存工具" class="headerlink" title="其他内存工具"></a>其他内存工具</h4><p>iostat:统计CPU和设备IO信息 </p>
<p>​    示例:iostat 1 10 </p>
<p>pmap命令:进程对应的内存映射 </p>
<p>pmap [options] pid […] </p>
<p>​    -x: 显示详细格式的信息 </p>
<p>​    示例:pmap 1 </p>
<p>另外一种实现: </p>
<p>​    cat /proc/PID/maps </p>
<hr>
<h3 id="系统监控工具"><a href="#系统监控工具" class="headerlink" title="系统监控工具"></a>系统监控工具</h3><h4 id="glances-命令"><a href="#glances-命令" class="headerlink" title="glances 命令"></a>glances 命令</h4><p>glances属于第三方EPEL源中的工具</p>
<p>glances [-bdehmnrsvyz1]/[-B bind]/[-c server]/[-C conffile]/[-p port]/[-P password]/[– password]/[-t refresh]/[-f file]/[-o output]</p>
<p>内建命令: </p>
<p>a Sort processes automatically        l Show/hide logs </p>
<p>c Sort processes by CPU%             b Bytes or bits for network I/O </p>
<p>m Sort processes by MEM%         w Delete warning logs </p>
<p>p Sort processes by name             x Delete warning and critical logs </p>
<p>i Sort processes by I/O rate         1 Global CPU or per-CPU stats </p>
<p>d Show/hide disk I/O stats         h Show/hide this help screen </p>
<p>f Show/hide file system stats         t View network I/O as combination </p>
<p>n Show/hide network stats         u View cumulative network I/O </p>
<p>s Show/hide sensors stats             q Quit (Esc and Ctrl-C also work) </p>
<p>y Show/hide hddtemp stats </p>
<p>部分选项解释:</p>
<p>​    -b: 以Byte为单位显示网卡数据速率 </p>
<p>​    -d: 关闭磁盘I/O模块 </p>
<p>​    -f /path/to/somefile: 设定输入文件位置 </p>
<p>​    -o {HTML|CSV}:输出格式 </p>
<p>​    -m: 禁用mount模块 </p>
<p>​    -n: 禁用网络模块 </p>
<p>​    -t #: 延迟时间间隔 </p>
<p>​    -1:每个CPU的相关数据单独显示 </p>
<p>*<em>C/S模式下运行glances命令 *</em></p>
<p>服务器模式: </p>
<p>​    glances -s -B IPADDR </p>
<p>​    IPADDR: 指明监听的本机哪个地址 </p>
<p>客户端模式: </p>
<p>​    glances -c IPADDR </p>
<p>​    IPADDR:要连入的服务器端地址 </p>
<h4 id="dstat-命令"><a href="#dstat-命令" class="headerlink" title="dstat 命令"></a>dstat 命令</h4><p>dstat命令:系统资源统计,代替vmstat,iostat,需要使用yum安装 </p>
<p>dstat [-afv]/[options..]/[delay [count]] </p>
<p>​    -c 显示cpu相关信息 </p>
<p>​    -C #,#,…,total </p>
<p>​    -d 显示disk相关信息 </p>
<p>​    -D total,sda,sdb,… </p>
<p>​    -g 显示page相关统计数据 </p>
<p>​    -m 显示memory相关统计数据 </p>
<p>​    -n 显示network相关统计数据 </p>
<p>​    -p 显示process相关统计数据 </p>
<p>​    -r 显示io请求相关的统计数据 </p>
<p>​    -s 显示swapped相关的统计数据 </p>
<p>​    –tcp </p>
<p>​    –udp </p>
<p>​    –unix </p>
<p>​    –raw </p>
<p>​    –socket </p>
<p>​    –ipc </p>
<p>​    –top-cpu:显示最占用CPU的进程 </p>
<p>​    –top-io: 显示最占用io的进程 </p>
<p>​    –top-mem: 显示最占用内存的进程 </p>
<p>​    –top-latency: 显示延迟最大的进程 </p>
<h4 id="iotop"><a href="#iotop" class="headerlink" title="iotop"></a>iotop</h4><p>iotop命令是一个用来监视磁盘I/O使用状况的top类工具iotop具有与top相似的UI，其中包括 PID、用户、I/O、进程等相关信息，可查看每个进程是如何使用IO </p>
<p>iotop输出 </p>
<p>​    第一行:Read和Write速率总计 </p>
<p>​    第二行:实际的Read和Write速率 </p>
<p>​    第三行:</p>
<p>​        参数如下: </p>
<p>​            线程ID(按p切换为进程ID) </p>
<p>​            优先级 </p>
<p>​            用户 </p>
<p>​            磁盘读速率 </p>
<p>​            磁盘写速率 </p>
<p>​            swap交换百分比 </p>
<p>​            IO等待所占的百分比 </p>
<p>​            线程/进程命令 </p>
<p><strong>iotop 常用参数</strong></p>
<p>​    -o, –only只显示正在产生I/O的进程或线程，除了传参，可以在运行过程中按o 生效 </p>
<p>​    -b, –batch非交互模式，一般用来记录日志 </p>
<p>​    -n NUM, –iter=NUM设置监测的次数，默认无限。在非交互模式下很有用 </p>
<p>​    -d SEC, –delay=SEC设置每次监测的间隔，默认1秒，接受非整形数据例如1.1 </p>
<p>​    -p PID, –pid=PID指定监测的进程/线程 </p>
<p>​    -u USER, –user=USER指定监测某个用户产生的I/O </p>
<p>​    -P, –processes仅显示进程，默认iotop显示所有线程 </p>
<p>​    -a, –accumulated显示累积的I/O，而不是带宽 </p>
<p>​    -k, –kilobytes使用kB单位，而不是对人友好的单位。在非交互模式下，脚本 编程有用 </p>
<p>​    -t, –time 加上时间戳，非交互非模式 </p>
<p>​    -q, –quiet 禁止头几行，非交互模式，有三种指定方式 </p>
<p>​    -q 只在第一次监测时显示列名 </p>
<p>​    -qq 永远不显示列名 </p>
<p>​    -qqq 永远不显示I/O汇总 </p>
<p><strong>iotop 交互按键</strong></p>
<p>​    left和right方向键:改变排序 </p>
<p>​    r:反向排序 </p>
<p>​    o:切换至选项–only </p>
<p>​    p:切换至–processes选项 </p>
<p>​    a:切换至–accumulated选项 </p>
<p>​    q:退出 </p>
<p>​    i:改变线程的优先级 </p>
<h4 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h4><p>Lsof:list open files查看当前系统文件的工具。在linux环境下，一切皆文件，用户通 过文件不仅可以访问常规数据，还可以访问网络连接和硬件如传输控制协议 (TCP) 和 用户数据报协议 (UDP)套接字等，系统在后台都为该应用程序分配了一个文件描述符</p>
<p><strong>命令参数</strong> </p>
<p>​    -a:列出打开文件存在的进程 </p>
<p>​    -c&lt;进程名&gt;:列出指定进程所打开的文件 </p>
<p>​    -g:列出GID号进程详情 </p>
<p>​    -d&lt;文件号&gt;:列出占用该文件号的进程 </p>
<p>​    +d&lt;目录&gt;:列出目录下被打开的文件 </p>
<p>​    +D&lt;目录&gt;:递归列出目录下被打开的文件 </p>
<p>​    -n&lt;目录&gt;:列出使用NFS的文件 </p>
<p>​    -i&lt;条件&gt;:列出符合条件的进程(4、6、协议、:端口、 @ip ) </p>
<p>​    -p&lt;进程号&gt;:列出指定进程号所打开的文件 </p>
<p>​    -u:列出UID号进程详情 </p>
<p>​    -h:显示帮助信息 </p>
<p>​    -v:显示版本信息。 </p>
<p>​    -n: 不反向解析网络名字 </p>
<p><strong>进程管理</strong></p>
<p>查看由登陆用户启动而非系统启动的进程 </p>
<p>​    lsof /dev/pts1 </p>
<p>指定进程号，可以查看该进程打开的文件 </p>
<p>​    lsof -p 9527 </p>
<p><strong>文件管理</strong> </p>
<p>查看指定程序打开的文件 </p>
<p>​    lsof -c httpd </p>
<p>查看指定用户打开的文件 </p>
<p>​    lsof -u root | more </p>
<p>查看指定目录下被打开的文件 </p>
<p>​    lsof +D /var/log/ </p>
<p>​    lsof +d /var/log/ </p>
<p>​    参数+D为递归列出目录下被打开的文件，参数+d为列出目录下被打开的文件 </p>
<p><strong>网络管理</strong> </p>
<p>查看所有网络连接 </p>
<p>​    lsof -i –n lsof <a href="mailto:-i@127.0.0.1">-i@127.0.0.1</a> </p>
<p>​    通过参数-i查看网络连接的情况，包括连接的ip、端口等以及一些服务的连接情况，例如: sshd等。也可以通过指定ip查看该ip的网络连接情况 </p>
<p>查看端口连接情况 </p>
<p>​    lsof -i :80 -n </p>
<p>​    通过参数-i:端口可以查看端口的占用情况，-i参数还有查看协议，ip的连接情况等 </p>
<p>查看指定进程打开的网络连接 </p>
<p>​    lsof -i –n -a -p 9527 </p>
<p>​    参数-i、-a、-p等，-i查看网络连接情况，-a查看存在的进程，-p指定进程 </p>
<p>查看指定状态的网络连接 </p>
<p>​    lsof -n -P -i TCP -s TCP:ESTABLISHED </p>
<p>​    -n:no host names, -P:no port names,-i TCP指定协议，-s指定协议状态通过多个参数可以 清晰的查看网络连接情况、协议连接情况等 </p>
<p><strong>恢复删除文件</strong> </p>
<p>​    lsof |grep /var/log/messages </p>
<p>​    rm -f /var/log/messages </p>
<p>​    lsof |grep /var/log/messages </p>
<p>​    cat /proc/653/fd/6 </p>
<p>​    cat /proc/653/fd/6 &gt; /var/log/messages </p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 启动和内核管理(五)</title>
    <url>/Linux-%E5%90%AF%E5%8A%A8%E5%92%8C%E5%86%85%E6%A0%B8%E7%AE%A1%E7%90%86-%E4%BA%94/</url>
    <content><![CDATA[<h3 id="CentOS7-引导顺序"><a href="#CentOS7-引导顺序" class="headerlink" title="CentOS7 引导顺序"></a>CentOS7 引导顺序</h3><p>UEFi或BIOS初始化,运行POST开机自检<br>选择启动设备<br>引导装载程序, centos7是grub2<br>加载装载程序的配置文件：<br>    /etc/grub.d/<br>    /etc/default/grub<br>    /boot/grub2/grub.cfg<br>加载initramfs驱动模块<br>加载内核选项<br>内核初始化,centos7使用systemd代替init<br>执行initrd.target所有单元,包括挂载/etc/fstab<br>从initramfs根文件系统切换到磁盘根目录<br>systemd执行默认target配置,配置文件/etc/systemd/system/default.target</p>
<p>systemd执行sysinit.target初始化系统及basic.target准备操作系统<br>systemd启动multi-user.target下的本机与服务器服务<br>systemd执行multi-user.target下的/etc/rc.d/rc.local<br>Systemd执行multi-user.target下的getty.target及登录服务<br>systemd执行graphical需要的服务</p>
<h3 id="设置内核参数"><a href="#设置内核参数" class="headerlink" title="设置内核参数"></a>设置内核参数</h3><p>设置内核参数,只影响当次启动<br>启动时,在linux16行后添加systemd.unit=desired.target<br>systemd.unit=emergency.target<br>systemd.unit=rescue.target<br>rescue.target 比emergency 支持更多的功能,例如日志等<br>systemctl default 进入默认target</p>
<h3 id="启动排错"><a href="#启动排错" class="headerlink" title="启动排错"></a>启动排错</h3><p>文件系统损坏<br>先尝试自动修复,失败则进入emergency shell,提示用户修复<br>在/etc/fstab不存在对应的设备和UUID<br>等一段时间,如不可用,进入emergency shell<br>在/etc/fstab不存在对应挂载点<br>systemd 尝试创建挂载点,否则提示进入emergency shell.<br>在/etc/fstab不正确的挂载选项<br>提示进入emergency shell</p>
<h4 id="破解CentOS7的root口令方法一"><a href="#破解CentOS7的root口令方法一" class="headerlink" title="破解CentOS7的root口令方法一"></a>破解CentOS7的root口令方法一</h4><p>启动时任意键暂停启动<br>按e键进入编辑模式<br>将光标移动linux16开始的行,添加内核参数rd.break<br>按ctrl-x启动<br>mount –o remount,rw /sysroot<br>chroot /sysroot<br>passwd root<br>touch /.autorelabel<br>exit<br>reboot</p>
<h3 id="破解CentOS7的root口令方法二"><a href="#破解CentOS7的root口令方法二" class="headerlink" title="破解CentOS7的root口令方法二"></a>破解CentOS7的root口令方法二</h3><p>启动时任意键暂停启动<br>按e键进入编辑模式<br>将光标移动linux16开始的行,改为rw init=/sysroot/bin/sh<br>按ctrl-x启动<br>chroot /sysroot<br>passwd root<br>touch /.autorelabel<br>exit<br>reboot</p>
<h3 id="修复GRUB2"><a href="#修复GRUB2" class="headerlink" title="修复GRUB2"></a>修复GRUB2</h3><p>GRUB”the Grand Unified Bootloader”<br>引导提示时可以使用命令行界面<br>可从文件系统引导<br>主要配置文件 /boot/grub2/grub.cfg<br>修复配置文件<br>grub2-mkconfig &gt; /boot/grub2/grub.cfg<br>修复grub<br>grub2-install /dev/sda BIOS环境<br>grub2-install UEFI环境<br>调整默认启动内核<br>    vim /etc/default/grub<br>    GRUB_DEFAULT=0</p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 基础和帮助</title>
    <url>/Linux-%E5%9F%BA%E7%A1%80%E5%92%8C%E5%B8%AE%E5%8A%A9/</url>
    <content><![CDATA[<h3 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h3><h4 id="root-用户"><a href="#root-用户" class="headerlink" title="root 用户"></a>root 用户</h4><p>一个特殊的管理帐户 </p>
<p>也被称为超级用户 </p>
<p>root已接近完整的系统控制 </p>
<p>对系统损害几乎有无限的能力 </p>
<p>除非必要,不要登录为 root </p>
<h4 id="普通-非特权-用户"><a href="#普通-非特权-用户" class="headerlink" title="普通( 非特权 )用户"></a>普通( 非特权 )用户</h4><p>权限有限 </p>
<p>造成损害的能力比较有限 </p>
<hr>
<h3 id="终端terminal"><a href="#终端terminal" class="headerlink" title="终端terminal"></a>终端terminal</h3><p>设备终端 键盘鼠标显示器</p>
<p>物理终端( /dev/console ) 控制台console </p>
<p>虚拟终端(tty:teletypewriters, /dev/tty# #为[1-6]) tty 可有n个,Ctrl+Alt+F[1-6] </p>
<p>图形终端( /dev/tty7 ) startx, xwindows </p>
<pre><code>CentOS 6: Ctrl + Alt + F7 

CentOS 7: 在哪个终端启动,即位于哪个虚拟终端 </code></pre><p>串行终端( /dev/ttyS# ) ttyS </p>
<p>伪终端( pty:pseudo-tty , /dev/pts/# ) pty, SSH远程连接 </p>
<p>查看当前的终端设备:#tty </p>
<hr>
<h3 id="交互式接口"><a href="#交互式接口" class="headerlink" title="交互式接口"></a>交互式接口</h3><p>交互式接口:启动终端后,在终端设备附加一个交互式应用程序 </p>
<p>GUI:Graphic User Interface </p>
<p>X protocol, window manager, desktop Desktop: GNOME (C, 图形库gtk), KDE (C++,图形库qt) XFCE (轻量级桌面) </p>
<p>CLI:Command Line Interface </p>
<p>shell程序:sh (bourn 史蒂夫·伯恩) csh tcsh ksh (korn) bash (bourn again shell)GPL zsh </p>
<hr>
<h3 id="什么是shell"><a href="#什么是shell" class="headerlink" title="什么是shell"></a>什么是shell</h3><p>Shell 是Linux系统的用户界面,提供了用户与内核进行交互操作的一种接口。 它接收用户输入的命令并把它送入内核去执行 </p>
<p>shell也被称为LINUX的命令解释器(command interpreter) </p>
<p>shell是一种高级程序设计语言 </p>
<hr>
<h3 id="bash-shell"><a href="#bash-shell" class="headerlink" title="bash shell"></a>bash shell</h3><p>GNU Bourne-Again Shell(bash)是GNU计划中重要的工具软件之一,目前也 是 Linux标准的shell,与sh兼容</p>
<p>CentOS默认使用 </p>
<p>显示当前使用的shell </p>
<p><code>echo ${SHELL}</code></p>
<p>显示当前系统使用的所有shell </p>
<p><code>cat /etc/shells</code></p>
<hr>
<h3 id="命令提示符"><a href="#命令提示符" class="headerlink" title="命令提示符"></a>命令提示符</h3><p>命令提示符:prompt </p>
<p><code>[root@localhost ~]#</code></p>
<blockquote>
<p>#管理员     $ 普通用户 </p>
</blockquote>
<p>显示提示符格式 </p>
<p><code>[root@localhost ~]#echo $PS1</code></p>
<p>修改提示符格式 </p>
<p><code>PS1=&quot;\[\e[1;5;41;33m\][\u@\h \W]\\$\[\e[0m\]&quot;</code></p>
<blockquote>
<p>\e \033                 \u 当前用户 </p>
</blockquote>
<blockquote>
<p>\h 主机名简称         \H 主机名 </p>
</blockquote>
<blockquote>
<p>\w 当前工作目录         \W 当前工作目录基名 </p>
</blockquote>
<blockquote>
<p>\t 24小时时间格式     \T 12小时时间格式 ! 命令历史数 </p>
</blockquote>
<blockquote>
<p>\# 开机后命令历史数</p>
</blockquote>
<hr>
<h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><p>输入命令后回车 </p>
<p>提请shell程序找到键入命令所对应的可执行程序或代码,并由其分析后 提交给内核分配资源将其运行起来 </p>
<p>在shell中可执行的命令有两类 </p>
<h4 id="内部命令"><a href="#内部命令" class="headerlink" title="内部命令:"></a>内部命令:</h4><p>由shell自带的,而且通过某命令形式提供 help 内部命令列表 </p>
<p><code>enable cmd</code></p>
<p>启用内部命令 </p>
<p><code>enable –n cmd</code></p>
<p>禁用内部命令 </p>
<p><code>enable –n</code></p>
<p>查看所有禁用的内部命令 </p>
<h4 id="外部命令"><a href="#外部命令" class="headerlink" title="外部命令:"></a>外部命令:</h4><p>在文件系统路径下有对应的可执行程序文件 </p>
<p>查看路径:</p>
<p><code>which -a |--skip-alias</code></p>
<p><code>whereis</code> </p>
<p>区别指定的命令是内部或外部命令 </p>
<p><code>type COMMAND</code></p>
<h4 id="执行外部命令"><a href="#执行外部命令" class="headerlink" title="执行外部命令"></a>执行外部命令</h4><p>Hash缓存表 </p>
<p>系统初始hash表为空,当外部命令执行时,默认会从PATH路径下寻找该命 令,找到后会将这条命令的路径记录到hash表中,当再次使用该命令时,shell解 释器首先会查看hash表,存在将执行之,如果不存在,将会去PATH路径下寻找。 利用hash缓存表可大大提高命令的调用速率 </p>
<p>hash常见用法 </p>
<p><code>hash</code>                 //显示hash缓存 </p>
<p><code>hash –l</code>             //显示hash缓存,可作为输入使用 </p>
<p><code>hash –p path name</code>     //将命令全路径path起别名为name </p>
<p><code>hash –t name</code>         //打印缓存中name的路径</p>
<p> <code>hash –d name</code>         //清除name缓存 </p>
<p><code>hash –r</code>             //清除缓存 </p>
<h4 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h4><p>显示当前shell进程所有可用的命令别名 </p>
<p><code>alias</code></p>
<p>定义别名NAME,其相当于执行命令VALUE </p>
<p><code>alias NAME=&#39;VALUE&#39;</code></p>
<p>在命令行中定义的别名,仅对当前shell进程有效 </p>
<p>如果想永久有效,要定义在配置文件中 </p>
<p>仅对当前用户:</p>
<p><code>~/.bashrc</code> </p>
<p>对所有用户有效:</p>
<p><code>/etc/bashrc</code></p>
<p>编辑配置给出的新配置不会立即生效 </p>
<p>bash进程重新读取配置文件 </p>
<p><code>source /path/to/config_file</code></p>
<p><code>. /path/to/config_file</code></p>
<p>撤消别名:unalias </p>
<p><code>unalias [-a] name [name ...]</code></p>
<p>-a 取消所有别名 </p>
<p>如果别名同原命令同名,如果要执行原命令,可使用 </p>
<p><code>\ALIASNAME</code></p>
<p><code>&quot;ALIASNAME&quot;</code></p>
<p><code>&#39;ALIASNAME&#39;</code></p>
<p><code>command ALIASNAME</code></p>
<p><code>/path/commmand</code></p>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>COMMAND [OPTIONS…][ARGUMENTS…] </p>
<p>选项:用于启用或关闭命令的某个或某些功能 </p>
<p>短选项:-c 例如:-l, -h </p>
<p>长选项:–word 例如:–all, –human-readable </p>
<p>参数:命令的作用对象,比如文件名,用户名等 </p>
<p>注意: </p>
<p>多个选项以及多参数和命令之间使用空白字符分隔 </p>
<p>取消和结束命令执行:Ctrl+c,Ctrl+d </p>
<p>多个命令可以用;符号分开 </p>
<p>一个命令可以用\分成多行 </p>
<h4 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h4><p>Linux的两种时钟 </p>
<p>系统时钟:由Linux内核通过CPU的工作频率进行的 </p>
<p>硬件时钟:主板 </p>
<p>相关命令 </p>
<p>date 显示和设置系统时间 </p>
<p><code>date +%s</code></p>
<p><code>date -d @1509536033</code></p>
<p>hwclock,clock: 显示硬件时钟 </p>
<p>-s, –hctosys 以硬件时钟为准,校正系统时钟 </p>
<p>-w, –systohc 以系统时钟为准,校正硬件时钟 </p>
<p>时区:/etc/localtime </p>
<p>显示日历:</p>
<p>cal –y </p>
<hr>
<h3 id="简单命令"><a href="#简单命令" class="headerlink" title="简单命令"></a>简单命令</h3><p>关机:halt, poweroff </p>
<p>重启:reboot </p>
<pre><code>-f: 强制,不调用shutdown 

-p: 切断电源 </code></pre><p>关机或重启:shutdown </p>
<p>shutdown [OPTION]… TIME [MESSAGE] </p>
<pre><code>-r: reboot 

-h: halt 

-c:cancel </code></pre><p>TIME:无指定,默认相当于 +1 </p>
<pre><code>now: 立刻,相当于+0 

+m: 相对时间表示法,几分钟之后；例如 +3 

hh:mm: 绝对时间表示,指明具体时间 </code></pre><p>用户登录信息查看命令:</p>
<p><code>whoami</code>    : 显示当前登录有效用户 </p>
<p><code>who</code>    : 系统当前所有的登录会话 </p>
<p><code>w</code>        : 系统当前所有的登录会话及所做的操作 </p>
<p>screen命令: </p>
<pre><code>创建新screen会话 

    screen –S [SESSION] 

加入screen会话 

    screen –x [SESSION] 

退出并关闭screen会话 

    exit 

剥离当前screen会话 

    Ctrl+a,d 

显示所有已经打开的screen会话 

    screen -ls 

恢复某screen会话 

    screen -r [SESSION] </code></pre><p>echo命令 </p>
<p>功能:显示字符 </p>
<p>语法:echo [-neE][字符串] </p>
<p>说明:echo会将输入的字符串送往标准输出。输出的字符串间以空白字符隔开, 并在最后加上换行号 </p>
<p>选项: </p>
<pre><code>-E (默认)不支持 \ 解释功能 

-n 不自动换行 

-e 启用 \ 字符的解释功能 </code></pre><p>显示变量 echo “$VAR_NAME” 变量会替换,弱引用 echo ‘$VAR_NAME‘ 变量不会替换,强引用 </p>
<p>启用命令选项-e,若字符串中出现以下字符,则特别加以处理,而不会将它当成 一般文字输出 </p>
<pre><code>\a 发出警告声 

\b 退格键 

\c 最后不加上换行符号 

\n 换行且光标移至行首 

\r 回车,即光标移至行首,但不换行 

\t 插入tab 

\\ 插入\字符 

\0nnn 插入nnn(八进制)所代表的ASCII字符 

    echo -e &apos;\033[43;31;5mmagedu\033[0m&apos; 

\xHH插入HH(十六进制)所代表的ASCII字 </code></pre><h4 id="命令行扩展-被括起来的集合"><a href="#命令行扩展-被括起来的集合" class="headerlink" title="命令行扩展,被括起来的集合"></a>命令行扩展,被括起来的集合</h4><p>命令行扩展:$( ) 或   ``</p>
<p>把一个命令的输出打印给另一个命令的参数 </p>
<p><code>echo &quot;This system&#39;s name is $(hostname) &quot;</code></p>
<p><code>This system&#39;s name is server1.example.com</code></p>
<p>括号扩展:{ } </p>
<p>打印重复字符串的简化形式 </p>
<p><code>echo file{1,3,5}</code></p>
<p>生成 file1 file3 file5 </p>
<p><code>rm -f file{1,3,5}</code></p>
<p><code>echo {1..10}</code></p>
<p><code>echo {a..z}</code></p>
<p><code>echo {000..20..2}</code></p>
<hr>
<h3 id="Tab键补全"><a href="#Tab键补全" class="headerlink" title="Tab键补全"></a>Tab键补全</h3><p>命令补全 </p>
<pre><code>内部命令: 

外部命令:bash根据PATH环境变量定义的路径,自左而右在每个路径搜寻 以给定命令名命名的文件,第一次找到的命令即为要执行的命令 

用户给定的字符串只有一条惟一对应的命令,直接补全 

否则,再次Tab会给出列表 </code></pre><p>路径补全 </p>
<pre><code>把用户给出的字符串当做路径开头,并在其指定上级目录下搜索以指定的字符 串开头的文件名                             

如果惟一:则直接补全 

否则:再次Tab给出列表 </code></pre><h4 id="双击Tab键"><a href="#双击Tab键" class="headerlink" title="双击Tab键"></a>双击Tab键</h4><p>command 2Tab 所有子命令或文件补全 </p>
<p>string2Tab 以string开头命令 </p>
<p>/2Tab 显示所有根目录下一级目录,包括隐藏目录 </p>
<p>./2Tab 当前目录下子目录,包括隐藏目录 </p>
<p>*2Tab 当前目录下子目录,不包括隐藏目录 </p>
<p>~2Tab 所有用户列表 </p>
<p>$2Tab 所有变量 </p>
<p>@2Tab /etc/hosts记录 (centos7不支持) </p>
<p>=2Tab 相当于ls –A (centos7不支持) </p>
<hr>
<h3 id="命令行历史"><a href="#命令行历史" class="headerlink" title="命令行历史"></a>命令行历史</h3><p>保存你输入的命令历史。可以用它来重复执行命令 </p>
<p>登录shell时,会读取命令历史文件中记录下的命令~/.bash_history </p>
<p>登录进shell后新执行的命令只会记录在缓存中；这些命令会用户退出时”追 加”至命令历史文件中 </p>
<p>重复前一个命令,有4种方法 </p>
<pre><code>重复前一个命令使用上方向键,并回车执行 

按 !! 并回车执行 

输入 !-1 并回车执行 

按 Ctrl+p 并回车执行 </code></pre><p>!:0 执行前一条命令(去除参数) </p>
<p>Ctrl + n 显示当前历史中的下一条命令,但不执行 </p>
<p>Ctrl + j 执行当前命令 </p>
<p>!n 执行history命令输出对应序号n的命令 </p>
<p>!-n 执行history历史中倒数第n个命令 </p>
<p>!string 重复前一个以”string”开头的命令 </p>
<p>!?string 重复前一个包含string的命令 </p>
<p>!string:p 仅打印命令历史,而不执行 </p>
<p>!$:p 打印输出 !$ (上一条命令的最后一个参数)的内容 </p>
<p>!<em>:p 打印输出 !</em>(上一条命令的所有参数)的内容 </p>
<p>^string 删除上一条命令中的第一个string </p>
<p>^string1^string2 将上一条命令中的第一个string1替换为string2 </p>
<p>!:gs/string1/string2 将上一条命令中所有的string1都替换为 string2 </p>
<p>使用up(向上)和down(向下)键来上下浏览从前输入的命令 </p>
<p>ctrl-r来在命令历史中搜索命令 </p>
<p> (reverse-i-search)`’: </p>
<p>Ctrl+g:从历史搜索模式退出 </p>
<p>要重新调用前一个命令中最后一个参数 </p>
<p> !$ 表示 </p>
<p> Esc, .(点击Esc键后松开,然后点击 . 键) </p>
<p> Alt+ .(按住Alt键的同时点击 . 键) </p>
<hr>
<h3 id="命令行历史-1"><a href="#命令行历史-1" class="headerlink" title="命令行历史"></a>命令行历史</h3><p>command !^             利用上一个命令的第一个参数做cmd的参数 </p>
<p>command !$             利用上一个命令的最后一个参数做cmd的参数 </p>
<p>command !*             利用上一个命令的全部参数做cmd的参数 </p>
<p>command !:n         利用上一个命令的第n个参数做cmd的参数 </p>
<p>command !n:^         调用第n条命令的第一个参数 </p>
<p>command !n:$         调用第n条命令的最后一个参数 </p>
<p>command !n:m         调用第n条命令的第m个参数 </p>
<p>command !n:*         调用第n条命令的所有参数 </p>
<p>command !string:^      从命令历史中搜索以 string 开头的命令,并获取它的第一 个参数 </p>
<p>command !string:$     从命令历史中搜索以 string 开头的命令,并获取它的最后一 个参数 </p>
<p>command !string:n      从命令历史中搜索以 string 开头的命令,并获取它的第n 个参数 </p>
<p>command !string:*      从命令历史中搜索以 string 开头的命令,并获取它的所有 参数 </p>
<h4 id="命令history"><a href="#命令history" class="headerlink" title="命令history"></a>命令history</h4><p>history [-c][-d offset][n] </p>
<p>history -anrw [filename] </p>
<p>history -ps arg [arg…] </p>
<pre><code>-c: 清空命令历史 

-d offset: 删除历史中指定的第offset个命令 

n: 显示最近的n条历史 

-a: 追加本次会话新执行的命令历史列表至历史文件 

-r: 读历史文件附加到历史列表 

-w: 保存历史列表到指定的历史文件 

-n: 读历史文件中未读过的行到历史列表 

-p: 展开历史参数成多行,但不存在历史列表中 

-s: 展开历史参数成一行,附加在历史列表后 </code></pre><h4 id="命令历史相关环境变量"><a href="#命令历史相关环境变量" class="headerlink" title="命令历史相关环境变量"></a>命令历史相关环境变量</h4><p>HISTSIZE:命令历史记录的条数 </p>
<p>HISTFILE:指定历史文件,默认为~/.bash_history </p>
<p>HISTFILESIZE:命令历史文件记录历史的条数 </p>
<p>HISTTIMEFORMAT=”%F %T “ 显示时间 </p>
<p>HISTIGNORE=”str1:str2*:… “ 忽略str1命令,str2开头的历史 </p>
<p>控制命令历史的记录方式: </p>
<pre><code>环境变量:HISTCONTROL 

ignoredups 默认,忽略重复的命令,连续且相同为&quot;重复&quot; 

ignorespace 忽略所有以空白开头的命令 

ignoreboth 相当于ignoredups, ignorespace的组合 

erasedups 删除重复命令 </code></pre><p>export 变量名=”值” </p>
<p>存放在 /etc/profile 或 ~/.bash_profile </p>
<hr>
<h3 id="bash的快捷键"><a href="#bash的快捷键" class="headerlink" title="bash的快捷键"></a>bash的快捷键</h3><p>Ctrl + l 清屏,相当于clear命令 </p>
<p>Ctrl + o 执行当前命令,并重新显示本命令 </p>
<p>Ctrl + s 阻止屏幕输出,锁定 </p>
<p>Ctrl + q 允许屏幕输出 </p>
<p>Ctrl + c 终止命令 </p>
<p>Ctrl + z 挂起命令 </p>
<p>Ctrl + a 光标移到命令行首,相当于Home </p>
<p>Ctrl + e 光标移到命令行尾,相当于End </p>
<p>Ctrl + f 光标向右移动一个字符 </p>
<p>Ctrl + b 光标向左移动一个字符 </p>
<p>Alt + f 光标向右移动一个单词尾 </p>
<p>Alt + b 光标向左移动一个单词首 </p>
<p>Ctrl + xx 光标在命令行首和光标之间移动 </p>
<p>Ctrl + u 从光标处删除至命令行首 </p>
<p>Ctrl + k 从光标处删除至命令行尾 </p>
<p>Alt + r 删除当前整行 </p>
<p>Ctrl + w 从光标处向左删除至单词首 </p>
<p>Alt + d 从光标处向右删除至单词尾 </p>
<p>Ctrl + d 删除光标处的一个字符 </p>
<p>Ctrl + h 删除光标前的一个字符 </p>
<p>Ctrl + y 将删除的字符粘贴至光标后 </p>
<p>Alt + c 从光标处开始向右更改为首字母大写的单词 </p>
<p>Alt + u 从光标处开始,将右边一个单词更改为大写 </p>
<p>Alt + l 从光标处开始,将右边一个单词更改为小写 </p>
<p>Ctrl + t 交换光标处和之前的字符位置 </p>
<p>Alt + t 交换光标处和之前的单词位置 </p>
<p>Alt + N 提示输入指定字符后,重复显示该字符N次 </p>
<p>注意:Alt组合快捷键经常和其它软件冲突 </p>
<hr>
<h3 id="获得帮助"><a href="#获得帮助" class="headerlink" title="获得帮助"></a>获得帮助</h3><p>多层次的帮助 </p>
<p>whatis </p>
<p>command –help </p>
<p>man and info </p>
<p>/usr/share/doc/ </p>
<p>Red Hat documentation </p>
<p>其它网站和搜索 </p>
<h4 id="whatis"><a href="#whatis" class="headerlink" title="whatis"></a>whatis</h4><p>显示命令的简短描述 </p>
<p>使用数据库 </p>
<p>刚安装后不可立即使用 </p>
<p>makewhatis | mandb制作数据库 </p>
<p>使用示例: </p>
<pre><code>whatis cal 或 man –f cal </code></pre><h4 id="命令帮助"><a href="#命令帮助" class="headerlink" title="命令帮助"></a>命令帮助</h4><p>内部命令:help COMMAND </p>
<pre><code>man bash </code></pre><p>外部命令:</p>
<pre><code>(1) COMMAND --help 

    COMMAND -h 

(2) 使用手册(manual) 

    man COMMAND 

(3) 信息页 

    info COMMAND 

(4) 程序自身的帮助文档 

    README 

    INSTALL 

    ChangeLog 

(5) 程序官方文档 

    官方站点:Documentation 

(6) 发行版的官方文档 

(7) Google </code></pre><h4 id="help和-h选项"><a href="#help和-h选项" class="headerlink" title="-help和-h选项"></a>-help和-h选项</h4><p>显示用法总结和参数列表 </p>
<p>使用的大多数,但并非所有的 </p>
<p>示例: </p>
<pre><code>date --help 

Usage: date [OPTION]... [+FORMAT] or: date \[-u|--utc|-- universal]\[MMDDhhmm\[\[CC]YY]\[.ss]]

[] 表示可选项 

CAPS或 &lt;&gt; 表示变化的数据 

... 表示一个列表 

x |y| z 的意思是&quot; x 或 y 或 z &quot; 

-abc的 意思是-a -b –c 

{ } 表示分组 </code></pre><h4 id="man命令"><a href="#man命令" class="headerlink" title="man命令"></a>man命令</h4><p>提供命令帮助的文件 </p>
<p>手册页存放在/usr/share/man </p>
<p>几乎每个命令都有man的”页面” </p>
<p>man页面分组为不同的”章节” </p>
<p>统称为Linux手册 </p>
<p>man命令的配置文件:/etc/man.config | man_db.conf MANPATH /PATH/TO/SOMEWHERE: 指明man文件搜索位置 </p>
<p>man -M /PATH/TO/SOMEWHERE COMMAND: 到指定位置下搜索 COMMAND命令的手册页并显示 </p>
<p>中文man需安装包man-pages-zh-CN </p>
<h4 id="man章节"><a href="#man章节" class="headerlink" title="man章节"></a>man章节</h4><p>1: 用户命令 </p>
<p>2: 系统调用 </p>
<p>3: C库调用 </p>
<p>4: 设备文件及特殊文件 </p>
<p>5: 配置文件格式 </p>
<p>6: 游戏 </p>
<p>7: 杂项 </p>
<p>8: 管理类的命令 </p>
<p>9:Linux 内核API</p>
<h4 id="man帮助段落说明"><a href="#man帮助段落说明" class="headerlink" title="man帮助段落说明"></a>man帮助段落说明</h4><p>帮助手册中的段落说明: </p>
<pre><code>NAME 名称及简要说明 

SYNOPSIS 用法格式说明 

   • [] 可选内容 

   • &lt;&gt; 必选内容 

   • a|b 二选一 

   • { } 分组 

   • ... 同一内容可出现多次 

DESCRIPTION 详细说明 

OPTIONS 选项说明 

EXAMPLES 示例 

FILES 相关文件 

AUTHOR 作者 

COPYRIGHT 版本信息 

REPORTING BUGS bug信息 

SEE ALSO 其它帮助参考 </code></pre><h4 id="man帮助"><a href="#man帮助" class="headerlink" title="man帮助"></a>man帮助</h4><p>查看man手册页 </p>
<pre><code>man [章节] keyword </code></pre><p>列出所有帮助 </p>
<pre><code>man –a keyword </code></pre><p>搜索man手册 </p>
<pre><code>man -k keyword 列出所有匹配的页面 

使用 whatis 数据库 </code></pre><p>相当于whatis </p>
<pre><code>man –f keyword </code></pre><p>打印man帮助文件的路径 </p>
<pre><code>man –w [章节] keyword </code></pre><h4 id="man命令-1"><a href="#man命令-1" class="headerlink" title="man命令"></a>man命令</h4><p>man命令的操作方法:使用less命令实现 </p>
<pre><code>space, ^v, ^f, ^F: 向文件尾翻屏 

b, ^b: 向文件首部翻屏 

d, ^d: 向文件尾部翻半屏 

u, ^u: 向文件首部翻半屏 

RETURN, ^N, e, ^E or j or ^J: 向文件尾部翻一行 

y or ^Y or ^P or k or ^K:向文件首部翻一行 

q: 退出 

#:跳转至第#行 

1G: 回到文件首部 

G:翻至文件尾部 </code></pre><h4 id="man搜索"><a href="#man搜索" class="headerlink" title="man搜索"></a>man搜索</h4><p>/KEYWORD: </p>
<pre><code>以KEYWORD指定的字符串为关键字,从当前位置向文件尾部搜索；不区 分字符大小写； 

n: 下一个 

N:上一个 </code></pre><p>?KEYWORD: 以KEYWORD指定的字符串为关键字,从当前位置向文件首部搜索；不区分字 符大小写； </p>
<pre><code>n: 跟搜索命令同方向,下一个 

N:跟搜索命令反方向,上一个 </code></pre><h4 id="info"><a href="#info" class="headerlink" title="info"></a>info</h4><p>man常用于命令参考 ,GNU工具info适合通用文档参考 </p>
<p>没有参数,列出所有的页面 </p>
<p>info 页面的结构就像一个网站 </p>
<p>每一页分为”节点” </p>
<p>链接节点之前 * </p>
<p>info [ 命令 ] </p>
<h4 id="导航info页"><a href="#导航info页" class="headerlink" title="导航info页"></a>导航info页</h4><p>方向键,PgUp,PgDn 导航 </p>
<p>Tab键 移动到下一个链接 </p>
<p>d 显示主题目录 </p>
<p>Home 显示主题首部 </p>
<p>Enter进入 选定链接 </p>
<p>n/p/u/l 进入下/前/上一层/最后一个链接 </p>
<p>s 文字 文本搜索 </p>
<p>q 退出 info </p>
<h4 id="通过本地文档获取帮助"><a href="#通过本地文档获取帮助" class="headerlink" title="通过本地文档获取帮助"></a>通过本地文档获取帮助</h4><p>System-&gt;help(centos6) </p>
<p>Applications -&gt; documentation-&gt;help(centos7) </p>
<p>提供的官方使用指南和发行注记 </p>
<p>/usr/share/doc目录 </p>
<p>多数安装了的软件包的子目录,包括了这些软件的相关 原理说明 </p>
<p>常见文档:README INSTALL CHANGES </p>
<p>不适合其它地方的文档的位置 </p>
<p>配置文件范例 </p>
<p>HTML/PDF/PS 格式的文档 </p>
<p>授权书详情 </p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-文件管理</title>
    <url>/Linux-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86-1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Linux 文件查找和压缩</title>
    <url>/Linux-%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%92%8C%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<h3 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h3><p>在文件系统上查找符合条件的文件 </p>
<p>文件查找:locate, find </p>
<p>​    非实时查找(数据库查找):locate </p>
<p>​    实时查找:find </p>
<h4 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h4><p>查询系统上预建的文件索引数据库 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/var/lib/mlocate/mlocate.db</span><br></pre></td></tr></table></figure>

<p>依赖于事先构建的索引 </p>
<p>索引的构建是在系统较为空闲时自动进行(周期性任务)，管理员手动更新数据库 (updatedb) </p>
<p>索引构建过程需要遍历整个根文件系统，极消耗资源 </p>
<p>工作特点: </p>
<p>• 查找速度快 </p>
<p>• 模糊查找 </p>
<p>• 非实时查找 </p>
<p>• 搜索的是文件的全路径，不仅仅是文件名 </p>
<p>• 可能只搜索用户具备读取和执行权限的目录 </p>
<h4 id="locate-命令"><a href="#locate-命令" class="headerlink" title="locate 命令"></a>locate 命令</h4><p>locate KEYWORD </p>
<p>有用的选项 </p>
<p>​    -i 不区分大小写的搜索 </p>
<p>​    -n N 只列举前N个匹配项目 </p>
<p>​    -r 使用正则表达式 </p>
<p>示例 </p>
<p>搜索名称或路径中带有”conf”的文件 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">locate conf</span><br></pre></td></tr></table></figure>

<p>使用Regex来搜索以”.conf”结尾的文件 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">locate -r ‘\.conf$’</span><br></pre></td></tr></table></figure>



<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>实时查找工具，通过遍历指定路径完成文件查找 </p>
<p>工作特点: </p>
<p>​    • 查找速度略慢 </p>
<p>​    • 精确查找 </p>
<p>​    • 实时查找 </p>
<p>​    • 可能只搜索用户具备读取和执行权限的目录 </p>
<p>语法: </p>
<p>find [OPTION]… [查找路径][查找条件][处理动作] </p>
<p>查找路径:指定具体目标路径;</p>
<p>默认为当前目录 查找条件:指定的查找标准，可以文件名、大小、类型、权限等标准进行; 默认为找出指定路径下的所有文件 </p>
<p>处理动作:对符合条件的文件做操作，默认输出至屏幕     </p>
<h4 id="查找条件"><a href="#查找条件" class="headerlink" title="查找条件"></a>查找条件</h4><p>指搜索层级 </p>
<p>​    -maxdepth level 最大搜索目录深度,指定目录为第1级 </p>
<p>​    -mindepth level 最小搜索目录深度 </p>
<p>根据文件名和inode查找: </p>
<p>​    -name “文件名称”:支持使用glob </p>
<p>​        *, ?, [], [^] </p>
<p>​    -iname “文件名称”:不区分字母大小写 </p>
<p>​    -inum n 按inode号查找 </p>
<p>​    -samefile name 相同inode号的文件 </p>
<p>​    -links n 链接数为n的文件 </p>
<p>​    -regex “PATTERN”:以PATTERN匹配整个文件路径字符串，而不仅仅是文 件名称     </p>
<p>根据属主、属组查找: </p>
<p>​    -user USERNAME:查找属主为指定用户(UID)的文件 </p>
<p>​    -group GRPNAME: 查找属组为指定组(GID)的文件 </p>
<p>​    -uid UserID:查找属主为指定的UID号的文件 </p>
<p>​    -gid GroupID:查找属组为指定的GID号的文件 </p>
<p>​    -nouser:查找没有属主的文件 </p>
<p>​    -nogroup:查找没有属组的文件     </p>
<p>根据文件类型查找: </p>
<p>​    -type TYPE: </p>
<p>​    • f: 普通文件 </p>
<p>​    • d: 目录文件 </p>
<p>​    • l: 符号链接文件 </p>
<p>​    • s:套接字文件 </p>
<p>​    • b: 块设备文件 </p>
<p>​    • c: 字符设备文件 </p>
<p>​    • p: 管道文件     </p>
<p>空文件或目录 </p>
<p>​    -empty </p>
<p>​    find /app -type d -empty     </p>
<p>组合条件: </p>
<p>​    与:-a </p>
<p>​    或:-o </p>
<p>​    非:-not, !     </p>
<p>德·摩根定律: </p>
<pre><code>(非 A) 或 (非 B) = 非(A 且 B) 

(非 A) 且 (非 B) = 非(A 或 B) </code></pre><p>示例: </p>
<pre><code>!A -a !B = !(A -o B) 

!A -o !B = !(A -a B) </code></pre><h4 id="查找条件-1"><a href="#查找条件-1" class="headerlink" title="查找条件"></a>查找条件</h4><p>根据文件大小来查找: </p>
<p>-size [+|-]#UNIT </p>
<pre><code>常用单位:k, M, G，c（byte） </code></pre><p>#UNIT: (#-1, #] </p>
<pre><code>如:6k 表示(5k,6k] </code></pre><p>-#UNIT:[0,#-1] </p>
<pre><code>如:-6k 表示[0,5k] </code></pre><p>+#UNIT:(#,∞) </p>
<pre><code>如:+6k 表示(6k,∞)     </code></pre><p>根据时间戳: </p>
<p>以”天”为单位; </p>
<p>​    -atime [+|-]#, </p>
<p>​        #: [#,#+1) </p>
<p>​        +#: [#+1,∞] </p>
<p>​        -#: [0,#)     </p>
<p>​    -mtime </p>
<p>​    -ctime     </p>
<p>以”分钟”为单位: </p>
<p>​    -amin </p>
<p>​    -mmin </p>
<p>​    -cmin         </p>
<p>根据权限查找: </p>
<p>-perm [/|-]MODE </p>
<p>MODE: 精确权限匹配 </p>
<p>​    /MODE:任何一类(u,g,o)对象的权限中只要能一位匹配即可，或关系，+ 从centos7开始淘汰 </p>
<p>​    -MODE:每一类对象都必须同时拥有指定权限，与关系 0 表示不关注 </p>
<p>​    • find -perm 755 会匹配权限模式恰好是755的文件 </p>
<p>​    • 只要当任意人有写权限时，find -perm +222就会匹配 </p>
<p>​    • 只有当每个人都有写权限时，find -perm -222才会匹配 </p>
<p>​    • 只有当其它人（other）有写权限时，find -perm -002才会匹配     </p>
<h4 id="处理动作"><a href="#处理动作" class="headerlink" title="处理动作"></a>处理动作</h4><p>-print:默认的处理动作，显示至屏幕 </p>
<p>-ls:类似于对查找到的文件执行”ls -l”命令 </p>
<p>-delete:删除查找到的文件 </p>
<p>-fls file:查找到的所有文件的长格式信息保存至指定文件中 </p>
<p>-ok COMMAND {} ; </p>
<p>​    对查找到的每个文件执行由COMMAND指定的命令，对于 每个文件执行命令之前，都会交互式要求用户确认 </p>
<p>-exec COMMAND {} ; </p>
<p>​    对查找到的每个文件执行由COMMAND指定的命令 </p>
<p>{}: 用于引用查找到的文件名称自身 </p>
<p>find传递查找到的文件至后面指定的命令时，查找到所有符合条件的文件一次性 传递给后面的命令 </p>
<h4 id="参数替换xargs"><a href="#参数替换xargs" class="headerlink" title="参数替换xargs"></a>参数替换xargs</h4><p>由于很多命令不支持管道|来传递参数，而日常工作中有这个必要，所以就有了 xargs命令 </p>
<p>xargs用于产生某个命令的参数，xargs 可以读入 stdin 的数据，并且以空格符 或回车符将 stdin 的数据分隔成为arguments </p>
<p>注意:文件名或者是其他意义的名词内含有空格符的情况 </p>
<p>有些命令不能接受过多参数，命令执行可能会失败，xargs可以解决 </p>
<p>示例: </p>
<p>​    ls f* |xargs rm </p>
<p>​    find /sbin -perm +700 |ls -l 这个命令是错误的     </p>
<p>​    find /sbin -perm +700 | xargs ls –l </p>
<p>find和xargs格式:find | xargs COMMAND </p>
<h3 id="压缩，解压缩及归档工具"><a href="#压缩，解压缩及归档工具" class="headerlink" title="压缩，解压缩及归档工具"></a>压缩，解压缩及归档工具</h3><p>file-roller </p>
<p>compress/uncompress: .Z </p>
<p>gzip/gunzip: .gz </p>
<p>bzip2/bunzip2: .bz2 </p>
<p>xz/unxz: .xz </p>
<p>zip/unzip </p>
<p>tar </p>
<p>cpio </p>
<h4 id="compress-uncompress"><a href="#compress-uncompress" class="headerlink" title="compress/uncompress"></a>compress/uncompress</h4><p>compress [-dfvcVr]/[-b maxbits]/[file …] </p>
<p>​    -d: 解压缩，相当于uncompress </p>
<p>​    -c: 结果输出至标准输出,不删除原文件 </p>
<p>​    -v: 显示详情     </p>
<p>uncompress 解压缩 </p>
<p>zcat file.Z &gt;file </p>
<h4 id="gzip-gunzip"><a href="#gzip-gunzip" class="headerlink" title="gzip/gunzip"></a>gzip/gunzip</h4><p>gzip [OPTION]… FILE … </p>
<p>​    -d: 解压缩，相当于gunzip </p>
<p>​    -c: 将压缩或解压缩的结果输出至标准输出 </p>
<p>​    -#:1-9，指定压缩比，值越大压缩比越大     </p>
<p>zcat:不显式解压缩的前提下查看文本文件内容 </p>
<p>实例: </p>
<p>​    gzip -c messages &gt;messages.gz </p>
<p>​    gzip -c -d messages.gz &gt; messages </p>
<p>​    zcat messages.gz &gt; messages     </p>
<h4 id="bzip2-bunzip-bzcat"><a href="#bzip2-bunzip-bzcat" class="headerlink" title="bzip2/bunzip/bzcat"></a>bzip2/bunzip/bzcat</h4><p>bzip2 [OPTION]… FILE … </p>
<p>​    -k: keep, 保留原文件 </p>
<p>​    -d:解压缩 </p>
<p>​    -#:1-9，压缩比，默认为9     </p>
<p>bzcat:不显式解压缩的前提下查看文本文件内容 </p>
<h4 id="xz-unxz-xzcat"><a href="#xz-unxz-xzcat" class="headerlink" title="xz/unxz/xzcat"></a>xz/unxz/xzcat</h4><p>xz [OPTION]… FILE … </p>
<p>​    -k: keep, 保留原文件 </p>
<p>​    -d:解压缩 </p>
<p>​    -#:1-9，压缩比，默认为6     </p>
<p>xzcat: 不显式解压缩的前提下查看文本文件内容 </p>
<h4 id="zip-unzip"><a href="#zip-unzip" class="headerlink" title="zip/unzip"></a>zip/unzip</h4><p>打包压缩 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zip –r /testdir/sysconfig /etc/sysconfig/</span><br></pre></td></tr></table></figure>

<p>解包解压缩 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unzip sysconfig.zip </span><br><span class="line"></span><br><span class="line">cat /var/log/messages | zip messages - </span><br><span class="line"></span><br><span class="line">unzip -p message &gt; message</span><br></pre></td></tr></table></figure>



<h4 id="tar工具"><a href="#tar工具" class="headerlink" title="tar工具"></a>tar工具</h4><p> tar（Tape ARchive，磁带归档的缩写） </p>
<p> tar [OPTION]… </p>
<p>(1) 创建归档 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -cpvf /PATH/TO/SOMEFILE.tar FILE...</span><br></pre></td></tr></table></figure>

<p>(2) 追加文件至归档: 注:不支持对压缩文件追加 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -r -f /PATH/TO/SOMEFILE.tar FILE...</span><br></pre></td></tr></table></figure>

<p>(3) 查看归档文件中的文件列表 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -t -f /PATH/TO/SOMEFILE.tar</span><br></pre></td></tr></table></figure>

<p>(4) 展开归档 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -x -f /PATH/TO/SOMEFILE.tar </span><br><span class="line"></span><br><span class="line">tar -x -f /PATH/TO/SOMEFILE.tar -C /PATH/</span><br></pre></td></tr></table></figure>

<p>(5) 结合压缩工具实现:归档并压缩 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-j: bzip2, -z: gzip, -J: xz</span><br></pre></td></tr></table></figure>

<p>-T选项指定输入文件,-X选项指定包含要排除的文件列表 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar zcvf mybackup.tgz -T /root/includefilelist -X /root/excludefilelist</span><br></pre></td></tr></table></figure>

<p>分割大的 tar 文件为多份小文件: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">split –b Size –d tar-file-name prefix-name </span><br><span class="line"></span><br><span class="line">split -b 1M –d mybackup.tgz mybackup-parts </span><br><span class="line"></span><br><span class="line">split -b 1M mybackup.tgz mybackup-parts</span><br></pre></td></tr></table></figure>

<p>合并: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat mybackup-parts* &gt; mybackup.tar.gz</span><br></pre></td></tr></table></figure>



<h4 id="cpio"><a href="#cpio" class="headerlink" title="cpio"></a>cpio</h4><p>功能:复制文件从或到归档 </p>
<p>cpio命令是通过重定向的方式将文件进行打包备份，还原恢复的工具，它可以 解压以”.cpio”或者”.tar”结尾的文件 </p>
<p>cpio [选项] &gt; 文件名或者设备名 </p>
<p>cpio [选项] &lt; 文件名或者设备名 </p>
<p>选项 </p>
<p>​    -o 将文件拷贝打包成文件或者将文件输出到设备上 </p>
<p>​    -i 解包，将打包文件解压或将设备上的备份还原到系统 </p>
<p>​    -t 预览，查看文件内容或者输出到设备上的文件内容 </p>
<p>​    -v 显示打包过程中的文件名称。 </p>
<p>​    -d 解包生成目录，在cpio还原时，自动的建立目录 </p>
<p>​    -c 一种较新的存储方式     </p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 标准IO和管道</title>
    <url>/Linux-%E6%A0%87%E5%87%86IO%E5%92%8C%E7%AE%A1%E9%81%93/</url>
    <content><![CDATA[<h3 id="标准输入和输出"><a href="#标准输入和输出" class="headerlink" title="标准输入和输出"></a>标准输入和输出</h3><p>程序:指令+数据 </p>
<p>​    读入数据:    Input </p>
<p>​    输出数据:    Output </p>
<p>打开的文件都有一个fd: file descriptor (文件描述符) </p>
<p>Linux给程序提供三种I/O设备 </p>
<p>​    标准输入(STDIN)     －0 默认接受来自键盘的输入 </p>
<p>​    标准输出(STDOUT) －1 默认输出到终端窗口 </p>
<p>​    标准错误(STDERR)  －2 默认输出到终端窗口 </p>
<p>I/O重定向:改变默认位置 </p>
<h3 id="把-I-O-重定向至文件"><a href="#把-I-O-重定向至文件" class="headerlink" title="把 I/O 重定向至文件"></a>把 I/O 重定向至文件</h3><hr>
<h4 id="把输出和错误重新定向到文件"><a href="#把输出和错误重新定向到文件" class="headerlink" title="把输出和错误重新定向到文件"></a>把输出和错误重新定向到文件</h4><p>STDOUT和STDERR可以被重定向到文件 </p>
<p>​    命令 操作符号 文件名 </p>
<p>支持的操作符号包括: </p>
<p>​    &gt;       把STDOUT重定向到文件 </p>
<p>​    2&gt;     把STDERR重定向到文件 </p>
<p>​    &amp;&gt;     把所有输出重定向到文件 </p>
<p>&gt;文件内容会被覆盖 </p>
<p>​    set –C 禁止将内容覆盖已有文件,但可追加 </p>
<p>​    &gt;| file 强制覆盖 </p>
<p>​    set +C 允许覆盖 </p>
<p>&gt;&gt;原有内容基础上，追加内容 </p>
<p>​    2&gt; 覆盖重定向错误输出数据流 </p>
<p>​    2&gt;&gt; 追加重定向错误输出数据流 </p>
<p>标准输出和错误输出各自定向至不同位置 </p>
<p>​    COMMAND &gt; /path/to/file.out 2&gt; /path/to/error.out </p>
<p>合并标准输出和错误输出为同一个数据流进行重定向 </p>
<p>​     &amp;&gt; 覆盖重定向 </p>
<p>​     &amp;&gt;&gt; 追加重定向 </p>
<p>​    COMMAND &gt; /path/to/file.out 2&gt;&amp;1 (顺序很重要) </p>
<p>​    COMMAND &gt;&gt; /path/to/file.out 2&gt;&amp;1 </p>
<p> ():合并多个程序的STDOUT </p>
<p>​    ( cal 2007 ; cal 2008 ) &gt; all.txt </p>
<h4 id="tr命令"><a href="#tr命令" class="headerlink" title="tr命令"></a>tr命令</h4><p>tr 转换和删除字符 tr [OPTION]… SET1 [SET2] </p>
<p>选项: </p>
<p>​    -c –C –complement:取字符集的补集 </p>
<p>​    -d –delete:删除所有属于第一字符集的字符 </p>
<p>​    -s –squeeze-repeats:把连续重复的字符以单独一个字符表示</p>
<p>​     -t –truncate-set1:将第一个字符集对应字符转化为第二字符集对应的字符</p>
<p>​    [:alnum:]:字母和数字 </p>
<p>​    [:alpha:]:字母 </p>
<p>​    [:cntrl:]:控制(非打印)字符 </p>
<p>​    [:digit:]: 数字 </p>
<p>​    [:graph:]:图形字符 </p>
<p>​    [:lower:]:小写字母 </p>
<p>​    [:print:]:可打印字符 </p>
<p>​    [:punct:]: 标点符号 </p>
<p>​    [:space:]:空白字符 </p>
<p>​    [:upper:]:大写字母 </p>
<p>​    [:xdigit:]:十六进制字符 </p>
<h3 id="使用管道"><a href="#使用管道" class="headerlink" title="使用管道"></a>使用管道</h3><hr>
<h4 id="从文件中导入STDIN"><a href="#从文件中导入STDIN" class="headerlink" title="从文件中导入STDIN"></a>从文件中导入STDIN</h4><p>使用&lt;来重定向标准输入 </p>
<p>某些命令能够接受从文件中导入的STDIN </p>
<p>​    tr ‘a-z’ ‘A-Z’&lt; /etc/issue </p>
<p>该命令会把/etc/issue中的小写字符都转换成写写字符 </p>
<p>tr –d abc &lt; /etc/fstab 删除fstab文件中的所有abc中任意字符 </p>
<p>cat &gt; file </p>
<p>​    google </p>
<p>​    mark</p>
<p>​    按ctrl+d离开，可以使用文件来代替键盘的输入 </p>
<p>cat &gt; filea &lt; fileb </p>
<h4 id="把多行发送给STDIN"><a href="#把多行发送给STDIN" class="headerlink" title="把多行发送给STDIN"></a>把多行发送给STDIN</h4><p>使用“&lt;&lt;终止词”命令从键盘把多行重导向给STDIN<br>直到 终止词 位置的所有文本都发送给STDIN<br>有时被称为就地文本(heretext)<br>mail -s “Please Call” <a href="mailto:admin@google.com">admin@google.com</a> &lt;&lt; END </p>
<p>&gt;Hi Mark,</p>
<p>&gt;Please give me a call when you get in. We may need</p>
<p>&gt; to do some maintenance on server1.</p>
<p>&gt;Details when you’re on-site</p>
<p>&gt;Zhang</p>
<p>&gt;END</p>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>管道(使用符号“|”表示)用来连接命令 </p>
<p>命令1 | 命令2 | 命令3 | … </p>
<p>将命令1的STDOUT发送给命令2的STDIN，命令2的STDOUT发送到命令3的 STDIN             </p>
<p>STDERR默认不能通过管道转发，可利用2&gt;&amp;1 或 |&amp; 实现 </p>
<p>最后一个命令会在当前shell进程的子shell进程中执行用来组合多种工具的功能 </p>
<p><code>ls | tr ‘a-z’ ‘A-Z</code></p>
<p>less :一页一页地查看输入</p>
<p><code>ls -l /etc | less</code></p>
<p>mail: 通过电子邮件发送输入 </p>
<p><code>echo &quot;test email&quot; | mail -s &quot;test&quot; user@example.com</code></p>
<p>lpr:把输入发送给打印机 </p>
<p><code>echo &quot;test print&quot; | lpr -P printer_name</code></p>
<h4 id="管道中的-符号"><a href="#管道中的-符号" class="headerlink" title="管道中的 - 符号"></a>管道中的 - 符号</h4><p>示例: </p>
<p>将 /home 里面的文件打包，但打包的数据不是记录到文件，而是传送到 stdout， 经过管道后，将 tar -cvf - /home 传送给后面的 tar -xvf - , 后面的这个 - 则是取 前一个命令的 stdout， 因此，就不需要使用临时file了 </p>
<p><code>tar -cvf - /home | tar -xvf -</code></p>
<h4 id="重定向到多个目标-tee"><a href="#重定向到多个目标-tee" class="headerlink" title="重定向到多个目标(tee)"></a>重定向到多个目标(tee)</h4><p>命令1 | tee [-a ] 文件名 | 命令2 </p>
<p>​    把命令1的STDOUT保存在文件中，做为命令2的输入 </p>
<p>​    -a 追加 </p>
<p>使用: </p>
<p>​    保存不同阶段的输出 </p>
<p>​    复杂管道的故障排除 </p>
<p>​    同时查看和记录输出 </p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 文件权限及属性</title>
    <url>/Linux-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E5%8F%8A%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h4 id="文件属性操作"><a href="#文件属性操作" class="headerlink" title="文件属性操作"></a>文件属性操作</h4><p>​    chown 设置文件的所有者 </p>
<p>​    chgrp 设置文件的属组信息 </p>
<h4 id="修改文件的主属性和属组"><a href="#修改文件的主属性和属组" class="headerlink" title="修改文件的主属性和属组"></a>修改文件的主属性和属组</h4><p>修改文件的属主:chown </p>
<pre><code>chown [OPTION]... \[OWNER][:[GROUP]] FILE... </code></pre><p>用法: </p>
<p>​    OWNER </p>
<p>​    OWNER:GROUP </p>
<p>​    :GROUP </p>
<p>​    命令中的冒号可用.替换 </p>
<p>​    -R: 递归 </p>
<p>​    chown [OPTION]… –reference=RFILE FILE…     </p>
<p>修改文件的属组:chgrp </p>
<p>​    chgrp [OPTION]… GROUP FILE… </p>
<p>​    chgrp [OPTION]… –reference=RFILE FILE… </p>
<p>​    -R 递归 </p>
<h4 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h4><p>文件的权限主要针对三类对象进行定义 </p>
<p>​    owner: 属主, u </p>
<p>​    group: 属组, g </p>
<p>​    other: 其他, o </p>
<p>每个文件针对每类访问者都定义了三种权限 </p>
<p>​    r: Readable </p>
<p>​    w: Writable </p>
<p>​    x: eXcutable     </p>
<p>文件:</p>
<p>​    r: 可使用文件查看类工具获取其内容 </p>
<p>​    w: 可修改其内容 </p>
<p>​    x: 可以把此文件提请内核启动为一个进程     </p>
<p>目录: </p>
<p>​    r: 可以使用ls查看此目录中文件列表 </p>
<p>​    w: 可在此目录中创建文件,也可删除此目录中的文件 </p>
<p>​    x: 可以使用ls -l查看此目录中文件元数据(须配合r),可以cd进入此目录 </p>
<p>​    X:只给目录x权限,不给文件x权限 </p>
<h4 id="文件权限操作"><a href="#文件权限操作" class="headerlink" title="文件权限操作"></a>文件权限操作</h4><p>文件权限操作命令:chmod </p>
<p>文件权限(rwx|X) </p>
<h4 id="八进制数字"><a href="#八进制数字" class="headerlink" title="八进制数字"></a>八进制数字</h4><p>—     000 0 </p>
<p>–x     001 1 </p>
<p>-w-     010 2 </p>
<p>-wx     011 3 </p>
<p>r–     100 4 </p>
<p>r-x     101 5 </p>
<p>rw-     110 6 </p>
<p>rwx    111 7 </p>
<p>例如: </p>
<pre><code>640: rw-r----- 

755: rwxr-xr-x </code></pre><h4 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h4><p>chmod [OPTION]… OCTAL-MODE FILE… </p>
<p>​    -R: 递归修改权限 </p>
<p>chmod [OPTION]… MODE[,MODE]… FILE… </p>
<p>MODE: </p>
<p>修改一类用户的所有权限: </p>
<p>​    u= g= o= ug= a= u=,g= </p>
<p>修改一类用户某位或某些位权限 </p>
<p>​    u+ u- g+ g- o+ o- a+ a- + - </p>
<p>chmod [OPTION]… –reference=RFILE FILE… </p>
<p>​    参考RFILE文件的权限,将FILE的修改为同RFILE </p>
<h4 id="权限设置示例"><a href="#权限设置示例" class="headerlink" title="权限设置示例"></a>权限设置示例</h4><p>chgrp sales testfile </p>
<p>chown root:admins testfile </p>
<p>chmod u+wx,g-r,o=rx file </p>
<p>chmod -R g+rwX /testdir </p>
<p>chmod 600 file </p>
<p>chown mark testfile </p>
<h4 id="新建文件和目录的默认权限"><a href="#新建文件和目录的默认权限" class="headerlink" title="新建文件和目录的默认权限"></a>新建文件和目录的默认权限</h4><p>umask值 可以用来保留在创建文件权限 </p>
<p>新建FILE权限: 666-umask </p>
<p>​    如果所得结果某位存在执行(奇数)权限,则将其权限+1 </p>
<p>新建DIR权限: 777-umask </p>
<p>非特权用户umask是 002 </p>
<p>root的umask 是 022 </p>
<p>umask: 查看 </p>
<p>umask #: 设定 </p>
<p>​    umask 002 </p>
<p>​    umask –S 模式方式显示 </p>
<p>​    umask –p 输出可被调用     </p>
<p>全局设置: /etc/bashrc 用户设置:~/.bashrc </p>
<h4 id="Linux文件系统上的特殊权限"><a href="#Linux文件系统上的特殊权限" class="headerlink" title="Linux文件系统上的特殊权限"></a>Linux文件系统上的特殊权限</h4><p>SUID, SGID, Sticky </p>
<p>三种常用权限:r, w, x user, group, other </p>
<p>安全上下文 </p>
<p>前提:进程有属主和属组；文件有属主和属组 </p>
<p>(1) 任何一个可执行程序文件能不能启动为进程,取决发起者对程序文件是否拥有 执行权限 </p>
<p>(2) 启动为进程之后,其进程的属主为发起者,进程的属组为发起者所属的组 </p>
<p>(3) 进程访问文件时的权限,取决于进程的发起者 </p>
<p>​    (a) 进程的发起者,同文件的属主:则应用文件属主权限 </p>
<p>​    (b) 进程的发起者,属于文件属组；则应用文件属组权限 </p>
<p>​    (c) 应用文件“其它”权限     </p>
<h4 id="可执行文件上的SUID权限"><a href="#可执行文件上的SUID权限" class="headerlink" title="可执行文件上的SUID权限"></a>可执行文件上的SUID权限</h4><p>任何一个可执行程序文件能不能启动为进程:取决发起者对程序文件是否拥有 执行权限 </p>
<p>启动为进程之后,其进程的属主为原程序文件的属主 </p>
<p>SUID只对二进制可执行程序有效 </p>
<p>SUID设置在目录上无意义 </p>
<p>权限设定: </p>
<p>​    chmod u+s FILE… </p>
<p>​    chmod u-s FILE… </p>
<p>​    SUID使用数字表示法可以用 4 来表示.</p>
<h4 id="可执行文件上SGID权限"><a href="#可执行文件上SGID权限" class="headerlink" title="可执行文件上SGID权限"></a>可执行文件上SGID权限</h4><p>任何一个可执行程序文件能不能启动为进程,取决发起者对程序文件是否拥有 执行权限 </p>
<p>启动为进程之后,其进程的属组为原程序文件的属组 </p>
<p>权限设定: </p>
<p>​    chmod g+s FILE… </p>
<p>​    chmod g-s FILE… </p>
<h4 id="目录上的SGID权限"><a href="#目录上的SGID权限" class="headerlink" title="目录上的SGID权限"></a>目录上的SGID权限</h4><p>默认情况下,用户创建文件时,其属组为此用户所属的主组 </p>
<p>一旦某目录被设定了SGID,则对此目录有写权限的用户在此目录中创建的文件 所属的组为此目录的属组 </p>
<p>通常用于创建一个协作目录 </p>
<p>权限设定: </p>
<p>​    chmod g+s DIR… </p>
<p>​    chmod g-s DIR…     </p>
<p>​    SGID使用数字表示法可以用 2 来表示.</p>
<h4 id="Sticky位"><a href="#Sticky位" class="headerlink" title="Sticky位"></a>Sticky位</h4><p>具有写权限的目录通常用户可以删除该目录中的任何文件,无论该文件的权限 或拥有权 </p>
<p>在目录设置Sticky 位,只有文件的所有者或root可以删除该文件 </p>
<p>sticky 设置在文件上无意义 </p>
<p>权限设定: </p>
<p>​    chmod o+t DIR… </p>
<p>​    chmod o-t DIR…     </p>
<p>​    Sticky使用数字表示发可以用 1 来表示.</p>
<p>例如: </p>
<p>​    ls -ld /tmp drwxrwxrwt 12 root root 4096 Nov 2 15:44 /tmp </p>
<h4 id="特殊权限数字法"><a href="#特殊权限数字法" class="headerlink" title="特殊权限数字法"></a>特殊权限数字法</h4><p>SUID SGID STICKY </p>
<p>000 0 </p>
<p>001 1 </p>
<p>010 2 </p>
<p>011 3 </p>
<p>100 4 </p>
<p>101 5 </p>
<p>110 6 </p>
<p>111 7 </p>
<p>chmod 4777 /tmp/a.txt </p>
<h4 id="权限位映射"><a href="#权限位映射" class="headerlink" title="权限位映射"></a>权限位映射</h4><p>SUID: user,占据属主的执行权限位 </p>
<p>​    s: 属主拥有x权限 </p>
<p>​    S: 属主没有x权限     </p>
<p>SGID: group,占据属组的执行权限位 </p>
<pre><code>s: group拥有x权限 </code></pre><p>​    S: group没有x权限 </p>
<p>Sticky: other,占据other的执行权限位 </p>
<p>​    t: other拥有x权限 </p>
<p>​    T: other没有x权限     </p>
<p><strong>特殊权限</strong></p>
<p>suid (4) : 作用于二进制程序,功能: 当用户执行此程序的时,将继承此文件所有者的权限</p>
<p>sgid (2) : 作用于二进制程序,功能: 当用户执行此程序的时,将继承此文件所有组的权限</p>
<pre><code>作用于目录上,功能:当用户在目录新建文件时,新文件的所属组自动继承此目录的所属组</code></pre><p>sticky (1) : 作用于目录上,功能: 此目录中的文件,只能被所有者自己删除</p>
<h4 id="设定文件特定属性"><a href="#设定文件特定属性" class="headerlink" title="设定文件特定属性"></a>设定文件特定属性</h4><p>chattr +i 不能删除,改名,更改 </p>
<p>chattr +a 只能追加内容 </p>
<p>lsattr 显示特定属性 </p>
<h4 id="访问控制列表"><a href="#访问控制列表" class="headerlink" title="访问控制列表"></a>访问控制列表</h4><p>ACL:Access Control List,实现灵活的权限管理 </p>
<p>除了文件的所有者,所属组和其它人,可以对更多的用户设置权限 </p>
<p>CentOS7 默认创建的xfs和ext4文件系统具有ACL功能 </p>
<p>CentOS7 之前版本,默认手工创建的ext4文件系统无ACL功能,需手动增加 </p>
<pre><code>tune2fs –o acl /dev/sdb1 

mount –o acl /dev/sdb1 /mnt/test </code></pre><p>ACL生效顺序:所有者,自定义用户,自定义组,其他人 </p>
<p>为多用户或者组的文件和目录赋予访问权限rwx </p>
<p>• mount -o acl /directory </p>
<p>• getfacl file |directory </p>
<p>• setfacl -m u:mark:rwx file|directory </p>
<p>• setfacl -Rm g:sales:rwX directory </p>
<p>• setfacl -M file.acl file|directory </p>
<p>• setfacl -m g:salesgroup:rw file| directory </p>
<p>• setfacl -m d:u:mark:rx directory </p>
<p>• setfacl -x u:mark file |directory </p>
<p>• setfacl -X file.acl directory </p>
<p>ACL文件上的group权限是mask 值(自定义用户,自定义组,拥有组的最大权 限),而非传统的组权限 </p>
<p>getfacl 可看到特殊权限:flags </p>
<p>通过ACL赋予目录默认x权限,目录内文件也不会继承x权限 </p>
<p>base ACL 不能删除 </p>
<p>setfacl -k dir 删除默认ACL权限 </p>
<p>setfacl –b file1清除所有ACL权限 </p>
<p>getfacl file1 | setfacl –set-file=- file2 复制file1的acl权限给file2 </p>
<p>mask只影响除所有者和other的之外的人和组的最大权限 </p>
<p>Mask需要与用户的权限进行逻辑与运算后,才能变成有限的权限(Effective Permission) </p>
<p>用户或组的设置必须存在于mask权限设定范围内才会生效 </p>
<pre><code>setfacl -m mask::rx file </code></pre><p>–set选项会把原有的ACL项都删除,用新的替代,需要注意的是一定要包含 UGO的设置,不能象-m一样只是添加ACL就可以 </p>
<p>示例: </p>
<pre><code>setfacl --set u::rw,u:mark:rw,g::r,o::- file1 </code></pre><p>备份和恢复ACL </p>
<p>主要的文件操作命令cp和mv都支持ACL,只是cp命令需要加上-p 参数。但是 tar等常见的备份工具是不会保留目录和文件的ACL信息 </p>
<pre><code>getfacl -R /tmp/dir1 &gt; acl.txt 

setfacl -R -b /tmp/dir1 

setfacl -R --set-file=acl.txt  /tmp/dir1 

setfacl --restore acl.txt 

getfacl -R /tmp/dir1 </code></pre>]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 文件管理</title>
    <url>/Linux-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h3 id="文件系统结构元素"><a href="#文件系统结构元素" class="headerlink" title="文件系统结构元素"></a>文件系统结构元素</h3><p>文件和目录被组织成一个单根倒置树结构 </p>
<p>文件系统从根目录下开始,用“/”表示 </p>
<p>根文件系统(rootfs):root filesystem </p>
<p>文件名称<strong>区分大小写</strong> </p>
<p>以.开头的文件为隐藏文件 </p>
<p>路径分隔的 / 文件有两类数据: </p>
<p>​    元数据:metadata </p>
<p>​    数据:data </p>
<p>文件系统分层结构:LSB Linux Standard Base </p>
<p>FHS: (Filesystem Hierarchy Standard) <a href="http://www.pathname.com/fhs/" target="_blank" rel="noopener">http://www.pathname.com/fhs/</a> </p>
<h4 id="文件名规则"><a href="#文件名规则" class="headerlink" title="文件名规则"></a>文件名规则</h4><p>文件名最长255个字节 </p>
<p>包括路径在内文件名称最长4095个字节 </p>
<p>蓝色–&gt;目录 绿色–&gt;可执行文件 红色–&gt;压缩文件 浅蓝色–&gt;链接文 件 灰色–&gt;其他文件 </p>
<p>除了斜杠和NUL,所有字符都有效.但使用特殊字符的目录名和文件不推荐使用, 有些字符需要用引号来引用它们。 </p>
<p>标准Linux文件系统(如ext4),文件名称大小写敏感。例如: MAIL, Mail, mail, mAiL </p>
<h4 id="文件系统结构"><a href="#文件系统结构" class="headerlink" title="文件系统结构"></a>文件系统结构</h4><p>/boot:引导文件存放目录,内核文件(vmlinuz)、引导加载器(bootloader, grub)都存放于此目录    /bin:供所有用户使用的基本命令；不能关联至独立分区,OS启动即会用到的 程序 </p>
<p>/sbin:管理类的基本命令；不能关联至独立分区,OS启动即会用到的程序 </p>
<p>/lib:启动时程序依赖的基本共享库文件以及内核模块文件(/lib/modules) </p>
<p>/lib64:专用于x86_64系统上的辅助共享库文件存放位置 </p>
<p>/etc:配置文件目录 </p>
<p>/home/USERNAME:普通用户家目录 </p>
<p>/root:管理员的家目录 </p>
<p>/media:便携式移动设备挂载点</p>
<h4 id="文件系统结构-1"><a href="#文件系统结构-1" class="headerlink" title="文件系统结构"></a>文件系统结构</h4><p>/mnt:临时文件系统挂载点 </p>
<p>/dev:设备文件及特殊文件存储位置 </p>
<p>​    b: block device,随机访问 </p>
<p>​    c: character device,线性访问 </p>
<p>/opt:第三方应用程序的安装位置 </p>
<p>/srv:系统上运行的服务用到的数据 </p>
<p>/tmp:临时文件存储位置 </p>
<h4 id="文件系统结构-2"><a href="#文件系统结构-2" class="headerlink" title="文件系统结构"></a>文件系统结构</h4><p>/usr: universal shared, read-only data </p>
<p>​    bin: 保证系统拥有完整功能而提供的应用程序 </p>
<p>​    sbin: lib:32位使用 </p>
<p>​    lib64:只存在64位系统 </p>
<p>​    include: C程序的头文件(header files) </p>
<p>​    share:结构化独立的数据,例如doc, man等 </p>
<p>​    local:第三方应用程序的安装位置 </p>
<p>​    bin, sbin, lib, lib64, etc, share </p>
<p>/var: variable data files </p>
<p>​    cache: 应用程序缓存数据目录 </p>
<p>​    lib: 应用程序状态信息数据 </p>
<p>​    local:专用于为/usr/local下的应用程序存储可变数据； </p>
<p>​    lock: 锁文件 </p>
<p>​    log: 日志目录及文件 </p>
<p>​    opt: 专用于为/opt下的应用程序存储可变数据； </p>
<p>​    run: 运行中的进程相关数据,通常用于存储进程pid文件 </p>
<p>​    spool: 应用程序数据池 </p>
<p>​    tmp: 保存系统两次重启之间产生的临时数据 </p>
<p>/proc: 用于输出内核与进程信息相关的虚拟文件系统 </p>
<p>/sys:用于输出当前系统上硬件设备相关信息虚拟文件系统 </p>
<p>/selinux: security enhanced Linux,selinux相关的安全策略等信息的存储位置 </p>
<h4 id="Linux上应用程序的组成部分"><a href="#Linux上应用程序的组成部分" class="headerlink" title="Linux上应用程序的组成部分"></a>Linux上应用程序的组成部分</h4><p>二进制程序:/bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin </p>
<p>库文件:/lib, /lib64, /usr/lib, /usr/lib64, /usr/local/lib, /usr/local/lib64 </p>
<p>配置文件:/etc, /etc/DIRECTORY, /usr/local/etc </p>
<p>帮助文件:/usr/share/man, /usr/share/doc, /usr/local/share/man, /usr/local/share/doc </p>
<h4 id="Linux下的文件类型"><a href="#Linux下的文件类型" class="headerlink" title="Linux下的文件类型"></a>Linux下的文件类型</h4><p>   -:普通文件 </p>
<p>   d: 目录文件 </p>
<p>   b: 块设备 </p>
<p>   c: 字符设备 </p>
<p>   l: 符号链接文件 </p>
<p>   p: 管道文件pipe </p>
<p>   s: 套接字文件socket </p>
<h4 id="CentOS-7-目录变化"><a href="#CentOS-7-目录变化" class="headerlink" title="CentOS 7 目录变化"></a>CentOS 7 目录变化</h4><p>   /bin 和 /usr/bin </p>
<p>   /sbin 和 /usr/sbin </p>
<p>   /lib 和/usr/lib </p>
<p>   /lib64 和 /usr/lib64  </p>
<h4 id="显示当前工作目录"><a href="#显示当前工作目录" class="headerlink" title="显示当前工作目录"></a>显示当前工作目录</h4><p>   每个shell和系统进程都有一个当前的工作目录 </p>
<p>   CWD:current work directory </p>
<p>   显示当前shell CWD的绝对路径 </p>
<p>pwd: printing working directory </p>
<p>​    -P 显示真实物理路径 </p>
<p>​    -L 显示链接路径(默认)</p>
<h4 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h4><p>​    绝对路径 </p>
<p>​    / 以正斜杠开始 </p>
<p>​    可以用于完整的文件的位置路径 </p>
<p>​    可用于任何想指定一个文件名的时候 </p>
<p>   相对路径名 </p>
<p>​    不以斜线开始 </p>
<p>​    指定相对于当前工作目录或某目录的位置 </p>
<p>​    可以作为一个简短的形式指定一个文件名 </p>
<p>   基名:basename </p>
<p>   目录名:dirname </p>
<h4 id="更改目录"><a href="#更改目录" class="headerlink" title="更改目录"></a>更改目录</h4><p>   cd 改变目录 </p>
<p>使用绝对或相对路径: </p>
<p>​    cd /home/mark/ </p>
<p>​    cd home/mark </p>
<p>切换至父目录: cd .. </p>
<p>切换至当前用户主目录: cd </p>
<p>切换至以前的工作目录: cd - </p>
<p>   选项:-P </p>
<p>   相关的环境变量: </p>
<p>​    PWD:当前目录路径 </p>
<p>​    OLDPWD:上一次目录路径 </p>
<h4 id="列出目录内容"><a href="#列出目录内容" class="headerlink" title="列出目录内容"></a>列出目录内容</h4><p>   列出当前目录的内容或指定目录 </p>
<p>   用法:ls [options][files_or_dirs] </p>
<p>   示例: </p>
<p>​    ls -a 包含隐藏文件 </p>
<p>​    ls -l 显示额外的信息 </p>
<p>​    ls -R 目录递归通过 </p>
<p>​    ls -ld 目录和符号链接信息 </p>
<p>​    ls -1 文件分行显示 </p>
<p>​    ls –S 按从大到小排序 </p>
<p>​    ls –t 按mtime排序 </p>
<p>​    ls –u 配合-t选项,显示并按atime从新到旧排序 </p>
<p>​    ls –U 按目录存放顺序显示 </p>
<p>​    ls –X 按文件后缀排序 </p>
<h4 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h4><p>   stat </p>
<p>   文件:metadata, data </p>
<p>   三个时间戳: </p>
<p>​    access time:访问时间,atime,读取文件内容 </p>
<p>​    modify time: 修改时间, mtime,改变文件内容(数据) </p>
<p>​    change time: 改变时间, ctime,元数据发生改变 </p>
<h4 id="文件通配符"><a href="#文件通配符" class="headerlink" title="文件通配符"></a>文件通配符</h4><p>*<em>匹配零个或多个字符 *</em></p>
<p>? : 匹配任何单个字符 </p>
<p>~ : 当前用户家目录 </p>
<p>​    ~mark 用户mark家目录 </p>
<p>~+ : 当前工作目录 </p>
<p>~- : 前一个工作目录 </p>
<p>[0-9] 匹配数字范围 </p>
<p>[a-z]:字母</p>
<p>[A-Z]:字母</p>
<p>[mark] 匹配列表中的任何的一个字符 </p>
<p>[^mark] 匹配列表中的所有字符以外的字符 </p>
<p>预定义的字符类:man 7 glob</p>
<p>[:digit:]:任意数字,相当于0-9</p>
<p>[:lower:]:任意小写字母</p>
<p>[:upper:]: 任意大写字母 </p>
<p>[:alpha:]: 任意大小写字母 </p>
<p>[:alnum:]:任意数字或字母</p>
<p>[:blank:]:水平空白字符</p>
<p>[:space:]:水平或垂直空白字符</p>
<p>[:punct:]:标点符号</p>
<p>[:print:]:可打印字符</p>
<p>[:cntrl:]:控制(非打印)字符</p>
<p>[:graph:]:图形字符</p>
<p>[:xdigit:]:十六进制字符</p>
<h4 id="创建空文件和刷新时间"><a href="#创建空文件和刷新时间" class="headerlink" title="创建空文件和刷新时间"></a>创建空文件和刷新时间</h4><p>   touch命令: </p>
<p>​   touch [OPTION]… FILE… </p>
<p>​    -a 仅改变 atime和ctime </p>
<p>​    -m 仅改变 mtime和ctime </p>
<p>​    -t [[CC]YY]MMDDhhmm[.ss] 指定atime和mtime的时间戳 </p>
<p>​        touch -t 200909010059.30 marktest.sh  //#将文件时间属性改为9月1号0点59分30秒         </p>
<p>​    -c 如果文件不存在,则不予创建</p>
<h3 id="复制转移和删除文件"><a href="#复制转移和删除文件" class="headerlink" title="复制转移和删除文件"></a>复制转移和删除文件</h3><h4 id="复制文件和目录-CP"><a href="#复制文件和目录-CP" class="headerlink" title="复制文件和目录 CP"></a>复制文件和目录 CP</h4><p>   cp [OPTION]… [-T] SOURCE DEST </p>
<p>   cp [OPTION]… SOURCE… DIRECTORY </p>
<p>   cp [OPTION]… -t DIRECTORY SOURCE… </p>
<p>   cp SRC DEST </p>
<p>SRC是文件: </p>
<p>​    如果目标不存在:新建DEST,并将SRC中内容填充至DEST中 </p>
<p>​    如果目标存在: </p>
<p>​        如果DEST是文件:将SRC中的内容覆盖至DEST中 </p>
<p>​            基于安全,建议为cp命令使用-i选项 </p>
<p>​        如果DEST是目录:在DEST下新建与原文件同名的文件,并将SRC中内容填 充至新文件中 </p>
<pre><code>cp SRC... DEST </code></pre><p>SRC…:多个文件 </p>
<p>​    DEST必须存在,且为目录,其它情形均会出错； </p>
<pre><code>cp SRC DEST </code></pre><p>​    SRC是目录:此时使用选项:-r </p>
<p>​        如果DEST不存在:则创建指定目录,复制SRC目录中所有文件至DEST中； </p>
<p>​        如果DEST存在: </p>
<p>​            如果DEST是文件:报错 </p>
<p>​            如果DEST是目录: </p>
<table>
<thead>
<tr>
<th>源\目标</th>
<th>不存在</th>
<th>存在且为文件</th>
<th>存在且为目录</th>
</tr>
</thead>
<tbody><tr>
<td>一个文件</td>
<td>新建DEST,并将SRC中内容填充至DEST中</td>
<td>将SRC中的内容覆盖至DEST中,存在数据丢失的风险,要加 -i</td>
<td>在DEST下新建与原文件同名的文件,并将SRC中内容填充至新文件中</td>
</tr>
<tr>
<td>多个文件</td>
<td><strong>提示错误</strong></td>
<td><strong>提示错误</strong></td>
<td>在DEST下新建与源文件同名的文件,并将源文件内容复制进新文件中</td>
</tr>
<tr>
<td>目录要用 -r 选项</td>
<td>创建指定DEST同名目录,复制SRC目录中所有文件至DEST下</td>
<td><strong>提示错误</strong></td>
<td>在DEST下新建与原 目录同名的目录， 并将SRC中内容复 制至新目录中</td>
</tr>
</tbody></table>
<h4 id="cp-常用选项"><a href="#cp-常用选项" class="headerlink" title="cp 常用选项"></a>cp 常用选项</h4><p>   -i:覆盖前提示 –n:不覆盖,注意两者顺序 </p>
<p>   -r, -R: 递归复制目录及内部的所有内容 </p>
<p>   -a: 归档,相当于-dR –preserv=all </p>
<p>   -d:–no-dereference –preserv=links 不复制原文件,只复制链接名 </p>
<p>   –preserv[=ATTR_LIST] </p>
<p>​    mode: 权限 </p>
<p>​    ownership: 属主属组 </p>
<p>​    timestamp: </p>
<p>​    links </p>
<p>​    xattr </p>
<p>​    context </p>
<p>​    all </p>
<p>   -p: 等同–preserv=mode,ownership,timestamp </p>
<p>   -v: –verbose </p>
<p>   -f: –force </p>
<p>   -u:–update 只复制源比目标更新文件或目标不存在的文件 </p>
<p>   –backup=numbered 目标存在,覆盖前先备份加数字后缀 </p>
<h4 id="移动和重命名文件"><a href="#移动和重命名文件" class="headerlink" title="移动和重命名文件"></a>移动和重命名文件</h4><p>   mv [OPTION]… [-T] SOURCE DEST </p>
<p>   mv [OPTION]… SOURCE… DIRECTORY </p>
<p>   mv [OPTION]… -t DIRECTORY SOURCE… </p>
<p>​    常用选项: </p>
<p>​        -i: 交互式</p>
<p>​        -f: 强制 </p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>   rm [OPTION]… FILE… </p>
<p>   常用选项: </p>
<p>​    -i 交互式 </p>
<p>​    -f 强制删除 </p>
<p>​    -r 递归 </p>
<p>​    –no-preserve-root 删除/ </p>
<p>   示例: rm -rf / </p>
<h4 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h4><p>   tree 显示目录树 </p>
<p>​    -d: 只显示目录 </p>
<p>​    -L level:指定显示的层级数目 </p>
<p>​    -P pattern: 只显示由指定pattern匹配到的路径 </p>
<p>   mkdir 创建目录 </p>
<p>​    -p: 存在于不报错,且可自动创建所需的各目录 </p>
<p>​    -v: 显示详细信息 </p>
<p>​    -m MODE: 创建目录时直接指定权限 </p>
<p>   rmdir 删除空目录 </p>
<p>​    -p: 递归删除父空目录 </p>
<p>​    -v: 显示详细信息 </p>
<p>   rm -r 递归删除目录树 </p>
<h3 id="索引节点"><a href="#索引节点" class="headerlink" title="索引节点"></a>索引节点</h3><p>​    inode(index node)表中包含文件系统所有文件列表 </p>
<p>   一个节点 (索引节点)是在一个表项,包含有关文件的信息( 元数据 ),包 括: </p>
<p>​    文件类型,权限,UID,GID </p>
<p>​    链接数(指向这个文件名路径名称个数) </p>
<p>​    该文件的大小和不同的时间戳 </p>
<p>​    指向磁盘上文件的数据块指针 </p>
<p>​    有关文件的其他数据 </p>
<p>详情查看<a href="http://www.ruanyifeng.com/blog/2011/12/inode.html" target="_blank" rel="noopener">inode表结构</a></p>
<h4 id="cp和inode"><a href="#cp和inode" class="headerlink" title="cp和inode"></a>cp和inode</h4><p>   在 CP的 命令: </p>
<p>​    分配一个空闲的inode号,在inode表中生成新条目 在目录中创建一个目录项,将名称与inode编号关联 拷贝数据生成新的文件 </p>
<h4 id="rm和inode"><a href="#rm和inode" class="headerlink" title="rm和inode"></a>rm和inode</h4><p>rm 命令: </p>
<p>​    链接数递减,从而释放的inode号可以被重用 </p>
<p>​    把数据块放在空闲列表中 </p>
<p>​    删除目录项 </p>
<p>​    数据实际上不会马上被删除,但当另一个文件使用数据块时将被覆盖。</p>
<h4 id="mv和inode"><a href="#mv和inode" class="headerlink" title="mv和inode"></a>mv和inode</h4><p>​    如果mv命令的目标和源在相同的文件系统,作为mv 命令 </p>
<p>​    用新的文件名创建对应新的目录项 </p>
<p>​    删除旧目录条目对应的旧的文件名 </p>
<p>​    不影响inode表(除时间戳)或磁盘上的数据位置:没有数据被移动！ </p>
<p>   如果目标和源在一个不同的文件系统, mv相当于cp和rm </p>
<h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>   创建硬链接会增加额外的记录项以引用文件 </p>
<p>   对应于同一文件系统上一个物理文件 </p>
<p>   每个目录引用相同的inode号 </p>
<p>   创建时链接数递增 </p>
<p>   删除文件时,rm命令递减计数的链接 </p>
<p>   文件要存在,至少有一个链接数 </p>
<p>   当链接数为零时,该文件被删除 </p>
<p>   不能跨越驱动器或分区 </p>
<p>   语法: ln filename [linkname ] </p>
<h3 id="符号-软-链接"><a href="#符号-软-链接" class="headerlink" title="符号(软)链接"></a>符号(软)链接</h3><p>   一个符号链接指向另一个文件 </p>
<p>   ls - l的 显示链接的名称和引用的文件 </p>
<p>   一个符号链接的内容是它引用文件的名称 </p>
<p>   可以对目录进行 </p>
<p>   可以跨分区 </p>
<p>   指向的是另一个文件的路径；其大小为指向的路径字符串的长度；不增加或减 少目标文件inode的引用计数； </p>
<p>   语法: ln -s filename [linkname] </p>
<h3 id="确定文件内容"><a href="#确定文件内容" class="headerlink" title="确定文件内容"></a>确定文件内容</h3><p>文件可以包含多种类型的数据 </p>
<p>   检查文件的类型,然后确定适当的打开命令或应用程序使用 </p>
<p>   file [options] … </p>
<p>   常用选项: </p>
<p>​    -b 列出文件辨识结果时,不显示文件名称 </p>
<p>​    -f filelist 列出文件filelist中文件名的文件类型 </p>
<p>​    -F 使用指定分隔符号替换输出文件名后默认的”:”分隔符 </p>
<p>​    -L 查看对应软链接对应文件的文件类型 </p>
<p>​    –help 显示命令在线帮助 </p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 文本处理工具(二)</title>
    <url>/Linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7-%E4%BA%8C/</url>
    <content><![CDATA[<h3 id="VIM简介"><a href="#VIM简介" class="headerlink" title="VIM简介"></a>VIM简介</h3><p>vi: Visual Interface,文本编辑器 </p>
<p>文本:ASCII, Unicode </p>
<p>文本编辑种类: </p>
<pre><code>行编辑器: sed 

全屏编辑器:nano, vi 

vim - Vi Improved </code></pre><p>其他编辑器: </p>
<pre><code>gedit 一个简单的图形编辑器 

gvim 一个Vim编辑器的图形版本 </code></pre><h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><p>vim [OPTION]… FILE…</p>
<pre><code>+#: 打开文件后,让光标处于第#行的行首,+默认行尾 

+/PATTERN:打开文件后,直接让光标处于第一个被PATTERN匹配到的行的行首 

–b file 二进制方式打开文件 

–d file1 file2… 比较多个文件 

-m file 只读打开文件 </code></pre><p>ex file 或 vim –e 直接进入ex模式 </p>
<p>如果该文件存在,文件被打开并显示内容 如果该文件不存在,当编辑后第一次存盘时创建它 </p>
<h4 id="vim-一个模式编辑器"><a href="#vim-一个模式编辑器" class="headerlink" title="vim: 一个模式编辑器"></a>vim: 一个模式编辑器</h4><p>击键行为是依赖于 vim的 的”模式” </p>
<p>三种主要模式: </p>
<pre><code>命令(Normal)模式:默认模式,移动光标,剪切/粘贴文本 

插入(Insert)或编辑模式: 修改文本 

扩展命令(extended command )模式: 保存,退出等 </code></pre><p>Esc键 退出当前模式 </p>
<p>Esc键 Esc键 总是返回到命令模式 </p>
<h4 id="模式转换"><a href="#模式转换" class="headerlink" title="模式转换"></a>模式转换</h4><p>命令模式 –&gt; 插入模式 </p>
<pre><code>i: insert, 在光标所在处输入 

I:在当前光标所在行的行首输入 

a: append, 在光标所在处后面输入 

A:在当前光标所在行的行尾输入 

o: 在当前光标所在行的下方打开一个新行 

O:在当前光标所在行的上方打开一个新行 </code></pre><p>插入模式 ——–&gt; 命令模式 </p>
<pre><code>ESC </code></pre><p>命令模式 ——–&gt; 扩展命令模式 </p>
<pre><code>: </code></pre><p>扩展命令模式 ——–&gt; 命令模式 </p>
<pre><code>ESC,enter </code></pre><h4 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h4><p>扩展模式: </p>
<pre><code>:q 退出 

:q! 强制退出,丢弃做出的修改 

:wq 保存退出 :x 保存退出 </code></pre><p>命令模式 </p>
<pre><code>ZZ: 保存退出 

ZQ:不保存退出 </code></pre><h4 id="扩展模式"><a href="#扩展模式" class="headerlink" title="扩展模式"></a>扩展模式</h4><p>按”:”进入Ex模式 </p>
<p>创建一个命令提示符: 处于底部的屏幕左侧 </p>
<p>命令: </p>
<pre><code>w     写(存)磁盘文件 

wq     写入并退出 

x     写入并退出 

q     退出 

q！     不存盘退出,即使更改都将丢失 

r filename     读文件内容到当前文件中 

w filename     将当前文件内容写入另一个文件 

!command     执行命令 

r!command     读入命令的输出 </code></pre><h4 id="命令模式光标跳转"><a href="#命令模式光标跳转" class="headerlink" title="命令模式光标跳转"></a>命令模式光标跳转</h4><p>字符间跳转: </p>
<pre><code>h: 左 l: 右 j: 下 k: 上 

#COMMAND:跳转由#指定的个数的字符 </code></pre><p>单词间跳转: </p>
<pre><code>w:下一个单词的词首 

e:当前或下一单词的词尾 

b:当前或前一个单词的词首 

#COMMAND:由#指定一次跳转的单词数 </code></pre><p>当前页跳转: </p>
<pre><code>H:页首 M:页中间行 L:页底 </code></pre><p>行首行尾跳转:</p>
<pre><code>^: 跳转至行首的第一个非空白字符 

0: 跳转至行首 

$: 跳转至行尾 </code></pre><p>行间移动: </p>
<pre><code>#G、扩展模式:# :跳转至由#指定行 

G:最后一行 

1G, gg: 第一行 </code></pre><p>句间移动: </p>
<pre><code>):下一句 (:上一句 </code></pre><p>段落间移动: </p>
<pre><code>}:下一段 {:上一段 </code></pre><h4 id="命令模式翻屏操作"><a href="#命令模式翻屏操作" class="headerlink" title="命令模式翻屏操作"></a>命令模式翻屏操作</h4><p>Ctrl+f: 向文件尾部翻一屏 </p>
<p>Ctrl+b: 向文件首部翻一屏 </p>
<p>Ctrl+d: 向文件尾部翻半屏 </p>
<p>Ctrl+u:向文件首部翻半屏 </p>
<h4 id="命令模式操作"><a href="#命令模式操作" class="headerlink" title="命令模式操作"></a>命令模式操作</h4><p>字符编辑: </p>
<pre><code>x: 删除光标处的字符 

#x: 删除光标处起始的#个字符 

xp: 交换光标所在处的字符及其后面字符的位置 

~:转换大小写 

J:删除当前行后的换行符 </code></pre><p>替换命令(r, replace) </p>
<pre><code>r: 替换光标所在处的字符 

R:切换成REPLACE模式 </code></pre><p>删除命令: </p>
<pre><code>d: 删除命令,可结合光标跳转字符,实现范围删除 

d$: 删除到行尾 

d^:删除到非空行首 

d0:删除到行首 

dw: 

de: 

db: 

#COMMAND </code></pre><p>dd: 删除光标所在的行 </p>
<pre><code>#dd:多行删除 </code></pre><p>D:从当前光标位置一直删除到行尾,留空行,等同于d$ </p>
<p>复制命令(y, yank): </p>
<pre><code>y: 复制,行为相似于d命令 

y$ 

y0 

y^ 

ye 

yw 

yb 

#COMMAND </code></pre><p>yy:复制行 </p>
<pre><code>#yy: 复制多行 </code></pre><p>Y: 复制整行 </p>
<p>粘贴命令(p, paste): </p>
<pre><code>p:缓冲区存的如果为整行,则粘贴当前光标所在行的下方;否则,则粘贴 至当前光标所在处的后面 

P:缓冲区存的如果为整行,则粘贴当前光标所在行的上方；否则,则粘贴 至当前光标所在处的前面 </code></pre><p> 改变命令(c, change) </p>
<pre><code>c: 修改后切换成插入模式 </code></pre><p> 命令模式 –&gt; 插入模式 </p>
<pre><code>c$ 

c^ 

c0 

cb 

ce 

cw 

#COMMAND </code></pre><p> cc:删除当前行并输入新内容,相当于S </p>
<pre><code>#cc: </code></pre><p> C:删除当前光标到行尾,并切换成插入模式 </p>
<h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p>100imark [ESC] 粘贴”mark”100次 </p>
<p>&lt;start position&gt;&lt;commend&gt;&lt;end position&gt; </p>
<p>Command: </p>
<pre><code>y 复制、d 删除、gU 变大写、gu 变小写 </code></pre><p>例如 0y$ 命令意味着: </p>
<pre><code>0 → 先到行头 

y → 从这里开始拷贝 

$ → 拷贝到本行最后一个字符 

ye 从当前位置拷贝到本单词的最后一个字符 </code></pre><h4 id="扩展命令模式-地址定界"><a href="#扩展命令模式-地址定界" class="headerlink" title="扩展命令模式:地址定界"></a>扩展命令模式:地址定界</h4><p>地址定界 </p>
<pre><code>:start_pos,end_pos 

\# 具体第#行,例如2表示第2行 

\#,# 从左侧#表示起始行,到右侧#表示结尾行 

\#,+# 从左侧#表示的起始行,加上右侧#表示的行数 

    :2,+3 表示2到5行

 . 当前行 

$ 最后一行 

    .,$-1 当前行到倒数第二行 

% 全文, 相当于1,$ </code></pre><p>/pat1/,/pat2/ </p>
<pre><code>从第一次被pat1模式匹配到的行开始,一直到第一次被pat2匹配到的行结 束 

#,/pat/ 

/pat/,$ </code></pre><p>使用方式:后跟一个编辑命令 </p>
<pre><code>d 

y 

w file: 将范围内的行另存至指定文件中 

r file:在指定位置插入指定文件中的所有内容 </code></pre><h4 id="扩展命令模式-查找"><a href="#扩展命令模式-查找" class="headerlink" title="扩展命令模式:查找"></a>扩展命令模式:查找</h4><p>查找 </p>
<pre><code>/PATTERN:从当前光标所在处向文件尾部查找 

?PATTERN:从当前光标所在处向文件首部查找 

n:与命令同方向 

N:与命令反方向 </code></pre><h4 id="扩展命令模式-查找并替换"><a href="#扩展命令模式-查找并替换" class="headerlink" title="扩展命令模式:查找并替换"></a>扩展命令模式:查找并替换</h4><p>s: 在扩展模式下完成查找替换操作 </p>
<pre><code>格式:s/要查找的内容/替换为的内容/修饰符 

要查找的内容:可使用模式 

替换为的内容:不能使用模式,但可以使用\1, \2, ...等后向引用符号；还可 以使用&quot;&amp;&quot;引用前面查找时查找到的整个内容 

修饰符: 

i: 忽略大小写 

g: 全局替换；默认情况下,每一行只替换第一次出现 

gc:全局替换,每次替换前询问 </code></pre><p>查找替换中的分隔符/可替换为其它字符,例如 </p>
<pre><code>s@/etc@/var@g 

s#/boot#/#i </code></pre><h4 id="命令模式-撤销更改"><a href="#命令模式-撤销更改" class="headerlink" title="命令模式:撤销更改"></a>命令模式:撤销更改</h4><p>u    撤销最近的更改 </p>
<p>#u    撤销之前多次更改 </p>
<p>U     撤消光标落在这行后所有此行的更改 </p>
<p>按Ctrl - r重做最后的”撤消”更改 </p>
<p>.     重复前一个操作 </p>
<p>n.    重复前一个操作n次 </p>
<h4 id="vim的寄存器"><a href="#vim的寄存器" class="headerlink" title="vim的寄存器"></a>vim的寄存器</h4><p>有26个命名寄存器和1个无命名寄存器,常存放不同的剪贴版内容,可以不同会话间共享 </p>
<p>寄存器名称a,b,…,z,格式:”寄存器 放在数字和命令之间 </p>
<pre><code>如:3&quot;tyy 表示复制3行到t寄存器中  

&quot;tp 表示将t寄存器内容粘贴 </code></pre><p>未指定,将使用无命名寄存器 </p>
<p>有10个数字寄存器,用0,1,…,9表示,0存放最近复制内容,1存放最近删除内容。当新的文本变更和删除时,1转存到2,2转存到3,以此类推。数字寄存器不能在不 同会话间共享 </p>
<h4 id="编辑二进制文件"><a href="#编辑二进制文件" class="headerlink" title="编辑二进制文件"></a>编辑二进制文件</h4><p>以二进制方式打开文件 </p>
<pre><code>vim –b binaryfile </code></pre><p>扩展命令模式下,利用xxd命令转换为可读的十六进制 </p>
<pre><code>:%!xxd </code></pre><p>编辑二进制文件 </p>
<p>扩展命令模式下,利用xxd命令转换回二进制 </p>
<pre><code>:%!xxd –r </code></pre><p>保存退出</p>
<h4 id="可视化模式"><a href="#可视化模式" class="headerlink" title="可视化模式"></a>可视化模式</h4><p>允许选择的文本块 </p>
<pre><code>v 面向字符 

V 面向行 

ctrl-v 面向块 </code></pre><p>可视化键可用于与移动键结合使用: </p>
<pre><code>w ) } 箭头等 </code></pre><p>突出显示的文字可被删除,复制,变更,过滤,搜索,替换等</p>
<h4 id="多文件模式"><a href="#多文件模式" class="headerlink" title="多文件模式"></a>多文件模式</h4><p>vim FILE1 FILE2 FILE3 … </p>
<pre><code>:next 下一个 

:prev 前一个 

:first 第一个 

:last 最后一个 

:wall 保存所有 

:qall 退出所有 

:wqall 保存退出所有</code></pre><h4 id="使用多个窗口"><a href="#使用多个窗口" class="headerlink" title="使用多个窗口"></a>使用多个窗口</h4><p>多文件分割 </p>
<pre><code>vim -o|-O FILE1 FILE2 ... 

-o: 水平分割 

-O: 垂直分割 

在窗口间切换:Ctrl+w, Arrow </code></pre><p>单文件窗口分割: </p>
<pre><code>Ctrl+w,s: split, 水平分割 

Ctrl+w,v: vertical, 垂直分割 

ctrl+w,q:取消相邻窗口 

ctrl+w,o:取消全部窗口 

:wqall 退出 </code></pre><h4 id="定制vim的工作特性"><a href="#定制vim的工作特性" class="headerlink" title="定制vim的工作特性"></a>定制vim的工作特性</h4><p>配置文件:永久有效 </p>
<pre><code>全局:/etc/vimrc 

个人:~/.vimrc </code></pre><p>扩展模式:当前vim进程有效 </p>
<p>(1) 行号 </p>
<pre><code>显示:set number, 简写为set nu 

取消显示:set nonumber, 简写为set nonu </code></pre><p>(2) 忽略字符的大小写 </p>
<pre><code>启用:set ic 

不忽略:set noic </code></pre><p>(3) 自动缩进 </p>
<pre><code>启用:set ai 

禁用:set noai</code></pre><p>(4) 智能缩进 </p>
<pre><code>启用:smartindent 简写 set si 

禁用:set nosi </code></pre><p>(5) 高亮搜索 </p>
<pre><code>启用:set hlsearch 

禁用:set nohlsearch </code></pre><p>(6) 语法高亮 </p>
<pre><code>启用:syntax on 

禁用:syntax off </code></pre><p>(7) 显示Tab和换行符 ^I 和$显示 </p>
<pre><code>启用:set list 

禁用:set nolist </code></pre><p>(8) 文件格式 </p>
<pre><code>启用windows格式:set fileformat=dos 

启用unix格式:set fileformat=unix 

简写: set ff=dos|unix </code></pre><p>(9) 设置文本宽度 </p>
<pre><code>启用: set textwidth=65 (vim only) 

禁用: set wrapmargin=15 </code></pre><p>(10) 设置光标所在行的标识线 </p>
<pre><code>启用:set cursorline,简写cul 

禁用:set no cursorline </code></pre><p>(11) 复制保留格式 </p>
<pre><code>启用: set paste 

禁用: set nopaste </code></pre><h4 id="了解更多"><a href="#了解更多" class="headerlink" title="了解更多"></a>了解更多</h4><p>Set 帮助 </p>
<pre><code>:help option-list 

:set or :set all </code></pre><p>vi/vim内置帮助 </p>
<pre><code>:help 

:help topic 

Use :q to exit help </code></pre><p>vimtutor </p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 文本处理工具(一)</title>
    <url>/Linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7-%E4%B8%80/</url>
    <content><![CDATA[<h3 id="抽取文本的工具"><a href="#抽取文本的工具" class="headerlink" title="抽取文本的工具"></a>抽取文本的工具</h3><p>文件内容:less和 cat</p>
<p>文件截取:head和tail </p>
<p>按列抽取:cut </p>
<p>按关键字抽取:grep</p>
<h4 id="文件查看"><a href="#文件查看" class="headerlink" title="文件查看"></a>文件查看</h4><p>文件查看命令 : </p>
<p>cat ,tac ,rev </p>
<p>cat [OPTION]… [FILE]… </p>
<pre><code>-E: 显示行结束符$ 

-n: 对显示出的每一行进行编号 

-A:显示所有控制符 

-b:非空行编号 

-s:压缩连续的空行成一行 </code></pre><p>tac </p>
<p>rev </p>
<h4 id="分页查看文件内容"><a href="#分页查看文件内容" class="headerlink" title="分页查看文件内容"></a>分页查看文件内容</h4><p>more: 分页查看文件 </p>
<p>more [OPTIONS…] FILE… </p>
<pre><code>-d: 显示翻页及退出提示 </code></pre><p>less:一页一页地查看文件或STDIN输出 </p>
<p>查看时有用的命令包括: </p>
<pre><code>/文本 搜索 文本 

n/N 跳到下一个 或 上一个匹配 </code></pre><p>less 命令是man命令使用的分页器 </p>
<h4 id="显示文本前或后行内容"><a href="#显示文本前或后行内容" class="headerlink" title="显示文本前或后行内容"></a>显示文本前或后行内容</h4><p>head [OPTION]… [FILE]… </p>
<pre><code>-c #: 指定获取前#字节 

-n #: 指定获取前#行 

-#: 指定行数 </code></pre><p>tail [OPTION]… [FILE]… </p>
<pre><code>-c #: 指定获取后#字节 </code></pre><p>​    -n #: 指定获取后#行 </p>
<pre><code>-f: 跟踪显示文件fd新追加的内容,常用日志监控 

相当于 --follow=descriptor 

-F: 跟踪文件名,相当于—follow=name --retry     </code></pre><p>tailf 类似tail –f,当文件不增长时并不访问文件 </p>
<h4 id="按列抽取文本cut和合并文件paste"><a href="#按列抽取文本cut和合并文件paste" class="headerlink" title="按列抽取文本cut和合并文件paste"></a>按列抽取文本cut和合并文件paste</h4><p>cut [OPTION]… [FILE]… </p>
<pre><code>-d DELIMITER: 指明分隔符,默认tab </code></pre><p>​    -f FILEDS:     </p>
<p>​        #: 第#个字段 </p>
<p>​        #,#[,#]:离散的多个字段,例如1,3,6     </p>
<pre><code>#-#:连续的多个字段, 例如1-6 </code></pre><p>混合使用:1-3,7 </p>
<p>-c 按字符切割 </p>
<p>–output-delimiter=STRING指定输出分隔符 </p>
<h4 id="cut和paste"><a href="#cut和paste" class="headerlink" title="cut和paste"></a>cut和paste</h4><p>显示文件或STDIN数据的指定列 </p>
<p>​    cut -d: -f1 /etc/passwd        //以 : 为分隔符取出第一个参数</p>
<pre><code>cat /etc/passwd | cut -d: -f7 </code></pre><p>​    cut -c2-5 /usr/share/dict/words </p>
<p>paste 合并两个文件同行号的列到一行 </p>
<pre><code>paste [OPTION]... [FILE]... </code></pre><p>​    -d 分隔符:指定分隔符,默认用TAB </p>
<p>​    -s : 所有行合成一行显示 </p>
<p>​    paste f1 f2 </p>
<p>​    paste -s f1 f2         </p>
<h3 id="分析文本的工具"><a href="#分析文本的工具" class="headerlink" title="分析文本的工具"></a>分析文本的工具</h3><p>文本数据统计:wc </p>
<p>整理文本:sort </p>
<p>比较文件:diff和patch </p>
<h4 id="收集文本统计数据wc"><a href="#收集文本统计数据wc" class="headerlink" title="收集文本统计数据wc"></a>收集文本统计数据wc</h4><p>计数单词总数、行总数、字节总数和字符总数 </p>
<p>可以对文件或STDIN中的数据运行 </p>
<pre><code>wc story.txt 

39     237 1901     story.txt 

行数 字数 字节数  文件名</code></pre><p>常用选项 </p>
<p>​    -l    只计数行数 </p>
<p>​    -w     只计数单词总数 </p>
<p>​    -c     只计数字节总数 </p>
<p>​    -m     只计数字符总数 </p>
<p>​    -L     显示文件中最长行的长度     </p>
<h4 id="文本排序sort"><a href="#文本排序sort" class="headerlink" title="文本排序sort"></a>文本排序sort</h4><p>把整理过的文本显示在STDOUT,不改变原始文件 </p>
<pre><code>sort [options] file(s) </code></pre><p>常用选项 </p>
<p>​    -r     执行反方向(由上至下)整理 </p>
<p>​    -R     随机排序 </p>
<p>​    -n     执行按数字大小整理 </p>
<p>​    -f     选项忽略(fold)字符串中的字符大小写 </p>
<p>​    -u     选项(独特,unique)删除输出中的重复行 </p>
<p>​    -t c     选项使用c做为字段界定符 </p>
<p>​    -k X 选项按照使用c字符分隔的X列来整理能够使用多次     </p>
<h4 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h4><p>uniq命令:从输入中删除前后相接的重复的行 </p>
<p>uniq [OPTION]… [FILE]… </p>
<p>​    -c:     显示每行重复出现的次数 </p>
<p>​    -d:     仅显示重复过的行 </p>
<p>​    -u:     仅显示不曾重复的行 </p>
<p>​    注:连续且完全相同方为重复     </p>
<p>常和sort 命令一起配合使用: </p>
<pre><code>sort userlist.txt | uniq -c </code></pre><h4 id="比较文件"><a href="#比较文件" class="headerlink" title="比较文件"></a>比较文件</h4><p>比较两个文件之间的区别 </p>
<pre><code>diff foo.conf foo2.conf 

5c5 

&lt; use_widgets = no 

--- 

&gt; use_widgets = yes </code></pre><p>注明第5行有区别(改变) </p>
<h4 id="复制对文件改变patch"><a href="#复制对文件改变patch" class="headerlink" title="复制对文件改变patch"></a>复制对文件改变patch</h4><p>diff 命令的输出被保存在一种叫做”补丁”的文件中 </p>
<pre><code>使用 -u 选项来输出&quot;统一的(unified)&quot;diff格式文件,最适用于补丁文件 </code></pre><p>patch 复制在其它文件中进行的改变(要谨慎使用) </p>
<pre><code>适用 -b 选项来自动备份改变了的文件 

$ diff -u foo.conf foo2.conf &gt; foo.patch 

$ patch -b foo.conf foo.patch </code></pre><h3 id="Linux文本处理三剑客"><a href="#Linux文本处理三剑客" class="headerlink" title="Linux文本处理三剑客"></a>Linux文本处理三剑客</h3><p>grep:文本过滤(模式:pattern)工具 </p>
<pre><code>grep, egrep, fgrep(不支持正则表达式搜索) </code></pre><p>sed:stream editor,文本编辑工具 </p>
<p>awk:Linux上的实现gawk,文本报告生成器 </p>
<h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p>grep: Global search REgular expression and Print out the line </p>
<p>作用:文本搜索工具,根据用户指定的”模式”对目标文本逐行进行匹配检 查；打印匹配到的行 </p>
<p>模式:由正则表达式字符及文本字符所编写的过滤条件     </p>
<p>grep [OPTIONS] PATTERN [FILE…] </p>
<pre><code>grep root /etc/passwd 

grep &quot;$USER&quot; /etc/passwd 

grep &apos;$USER&apos; /etc/passwd 

grep \`whoami` /etc/passwd </code></pre><h4 id="grep命令选项"><a href="#grep命令选项" class="headerlink" title="grep命令选项"></a>grep命令选项</h4><pre><code>--color=auto: 对匹配到的文本着色显示 

-v: 显示不被pattern匹配到的行 

-i: 忽略字符大小写 

-n:显示匹配的行号 

-c: 统计匹配的行数 

-o: 仅显示匹配到的字符串 

-q: 静默模式,不输出任何信息 

-A #: after, 后#行 

-B #: before, 前#行 

-C #:context, 前后各#行 

-e:实现多个选项间的逻辑or关系 

   grep –e ‘cat ’ -e ‘dog’ file 

-w:匹配整个单词 

-E:使用ERE 

   使用正则表达式

-F:相当于fgrep,不支持正则表达式 

   可以测试文件1和文件2的包含关系</code></pre><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>REGEXP:由一类特殊字符及文本字符所编写的模式,其中有些字符(元字符)不表示字符字面意义,而表示控制或通配的功能 </p>
<p>程序支持:grep,sed,awk,vim, less,nginx,varnish等 </p>
<p>分两类: </p>
<p>基本正则表达式:BRE </p>
<p>扩展正则表达式:ERE </p>
<pre><code>grep -E, egrep </code></pre><p>正则表达式引擎: </p>
<p>采用不同算法,检查处理正则表达式的软件模块 </p>
<p>PCRE(Perl Compatible Regular Expressions) </p>
<p>元字符分类:字符匹配、匹配次数、位置锚定、分组 </p>
<p>man 7 regex </p>
<h4 id="基本正则表达式元字符"><a href="#基本正则表达式元字符" class="headerlink" title="基本正则表达式元字符"></a>基本正则表达式元字符</h4><p> 字符匹配:<br>​    . 匹配任意单个字符<br>​    [] 匹配指定范围内的任意单个字符<br>​    [^] 匹配指定范围外的任意单个字符<br>​    [:alnum:] 字母和数字<br>​    [:alpha:] 代表任何英文大小写字符,亦即 A-Z, a-z<br>​    [:lower:] 小写字母 [:upper:] 大写字母<br>​    [:blank:] 空白字符(空格和制表符)<br>​    [:space:] 水平和垂直的空白字符(比[:blank:]包含的范围广)<br>​    [:cntrl:] 不可打印的控制字符(退格、删除、警铃…)<br>​    [:digit:] 十进制数字 [:xdigit:]十六进制数字<br>​    [:graph:] 可打印的非空白字符<br>​    [:print:] 可打印字符<br>​    [:punct:] 标点符号</p>
<h4 id="正则表达式-1"><a href="#正则表达式-1" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>匹配次数:用在要指定次数的字符后面,用于指定前面的字符要出现的次数 </p>
<p>位置锚定:定位出现的位置 </p>
<p>^                 行首锚定,用于模式的最左侧 </p>
<p>$                行尾锚定,用于模式的最右侧 </p>
<p>^PATTERN$         用于模式匹配整行 </p>
<p>^$                 空行 </p>
<p>^[[:space:]]*$     空白行 </p>
<p>&lt; 或 \b             词首锚定,用于单词模式的左侧 </p>
<p>&gt; 或 \b             词尾锚定；用于单词模式的右侧 </p>
<p>&lt;PATTERN\&gt;         匹配整个单词 </p>
<p>分组:\(\)             将一个或多个字符捆绑在一起,当作一个整体进行处理,如: \(root\)\+ </p>
<p>分组括号中的模式匹配到的内容会被正则表达式引擎记录于内部的变量中,这 些变量的命名方式为: \1, \2, \3, … </p>
<p>\1 表示从左侧起第一个左括号以及与之匹配右括号之间的模式所匹配到的字符 </p>
<p>示例: \(string1\+\(string2\)*\) </p>
<pre><code>\1 :string1\\+\\(string2\\)* 

\2 :string2 </code></pre><p>后向引用:引用前面的分组括号中的模式所匹配字符,而非模式本身 </p>
<p>或者:\| </p>
<pre><code>示例:a\\|b: a或b C\\|cat: C或cat \\(C\\|c\\)at:Cat或cat </code></pre><table>
<thead>
<tr>
<th>元字符</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>行首</td>
</tr>
<tr>
<td>$</td>
<td>行尾</td>
</tr>
<tr>
<td>.</td>
<td>任意单一字符</td>
</tr>
<tr>
<td>[]</td>
<td>[]内任意单一字符</td>
</tr>
<tr>
<td>[^]</td>
<td>除[]内任意单一字符</td>
</tr>
<tr>
<td>*</td>
<td>*前面字符重复不确定次数</td>
</tr>
<tr>
<td>\+</td>
<td>\+前面字符重复一次以上不确定次数</td>
</tr>
<tr>
<td>?</td>
<td>? 前面字符重复0或1次</td>
</tr>
<tr>
<td>\</td>
<td>转义符</td>
</tr>
<tr>
<td>.*</td>
<td>任意长度字符</td>
</tr>
<tr>
<td>\{n\}</td>
<td>前面字符重复n次</td>
</tr>
<tr>
<td>\{n,\}</td>
<td>前面字符重复n次以上</td>
</tr>
<tr>
<td>\{m,n\}</td>
<td>前面字符重复m次和n次之间</td>
</tr>
<tr>
<td>[:alnum:]</td>
<td>字母和数字</td>
</tr>
<tr>
<td>[:alpha:]</td>
<td>代表任何英文大小写字符,即 A-Z,a-z</td>
</tr>
<tr>
<td>[:lower:]</td>
<td>小写字母</td>
</tr>
<tr>
<td>[:upper:]</td>
<td>大写字母</td>
</tr>
<tr>
<td>[:blank:]</td>
<td>水平空白字符(空格和制表符)</td>
</tr>
<tr>
<td>[:space:]</td>
<td>所有水平和垂直的空白字符(比[:blank:]包含的范围广)</td>
</tr>
<tr>
<td>[:cntrl:]</td>
<td>不可打印的控制字符(退格,删除,警铃)</td>
</tr>
<tr>
<td>[:digit:]</td>
<td>十进制数字</td>
</tr>
<tr>
<td>[:graph:]</td>
<td>可打印的非空白字符</td>
</tr>
<tr>
<td>[:punct:]</td>
<td>标点符号</td>
</tr>
<tr>
<td>[:xdigit:]</td>
<td>十六进制数字</td>
</tr>
</tbody></table>
<h4 id="egrep及扩展的正则表达式"><a href="#egrep及扩展的正则表达式" class="headerlink" title="egrep及扩展的正则表达式"></a>egrep及扩展的正则表达式</h4><p>egrep = grep -E </p>
<p>egrep [OPTIONS] PATTERN [FILE…] </p>
<p>扩展正则表达式的元字符: </p>
<p>字符匹配: </p>
<pre><code>. 任意单个字符 

[] 指定范围的字符 

[^] 不在指定范围的字符     </code></pre><h4 id="扩展正则表达式"><a href="#扩展正则表达式" class="headerlink" title="扩展正则表达式"></a>扩展正则表达式</h4><p>次数匹配:</p>
<pre><code> *:匹配前面字符任意次 

?: 0或1次 

+:1次或多次 

{m}:匹配m次 

{m,n}:至少m,至多n次     </code></pre><p>位置锚定:</p>
<pre><code> ^ :行首 

$ :行尾 

\&lt;, \b :语首 

\&gt;, \b :语尾     </code></pre><p>分组: </p>
<pre><code>() 

后向引用:\1, \2, ...     </code></pre><p>或者: </p>
<pre><code>a|b: a或b 

C|cat: C或cat 

(C|c)at:Cat或cat    </code></pre><h4 id="sed工具"><a href="#sed工具" class="headerlink" title="sed工具"></a>sed工具</h4><p>用法: </p>
<pre><code>sed [option]... &apos;script&apos; inputfile... </code></pre><p>常用选项: </p>
<pre><code>-n:不输出模式空间内容到屏幕,即不自动打印 

-e: 多点编辑 

-f:/PATH/SCRIPT_FILE: 从指定文件中读取编辑脚本 

-r: 支持使用扩展正则表达式 

-i.bak: 备份文件并原处编辑     </code></pre><p>script: </p>
<pre><code>&apos;地址命令&apos; </code></pre><p>地址定界:<br>(1) 不给地址:对全文进行处理<br>(2) 单地址:<br>​    #: 指定的行,$:最后一行<br>​    /pattern/:被此处模式所能够匹配到的每一行<br>(3) 地址范围:<br>​    #,#<br>​    #,+#<br>​    /pat1/,/pat2/<br>​    #,/pat1/<br>(4) <del>:步进<br>​    1</del>2 奇数行<br>​    2~2 偶数行</p>
<p>编辑命令: </p>
<pre><code>d             删除模式空间匹配的行,并立即启用下一轮循环 

p             打印当前模式空间内容,追加到默认输出之后 

a [\\]text         在指定行后面追加文本,支持使用\n实现多行追加 

i [\\\]text         在行前面插入文本 

c [\]text         替换行为单行或多行文本 

w /path/file     保存模式匹配的行至指定文件 

r /path/file     读取指定文件的文本至模式空间中匹配到的行后 

=             为模式空间中的行打印行号 

!             模式空间中匹配行取反处理     </code></pre><p>s/// 查找替换,支持使用其它分隔符,s@@@,s### </p>
<p>替换标记: </p>
<pre><code>g         行内全局替换 

p         显示替换成功的行 

w         /PATH/FILE 将替换成功的行保存至文件中     </code></pre><h4 id="高级编辑命令"><a href="#高级编辑命令" class="headerlink" title="高级编辑命令"></a>高级编辑命令</h4><pre><code>P: 打印模式空间开端至\n内容,并追加到默认输出之前 

h: 把模式空间中的内容覆盖至保持空间中 

H:把模式空间中的内容追加至保持空间中 

g: 从保持空间取出数据覆盖至模式空间 

G:从保持空间取出内容追加至模式空间 

x: 把模式空间中的内容与保持空间中的内容进行互换 

n: 读取匹配到的行的下一行覆盖至模式空间 

N:读取匹配到的行的下一行追加至模式空间 

d: 删除模式空间中的行 

D:如果模式空间包含换行符,则删除直到第一个换行符的模式空间中的文本, 并不会读取新的输入行,而使用合成的模式空间重新启动循环。如果模式空间 不包含换行符,则会像发出d命令那样启动正常的新循环 </code></pre>]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 用户和组</title>
    <url>/Linux-%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84/</url>
    <content><![CDATA[<h4 id="用户user"><a href="#用户user" class="headerlink" title="用户user"></a>用户user</h4><p>令牌token,identity </p>
<p>Linux用户:Username/UID </p>
<p>管理员:root, 0 </p>
<p>普通用户:1-60000 自动分配 </p>
<p>系统用户:1-499, 1-999 (CentOS7) </p>
<p>对守护进程获取资源进行权限分配 </p>
<p>登录用户:500+, 1000+(CentOS7) </p>
<p>交互式登录 </p>
<h4 id="组group"><a href="#组group" class="headerlink" title="组group"></a>组group</h4><p>Linux组:Groupname/GID </p>
<p>管理员组:root, 0 </p>
<p>普通组: </p>
<p>系统组:1-499, 1-999(CENTOS7) </p>
<p>普通组:500+, 1000+(CENTOS7)</p>
<h4 id="安全上下文"><a href="#安全上下文" class="headerlink" title="安全上下文"></a>安全上下文</h4><p> Linux安全上下文 </p>
<p>运行中的程序:进程 (process) </p>
<p>以进程发起者的身份运行: </p>
<pre><code>root: /bin/cat 

mark: /bin/cat </code></pre><p>进程所能够访问资源的权限取决于进程的运行者的身份 </p>
<h4 id="组的类别"><a href="#组的类别" class="headerlink" title="组的类别"></a>组的类别</h4><p>Linux组的类别 </p>
<p>用户的主要组(primary group) </p>
<pre><code>用户必须属于一个且只有一个主组 

组名同用户名,且仅包含一个用户,私有组    </code></pre><p>用户的附加组(supplementary group) </p>
<pre><code>一个用户可以属于零个或多个辅助组 </code></pre><h4 id="用户和组的配置文件"><a href="#用户和组的配置文件" class="headerlink" title="用户和组的配置文件"></a>用户和组的配置文件</h4><p>Linux用户和组的主要配置文件: </p>
<pre><code>/etc/passwd:        

    名称,密码,UID,GID,描述信息,用户家目录,shell类型 

/etc/group:        

    组及其属性信息

/etc/shadow:        

    用户名:加密字段:上一次口令更改的时间:最小的口令有效期:最大的口令有效期:口令过期时间:口令过期宽限时间:账户有效期:最后一位是保留位

/etc/gshadow:    

    组密码及其相关属性 </code></pre><h4 id="passwd文件格式"><a href="#passwd文件格式" class="headerlink" title="passwd文件格式"></a>passwd文件格式</h4><p>login name:登录用名(mark) </p>
<p>passwd:密码 (x) </p>
<p>UID:用户身份编号 (1000) </p>
<p>GID:登录默认所在组编号 (1000) </p>
<p>GECOS:用户全名或注释 </p>
<p>home directory:用户主目录 (/home/mark) </p>
<p>shell:用户默认使用shell (/bin/bash) </p>
<p>账户中为!代表账户被锁定,虽然被锁定账户了,但是还是能够通过 su - username 来切换用户,但是如果将用户的 shell 类型设置为 nologin的话 再次切用户的时候是不能够输入命令的.</p>
<p>新建用户的时候如果不设置密码是无法登录的,会在shadow文件中出现!!,centOS7中会提示用户登录不需要密码.</p>
<p>使用 usermod -U username 来解锁</p>
<p>可以使用 chage username 来修改用户的账户时间</p>
<h4 id="shadow文件格式"><a href="#shadow文件格式" class="headerlink" title="shadow文件格式"></a>shadow文件格式</h4><p>登录用名 </p>
<p>用户密码:一般用sha512加密 </p>
<p>从1970年1月1日起到密码最近一次被更改的时间 </p>
<p>密码再过几天可以被变更(0表示随时可被变更) </p>
<p>密码再过几天必须被变更(99999表示永不过期) </p>
<p>密码过期前几天系统提醒用户(默认为一周) </p>
<p>密码过期几天后帐号会被锁定 </p>
<p>从1970年1月1日算起,多少天后帐号失效 </p>
<h4 id="密码加密"><a href="#密码加密" class="headerlink" title="密码加密"></a>密码加密</h4><p>加密机制: </p>
<pre><code>加密:明文--&gt; 密文 

解密:密文--&gt; 明文 </code></pre><p>单向加密:哈希算法,原文不同,密文必不同 </p>
<p>相同算法定长输出,获得密文不可逆推出原始数据 </p>
<p>雪崩效应:初始条件的微小改变,引起结果的巨大改变 </p>
<p>md5: message digest, 128bits </p>
<p>sha1: secure hash algorithm, 160bits </p>
<p>sha224: 224bits </p>
<p>sha256: 256bits </p>
<p>sha384: 384bits </p>
<p>sha512: 512bits </p>
<p> 更改加密算法: </p>
<pre><code>authconfig --passalgo=sha256 --update</code></pre><h4 id="密码的复杂性策略"><a href="#密码的复杂性策略" class="headerlink" title="密码的复杂性策略"></a>密码的复杂性策略</h4><p>使用数字、大写字母、小写字母及特殊字符中至少3种 </p>
<p>足够长 </p>
<p>使用随机密码 </p>
<p>定期更换,不要使用最近曾经使用过的密码 </p>
<h4 id="group文件格式"><a href="#group文件格式" class="headerlink" title="group文件格式"></a>group文件格式</h4><p>群组名称:就是群组名称 </p>
<p>群组密码:通常不需要设定,密码是被记录在 /etc/gshadow </p>
<p>GID:就是群组的 ID </p>
<p>以当前组为附加组的用户列表</p>
<p>(分隔符为逗号) </p>
<h4 id="gshdow文件格式"><a href="#gshdow文件格式" class="headerlink" title="gshdow文件格式"></a>gshdow文件格式</h4><p>群组名称:就是群组名称 </p>
<p>群组密码: </p>
<p>组管理员列表:组管理员的列表,更改组密码和成员 </p>
<p>以当前组为附加组的用户列表</p>
<p>(分隔符为逗号) </p>
<h4 id="用户和组管理命令"><a href="#用户和组管理命令" class="headerlink" title="用户和组管理命令"></a>用户和组管理命令</h4><p>用户管理命令 </p>
<pre><code>useradd 

usermod 

userdel </code></pre><p>组帐号维护命令 </p>
<pre><code>groupadd 

groupmod 

groupdel</code></pre><h4 id="用户创建-useradd"><a href="#用户创建-useradd" class="headerlink" title="用户创建:useradd"></a>用户创建:useradd</h4><p>useradd [options] LOGIN </p>
<pre><code>-u UID 

-o 配合-u 选项,不检查UID的唯一性 

-g GID:指明用户所属基本组,可为组名,也可以GID 

-c &quot;COMMENT&quot;:用户的注释信息 

-d HOME_DIR: 以指定的路径(不存在)为家目录 

-s SHELL: 指明用户的默认shell程序,可用列表在/etc/shells文件中 

-G GROUP1[,GROUP2,...]:为用户指明附加组,组须事先存在 

-N 不创建私用组做主组,使用users组做主组 </code></pre><p>​    -r: 创建系统用户 CentOS 6: ID&lt;500, CentOS 7: ID&lt;1000 </p>
<pre><code>-m 创建家目录,用于系统用户 </code></pre><p>​    -M 不创建家目录,用于非系统用户</p>
<p>使用 -r 选项创建系统用户的时候会默认不创建用户家目录,</p>
<p>默认值设定:/etc/default/useradd文件中 </p>
<p>显示或更改默认设置 </p>
<pre><code>useradd -D 

useradd –D -s SHELL 

useradd –D –b BASE_DIR </code></pre><p>​    useradd –D –g GROUP </p>
<h4 id="新建用户的相关文件和命令"><a href="#新建用户的相关文件和命令" class="headerlink" title="新建用户的相关文件和命令"></a>新建用户的相关文件和命令</h4><p>/etc/default/useradd </p>
<p>/etc/skel/*                 创建用户的时候默认的文件夹</p>
<p>/etc/login.defs            创建用户的时候默认的加密策略</p>
<p>newusers passwd        格式文件 批量创建用户 </p>
<p>chpasswd                 批量修改用户口令 </p>
<h4 id="用户属性修改"><a href="#用户属性修改" class="headerlink" title="用户属性修改"></a>用户属性修改</h4><p>usermod [OPTION] login </p>
<pre><code>-u UID: 新UID 

-g GID: 新主组 

-G GROUP1[,GROUP2,...[,GROUPN]]:新附加组,原来的附加组将会被 覆盖；若保留原有,则要同时使用-a选项 

-s SHELL:新的默认SHELL 

-c &apos;COMMENT&apos;:新的注释信息 

-d HOME: 新家目录不会自动创建；若要创建新家目录并移动原家数据, 同时使用-m选项 

-l login_name: 新的名字； 

-L: lock指定用户,在/etc/shadow 密码栏的增加 ! 

-U: unlock指定用户,将 /etc/shadow 密码栏的 ! 拿掉 

-e YYYY-MM-DD: 指明用户账号过期日期 </code></pre><p>​    -f INACTIVE: 设定非活动期限 </p>
<p>删除所有的附加组 usermod -G “” apache</p>
<h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><p>userdel [OPTION]… login </p>
<pre><code>-r: 删除用户家目录 </code></pre><h4 id="查看用户相关的ID信息"><a href="#查看用户相关的ID信息" class="headerlink" title="查看用户相关的ID信息"></a>查看用户相关的ID信息</h4><pre><code>id [OPTION]... [USER] 

-u: 显示UID 

-g: 显示GID 

-G: 显示用户所属的组的ID </code></pre><p>​    -n: 显示名称,需配合ugG使用 </p>
<p>可以用id来判断用户是否存在</p>
<h4 id="切换用户或以其它用户身份执行命令"><a href="#切换用户或以其它用户身份执行命令" class="headerlink" title="切换用户或以其它用户身份执行命令"></a>切换用户或以其它用户身份执行命令</h4><p>su [options…][-][user [args…]] </p>
<p>切换用户的方式: </p>
<p>​    su UserName:非登录式切换,即不会读取目标用户的配置文件,不改变 当前工作目录 </p>
<p>​    su - UserName:登录式切换,会读取目标用户的配置文件,切换至家目 录,完全切换 </p>
<p>​    root su至其他用户无须密码；非root用户切换时需要密码 </p>
<p>换个身份执行命令: </p>
<p>​    su [-] UserName -c ‘COMMAND’ </p>
<p>选项:-l –login </p>
<p>​    su -l UserName 相当于 su - UserName </p>
<h4 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h4><p>passwd [OPTIONS] UserName: 修改指定用户的密码 </p>
<p>常用选项: </p>
<pre><code>-d:删除指定用户密码 

-l:锁定指定用户 

-u:解锁指定用户 

-e:强制用户下次登录修改密码 

-f:强制操作 

-n mindays:指定最短使用期限 

-x maxdays:最大使用期限 

-w warndays:提前多少天开始警告 </code></pre><p>​    -i inactivedays:非活动期限     </p>
<p>​    –stdin:从标准输入接收用户密码 </p>
<p>示例:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "PASSWORD" | passwd --stdin USERNAME &gt;/dev/null</span><br></pre></td></tr></table></figure>

<h4 id="修改用户密码策略"><a href="#修改用户密码策略" class="headerlink" title="修改用户密码策略"></a>修改用户密码策略</h4><p>chage [OPTION]… LOGIN </p>
<pre><code>-d LAST_DAY 

-E --expiredate EXPIRE_DATE 

-I --inactive INACTIVE 

-m --mindays MIN_DAYS 

-M --maxdays MAX_DAYS 

-W --warndays WARN_DAYS 

–l 显示密码策略     </code></pre><p>示例: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chage -d 0 USERNAME  	//下一次登录强制重设密码 </span><br><span class="line"></span><br><span class="line">chage -m 0 –M 42 –W 14 –I 7 USERNAME </span><br><span class="line"></span><br><span class="line">chage -E 2016-09-10 USERNAME</span><br></pre></td></tr></table></figure>

<h4 id="创建组"><a href="#创建组" class="headerlink" title="创建组"></a>创建组</h4><p>groupadd [OPTION]… group_name </p>
<p>​    -g GID: 指明GID号；[GID_MIN, GID_MAX] </p>
<p>​    -r: 创建系统组 </p>
<p>​        CentOS 6: ID&lt;500     </p>
<p>​        CentOS 7: ID&lt;1000</p>
<h4 id="修改和删除组"><a href="#修改和删除组" class="headerlink" title="修改和删除组"></a>修改和删除组</h4><p>组属性修改:groupmod </p>
<p>groupmod [OPTION]… group </p>
<p>​    -n group_name: 新名字 </p>
<p>​    -g GID: 新的GID </p>
<p>组删除:groupdel </p>
<p>​    groupdel GROUP </p>
<h4 id="更改组密码"><a href="#更改组密码" class="headerlink" title="更改组密码"></a>更改组密码</h4><p>组密码:gpasswd </p>
<p>gpasswd [OPTION] GROUP </p>
<p>​    -a user 将user添加至指定组中 </p>
<p>​    -d user 从指定组中移除用户user </p>
<p>​    -A user1,user2,… 设置有管理权限的用户列表 </p>
<p>newgrp命令:临时切换主组 </p>
<p>如果用户本不属于此组,则需要组密码 </p>
<h4 id="更改和查看组成员"><a href="#更改和查看组成员" class="headerlink" title="更改和查看组成员"></a>更改和查看组成员</h4><p>groupmems [options][action] </p>
<p>options: </p>
<p>​    -g, –group groupname 更改为指定组 (只有root) </p>
<p>Actions:</p>
<p>​    -a, –add username 指定用户加入组 </p>
<p>​    -d, –delete username 从组中删除用户 </p>
<p>​    -p, –purge 从组中清除所有成员 </p>
<p>​    -l, –list 显示组成员列表     </p>
<p>groups [USERNAME]… 查看用户所属组列表 </p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 系统及应用问题分析排查工具</title>
    <url>/Linux-%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E6%8E%92%E6%9F%A5%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>Linux服务器上经常遇到一些系统和应用上的问题，如何分析排查，需要利器，下面总结列表了一些常用工具、trace tool.</p>
<p>引用<a href="http://dtrace.org/blogs/brendan/2013/06/08/linux-performance-analysis-and-tools/" target="_blank" rel="noopener">linux-performance-analysis-and-tools</a>中图片，说明这些tool试用层次位置</p>
<p><img data-src="http://www.brendangregg.com/Perf/linux_observability_tools.png" alt=""></p>
<h2 id="OS系统命令"><a href="#OS系统命令" class="headerlink" title="OS系统命令"></a>OS系统命令</h2><h3 id="系统信息（RHEL-Fedora）"><a href="#系统信息（RHEL-Fedora）" class="headerlink" title="系统信息（RHEL/Fedora）"></a>系统信息（RHEL/Fedora）</h3><ul>
<li>uname -a 或 cat /proc/version #print system information<ul>
<li>Linux hadoopst2.cm6 2.6.18-164.el5 #1 SMP Tue Aug 18 15:51:48 EDT 2009 x86_64 x86_64 x86_64 GNU/Linux</li>
</ul>
</li>
<li>uptime<ul>
<li>15:42:46 up 674 days, 6 min, 35 users, load average: 1.30, 5.97, 11.53</li>
</ul>
</li>
<li>cat /etc/redhat-release<ul>
<li>Red Hat Enterprise Linux Server release 5.4 (Tikanga)</li>
</ul>
</li>
<li>lsb_release<ul>
<li>LSB Version:  :core-3.1-amd64:core-3.1-ia32:core-3.1-noarch:graphics-3.1-amd64:graphics-3.1-ia32:graphics-3.1-noarch</li>
</ul>
</li>
<li>cat /proc/cpuinfo</li>
<li>cat /proc/meminfo</li>
<li>lspci - list all PCI devices</li>
<li>lsusb - list USB devices</li>
<li>last, lastb - show listing of last logged in users</li>
<li>lsmod — show the status of modules in the Linux Kernel</li>
<li>modprobe - add and remove modules from the Linux Kernel</li>
</ul>
<h2 id="常用命令-工具"><a href="#常用命令-工具" class="headerlink" title="常用命令/工具"></a>常用命令/工具</h2><ul>
<li>ps<ul>
<li>To print a process tree: ps -ejH / ps axjf</li>
<li>To get info about threads: ps -eLf / ps axms</li>
</ul>
</li>
<li>ulimit -a</li>
<li>lsof - list open files, UNIX一切皆文件<ul>
<li>lsof -p PID</li>
</ul>
</li>
<li>rpm/yum<ul>
<li>rpm -qf FILE #文件所属rpm包</li>
<li>rpm -ql RPM #rpm包含文件</li>
<li>/var/log/yum.log #yum 更新包日志</li>
</ul>
</li>
<li>/etc/XXX #系统级程序配置目录， 如<ul>
<li>/etc/yum.repos.d/ yum源配置</li>
</ul>
</li>
<li>/var/log/XXX #日志目录， 如<ul>
<li>/var/log/cron #crontab日志，可以查看调度执行情况</li>
</ul>
</li>
<li>ntpd - Network Time Protocol (NTP) daemon，同步集群中机器时间</li>
<li>squid - proxy caching server，集群WebUI的代理</li>
</ul>
<h3 id="系统监控"><a href="#系统监控" class="headerlink" title="系统监控"></a>系统监控</h3><ul>
<li>mpstat - Report processors related statistics. 注意%sys %iowait值</li>
<li>vmstat - Report virtual memory statistics</li>
<li>iostat - Report Central Processing Unit (CPU) statistics and input/output statistics for devices and partitions.</li>
<li>netstat - Print network connections, routing tables, interface statistics, masquerade connections, and multicast memberships<ul>
<li>netstat -atpn | grep PID</li>
</ul>
</li>
<li><a href="http://ganglia.sourceforge.net/" target="_blank" rel="noopener">ganglia</a> - a scalable distributed monitoring system for high-performance computing systems such as clusters and Grids.</li>
<li>sar/tsar - Collect, report, or save system activity information; tsar是淘宝自己改进的版本<ul>
<li>定时采样（每分钟），可查历史记录（默认5分钟），可弥补ganglia显示更详细信息</li>
</ul>
</li>
<li>iftop - the “top” bandwidth consumers shown. <a href="http://en.wikipedia.org/wiki/Iftop" target="_blank" rel="noopener">iftop wiki</a></li>
<li><a href="http://guichaz.free.fr/iotop/" target="_blank" rel="noopener">iotop</a></li>
<li><a href="https://github.com/hoytech/vmtouch" target="_blank" rel="noopener">vmtouch</a>, Portable file system cache diagnostics and control</li>
</ul>
<h3 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h3><ul>
<li>telnet/nc IP PORT - 确认目标端口是否可访问，只ping通不一定端口可访问，可能防火墙等禁止</li>
<li>ifconfig/ifup/ifdown - configure a network interface</li>
<li>traceroute - print the route packets trace to network host</li>
<li>nslookup - query Internet name servers interactively</li>
<li>tcpdump - dump traffic on a network， 类似开源工具 <a href="http://www.wireshark.org/" target="_blank" rel="noopener">wireshark</a>, <a href="http://netsniff-ng.org/" target="_blank" rel="noopener">netsniff-ng</a>, <a href="http://en.wikipedia.org/wiki/Comparison_of_packet_analyzers" target="_blank" rel="noopener">更多工具比较</a></li>
<li>lynx - a general purpose distributed information browser for the World Wide Web</li>
<li><a href="http://tcpcp.sourceforge.net/" target="_blank" rel="noopener">tcpcp</a> - allows cooperating applications to pass ownership of TCP connection endpoints from one Linux host to another one.</li>
</ul>
<h2 id="程序-进程相关"><a href="#程序-进程相关" class="headerlink" title="程序/进程相关"></a>程序/进程相关</h2><h3 id="静态信息"><a href="#静态信息" class="headerlink" title="静态信息"></a>静态信息</h3><ul>
<li>ldconfig - configure dynamic linker run time bindings<ul>
<li>ldconfig -p | grep SO 查看so是否在link cache中</li>
</ul>
</li>
<li>ldd - print shared library dependencies， 查看exe或so依赖的so</li>
<li>nm - list symbols from object files，可grep查找是否存在相关的symbol，是否Undefined.</li>
<li>readelf - Displays information about ELF files. 可现实elf相关信息，如32/64位，适用的OS，处理器</li>
</ul>
<h3 id="动态信息"><a href="#动态信息" class="headerlink" title="动态信息"></a>动态信息</h3><ul>
<li>gdb</li>
<li>cat /proc/$PID/[cmdline|environ|limits|status|…] - 进程相关信息</li>
<li>pstack - print a stack trace of a running process</li>
<li>pmap - report memory map of a process</li>
</ul>
<p>资料来源:</p>
<p><a href="https://www.cnblogs.com/zengkefu/p/5642955.html" target="_blank" rel="noopener">https://www.cnblogs.com/zengkefu/p/5642955.html</a></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 磁盘存储和文件系统(二)</title>
    <url>/Linux-%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E4%BA%8C/</url>
    <content><![CDATA[<h3 id="挂载-mount"><a href="#挂载-mount" class="headerlink" title="挂载 mount"></a>挂载 mount</h3><p>挂载:将额外文件系统与根文件系统某现存的目录建立起关联关系,进而使得此 目录做为其它文件访问入口的行为 </p>
<p>卸载:为解除此关联关系的过程 </p>
<p>把设备关联挂载点:mount Point </p>
<p>​    mount </p>
<p>卸载时:可使用设备,也可以使用挂载点 </p>
<p>​    umount </p>
<p>挂载点下原有文件在挂载完成后会被临时隐藏 </p>
<p>挂载点目录一般为空 </p>
<h4 id="用mount命令挂载文件系统"><a href="#用mount命令挂载文件系统" class="headerlink" title="用mount命令挂载文件系统"></a>用mount命令挂载文件系统</h4><p>挂载方法:mount DEVICE MOUNT_POINT </p>
<p>mount:通过查看/etc/mtab文件显示当前已挂载的所有设备 </p>
<p>mount [-fnrsvw]/[-t vfstype]/[-o options] device dir </p>
<p>​    device:指明要挂载的设备； </p>
<p>​    (1) 设备文件:例如/dev/sda5 </p>
<p>​    (2) 卷标:-L ‘LABEL’, 例如 -L ‘MYDATA’ </p>
<p>​    (3) UUID, -U ‘UUID’:例如 -U ‘0c50523c-43f1-45e7- 85c0-a126711d406e’ </p>
<p>​    (4) 伪文件系统名称:proc, sysfs, devtmpfs, configfs </p>
<p>​    dir:挂载点 </p>
<p>​        事先存在；建议使用空目录 </p>
<p>​        进程正在使用中的设备无法被卸载 </p>
<h4 id="mount-常用命令选项"><a href="#mount-常用命令选项" class="headerlink" title="mount 常用命令选项"></a>mount 常用命令选项</h4><p>-t vsftype:指定要挂载的设备上的文件系统类型 </p>
<p>-r: readonly,只读挂载 </p>
<p>-w: read and write, 读写挂载 </p>
<p>-n: 不更新/etc/mtab,mount不可见 </p>
<p>-a:自动挂载所有支持自动挂载的设备(定义在了/etc/fstab文件中,且挂载选 项中有auto功能) </p>
<p>-L ‘LABEL’: 以卷标指定挂载设备 </p>
<p>-U ‘UUID’: 以UUID指定要挂载的设备 </p>
<p>-B, –bind: 绑定目录到另一个目录上 </p>
<p>查看内核追踪到的已挂载的所有设备 </p>
<p>​    cat /proc/mounts </p>
<p> -o options:(挂载文件系统的选项),多个选项使用逗号分隔 </p>
<p>​    async:异步模式 sync:同步模式,内存更改时,同时写磁盘 </p>
<p>​    atime/noatime:包含目录和文件 </p>
<p>​    diratime/nodiratime:目录的访问时间戳 </p>
<p>​    auto/noauto:是否支持自动挂载,是否支持-a选项 </p>
<p>​    exec/noexec:是否支持将文件系统上运行应用程序 </p>
<p>​    dev/nodev:是否支持在此文件系统上使用设备文件 </p>
<p>​    suid/nosuid:是否支持suid和sgid权限 </p>
<p>​    remount:重新挂载 </p>
<p>​    ro:只读 rw:读写 </p>
<p>​    user/nouser:是否允许普通用户挂载此设备,/etc/fstab使用 </p>
<p>​    acl:启用此文件系统上的acl功能 </p>
<p>​    loop: 使用loop设备 </p>
<p> defaults:相当于rw, suid, dev, exec, auto, nouser, async </p>
<h4 id="卸载命令"><a href="#卸载命令" class="headerlink" title="卸载命令"></a>卸载命令</h4><p>查看挂载情况 </p>
<p>​    findmnt MOUNT_POINT|device </p>
<p>查看正在访问指定文件系统的进程 </p>
<p>​    lsof MOUNT_POINT </p>
<p>​    fuser -v MOUNT_POINT </p>
<p>终止所有在正访问指定的文件系统的进程 </p>
<p>​    fuser -km MOUNT_POINT </p>
<p>卸载 </p>
<p>​    umount DEVICE </p>
<p>​    umount MOUNT_POINT </p>
<h4 id="挂载点和-etc-fstab"><a href="#挂载点和-etc-fstab" class="headerlink" title="挂载点和/etc/fstab"></a>挂载点和/etc/fstab</h4><p>配置文件系统体系 </p>
<p>被mount、fsck和其它程序使用 </p>
<p>系统重启时保留文件系统体系 </p>
<p>可以在设备栏使用文件系统卷标 </p>
<p>使用mount -a 命令挂载/etc/fstab中的所有文件系统 </p>
<h4 id="文件挂载配置文件"><a href="#文件挂载配置文件" class="headerlink" title="文件挂载配置文件"></a>文件挂载配置文件</h4><p> /etc/fstab每行定义一个要挂载的文件系统 </p>
<p> 1、要挂载的设备或伪文件系统 </p>
<p>​    设备文件 </p>
<p>​    LABEL:LABEL=”” </p>
<p>​    UUID:UUID=”” </p>
<p>​    伪文件系统名称:proc, sysfs </p>
<p> 2、挂载点 </p>
<p> 3、文件系统类型:ext4,xfs,nfs,none </p>
<p> 4、挂载选项:defaults ,acl,bind </p>
<p> 5、转储频率:</p>
<p>​    0:不做备份 </p>
<p>​    1:每天转储 </p>
<p>​    2:每隔一天转储 </p>
<p> 6、fsck检查的文件系统的顺序:允许的数字是0, 1, 和2 </p>
<p>​    0:不自检 </p>
<p>​    1:首先自检；一般只有rootfs才用 </p>
<p>​    2:非rootfs使用 </p>
<h4 id="处理交换文件和分区"><a href="#处理交换文件和分区" class="headerlink" title="处理交换文件和分区"></a>处理交换文件和分区</h4><p>交换分区是系统RAM的补充 </p>
<p>基本设置包括: </p>
<p>​    • 创建交换分区或者文件 </p>
<p>​    • 使用mkswap写入特殊签名 </p>
<p>​    • 在/etc/fstab文件中添加适当的条目 </p>
<p>​    • 使用swapon -a 激活交换空间 </p>
<h4 id="挂载交换分区"><a href="#挂载交换分区" class="headerlink" title="挂载交换分区"></a>挂载交换分区</h4><p>启用:swapon </p>
<p>​    swapon [OPTION]… [DEVICE] </p>
<p>​        -a:激活所有的交换分区 </p>
<p>​        -p PRIORITY:指定优先级 </p>
<p>​        /etc/fstab:pri=value </p>
<p>禁用:swapoff [OPTION]… [DEVICE] </p>
<h4 id="SWAP的优先级"><a href="#SWAP的优先级" class="headerlink" title="SWAP的优先级"></a>SWAP的优先级</h4><p>可以指定swap分区0到32767的优先级,值越大优先级越高 </p>
<p>如果用户没有指定,那么核心会自动给swap指定一个优先级,这个优先级从 -1开始,每加入一个新的没有用户指定优先级的swap,会给这个优先级减一 </p>
<p>先添加的swap的缺省优先级比较高,除非用户自己指定一个优先级,而用户 指定的优先级(是正数)永远高于核心缺省指定的优先级(是负数) </p>
<p>优化性能:分布存放,高性能磁盘存放 </p>
<h3 id="移动介质"><a href="#移动介质" class="headerlink" title="移动介质"></a>移动介质</h3><p>挂载意味着使外来的文件系统看起来如同是主目录树的一部分 </p>
<p>访问前、介质必须被挂载 </p>
<p>摘除时,介质必须被卸载 </p>
<p>按照默认设置,非根用户只能挂载某些设备（光盘、DVD、软 盘、USB等等） </p>
<p>挂载点通常在/media 或/mnt下 </p>
<h3 id="使用光盘"><a href="#使用光盘" class="headerlink" title="使用光盘"></a>使用光盘</h3><p>在图形环境下自动启动挂载/run/media/[lable]/[lable] </p>
<p>否则就必须被手工挂载 </p>
<p>​    mount /dev/cdrom /mnt/ </p>
<p>eject命令卸载或弹出磁盘 </p>
<p>创建ISO文件 </p>
<p>​    cp /dev/cdrom /root/centos7.iso </p>
<p>​    mkisofs -r -o /root/etc.iso /etc </p>
<p>刻录光盘 </p>
<p>​    wodim –v –eject centos.iso </p>
<h3 id="挂载USB介质"><a href="#挂载USB介质" class="headerlink" title="挂载USB介质"></a>挂载USB介质</h3><p>查看USB设备是否识别 </p>
<p>​    • lsusb </p>
<p>被内核探测为SCSI设备 </p>
<p>​    • /dev/sdaX、/dev/sdbX、或类似的设备文件 </p>
<p>在图形环境中自动挂载 </p>
<p>​    • 图标在[计算机]窗口中创建 </p>
<p>​    • 挂载在/run/media// </p>
<p>手动挂载 • mount /dev/sdb1 /mn </p>
<h4 id="常见工具"><a href="#常见工具" class="headerlink" title="常见工具"></a>常见工具</h4><p>文件系统空间占用等信息的查看工具: </p>
<p>​    df [OPTION]… [FILE]… </p>
<p>​    -H 以1000为单位 </p>
<p>​    -T 文件系统类型 </p>
<p>​    -h: human-readable </p>
<p>​    -i:inodes instead of blocks </p>
<p>​    -P: 以Posix兼容的格式输出 </p>
<p>查看某目录总体空间占用状态: </p>
<p>​    du [OPTION]… DIR </p>
<p>​    -h: human-readable </p>
<p>​    -s: summary –max-depth </p>
<h4 id="工具dd"><a href="#工具dd" class="headerlink" title="工具dd"></a>工具dd</h4><p> dd命令:convert and copy a file </p>
<p> 用法: </p>
<p>​    dd if=/PATH/FROM/SRC of=/PATH/TO/DEST </p>
<p>​    bs=#:block size, 复制单元大小 </p>
<p>​    count=#:复制多少个bs </p>
<p>​    of=file 写到所命名的文件而不是到标准输出 </p>
<p>​    if=file 从所命名文件读取而不是从标准输入 </p>
<p>​    bs=size 指定块大小（既是是ibs也是obs) </p>
<p>​    ibs=size 一次读size个byte </p>
<p>​    obs=size 一次写size个byte </p>
<p>​    cbs=size 一次转化size个byte </p>
<p>​    skip=blocks 从开头忽略blocks个ibs大小的块 </p>
<p>​    seek=blocks 从开头忽略blocks个obs大小的块 </p>
<p>​    count=n 只拷贝n个记录 </p>
<p>conv=conversion[,conversion…] 用指定的参数转换文件 </p>
<p>转换参数: </p>
<p>ascii 转换 EBCDIC 为 ASCII </p>
<p>ebcdic 转换 ASCII 为 EBCDIC </p>
<p>lcase 把大写字符转换为小写字符 </p>
<p>ucase 把小写字符转换为大写字符 </p>
<p>nocreat 不创建输出文件 </p>
<p>noerror 出错时不停止 </p>
<p>notrunc 不截短输出文件 </p>
<p>sync 把每个输入块填充到ibs个字节,不足部分用空(NUL)字符补齐 </p>
<p>备份MBR: </p>
<p>​    dd if=/dev/sda of=/tmp/mbr.bak bs=512 count=1 </p>
<p>破坏MBR中的bootloader: </p>
<p>​    dd if=/dev/zero of=/dev/sda bs=64 count=1 seek=446 </p>
<p>有一个大与2K的二进制文件fileA。现在想从第64个字节位置开始读取,需要读 取的大小是128Byts。又有fileB, 想把上面读取到的128Bytes写到第32个字节开 始的位置,替换128Bytes,实现如下: </p>
<p>​    dd if=fileA of=fileB bs=1 count=128 skip=63 seek=31 conv=notrunc </p>
<p>备份: </p>
<p>​    dd if=/dev/sdx of=/dev/sdy </p>
<p>​    将本地的/dev/sdx整盘备份到/dev/sdy </p>
<p>​    dd if=/dev/sdx of=/path/to/image </p>
<p>​    将/dev/sdx全盘数据备份到指定路径的image文件 </p>
<p>​    dd if=/dev/sdx | gzip &gt;/path/to/image.gz </p>
<p>​    备份/dev/sdx全盘数据,并利用gzip压缩,保存到指定路径 </p>
<p>恢复: </p>
<p>​    dd if=/path/to/image of=/dev/sdx </p>
<p>​    将备份文件恢复到指定盘 </p>
<p>​    gzip -dc /path/to/image.gz | dd of=/dev/sdx </p>
<p>​    将压缩的备份文件恢复到指定盘 </p>
<p>拷贝内存资料到硬盘 </p>
<p>​    dd if=/dev/mem of=/root/mem.bin bs=1024 </p>
<p>将内存里的数据拷贝到root目录下的mem.bin文件 </p>
<p>从光盘拷贝iso镜像 </p>
<p>​    dd if=/dev/cdrom of=/root/cd.iso </p>
<p>拷贝光盘数据到root文件夹下,并保存为cd.iso文件 </p>
<p>销毁磁盘数据 </p>
<p>​    dd if=/dev/urandom of=/dev/sda1 </p>
<p>利用随机的数据填充硬盘,在某些必要的场合可以用来销毁数据,执行此操作以后, /dev/sda1将无法挂载,创建和拷贝操作无法执行 </p>
<p>得到最恰当的block size </p>
<p>​    dd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file </p>
<p>​    dd if=/dev/zero bs=2048 count=500000 of=/root/1Gb.file </p>
<p>​    dd if=/dev/zero bs=4096 count=250000 of=/root/1Gb.file </p>
<p>通过比较dd指令输出中命令的执行时间,即可确定系统最佳的block size大小 </p>
<p>测试硬盘写速度 </p>
<p>​    dd if=/dev/zero of=/root/1Gb.file bs=1024 count=1000000 </p>
<p>测试硬盘读速度 </p>
<p>​    dd if=/root/1Gb.file bs=64k | dd of=/dev/null </p>
<p>修复硬盘 </p>
<p>​    dd if=/dev/sda of=/dev/sda </p>
<p>当硬盘较长时间（比如1,2年）放置不使用后,磁盘上会产生消磁点。当磁头读 到这些区域时会遇到困难,并可能导致I/O错误。当这种情况影响到硬盘的第一 个扇区时,可能导致硬盘报废。上边的命令有可能使这些数据起死回生,且这个 过程是安全高效的 </p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 磁盘存储和文件系统(一)</title>
    <url>/Linux-%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E4%B8%80/</url>
    <content><![CDATA[<h4 id="设备文件"><a href="#设备文件" class="headerlink" title="设备文件"></a>设备文件</h4><p>I/O Ports: I/O设备地址 </p>
<p>一切皆文件:open(), read(), write(), close() </p>
<p>设备类型: </p>
<pre><code>块设备:block,存取单位“块”,磁盘 

字符设备:char,存取单位“字符”,键盘 </code></pre><p>设备文件:</p>
<pre><code>关联至一个设备驱动程序,进而能够跟与之对应硬件设备进行通信 </code></pre><p>设备号码: </p>
<pre><code>主设备号:major number, 标识设备类型 

次设备号:minor number, 标识同一类型下的不同设备 </code></pre><p>磁盘设备的设备文件命名:/dev/DEV_FILE </p>
<p>SCSI, SATA, SAS, IDE,USB: /dev/sd </p>
<p>虚拟磁盘:/dev/vd </p>
<p>不同磁盘标识:a-z,aa,ab… </p>
<pre><code>/dev/sda, /dev/sdb, ... </code></pre><p>同一设备上的不同分区:1,2, … </p>
<pre><code>/dev/sda1, /dev/sda5 </code></pre><p>硬盘存储术语 </p>
<pre><code>head:磁头 

track:磁道 

cylinder: 柱面 

sector: 扇区,512bytes </code></pre><h4 id="CHS和LBA"><a href="#CHS和LBA" class="headerlink" title="CHS和LBA"></a>CHS和LBA</h4><p>CHS </p>
<pre><code>采用24bit位寻址 

其中前10位表示cylinder,中间8位表示head,后面6位表示sector 

最大寻址空间8GB </code></pre><p>LBA(logical block addressing) </p>
<p>​    LBA是一个整数,通过转换成CHS格式完成磁盘具体寻址 </p>
<pre><code>LBA采用48个bit位寻址 

最大寻址空间128PB </code></pre><p>由于CHS寻址方式的寻址空间在大概8GB以内,所以在磁盘容量小于大概8GB 时,可以使用CHS寻址方式或是LBA寻址方式;在磁盘容量大于大概8GB时,则 只能使用LBA寻址方式 </p>
<h4 id="使用分区空间"><a href="#使用分区空间" class="headerlink" title="使用分区空间"></a>使用分区空间</h4><p>设备识别 </p>
<p>设备分区 </p>
<p>创建文件系统 </p>
<p>标记文件系统 </p>
<p>在/etc/fstab文件中创建条目 </p>
<p>挂载新的文件系统 </p>
<h3 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h3><h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h4><p>两种分区方式:MBR,GPT </p>
<p>MBR: Master Boot Record,1982年,使用32位表示扇区数,分区不超过2T </p>
<p>如何分区:按柱面 </p>
<p>0磁道0扇区:512bytes </p>
<pre><code>446bytes: boot loader 

64bytes:分区表 

    16bytes: 标识一个分区 

2bytes: 55AA </code></pre><p>4个主分区;3主分区+1扩展(N个逻辑分区) </p>
<h4 id="MBR分区结构"><a href="#MBR分区结构" class="headerlink" title="MBR分区结构"></a>MBR分区结构</h4><p>硬盘主引导记录MBR由4个部分组成 </p>
<p>主引导程序(偏移地址0000H–0088H),它负责从活动分区中装载,并运行 系统引导程序 </p>
<p>出错信息数据区,偏移地址0089H–00E1H为出错信息,00E2H–01BDH全为 0字节 </p>
<p>分区表(DPT,Disk Partition Table)含4个分区项,偏移地址01BEH–01FDH, 每个分区表项长16个字节,共64字节为分区项1、分区项2、分区项3、分区项4 </p>
<p>结束标志字,偏移地址01FE–01FF的2个字节值为结束标志55AA </p>
<h4 id="GPT分区"><a href="#GPT分区" class="headerlink" title="GPT分区"></a>GPT分区</h4><p>GPT:GUID(Globals Unique Identifiers) partition table 支持128个分区, 使用64位,支持8Z( 512Byte/block )64Z ( 4096Byte/block) </p>
<p>使用128位UUID(Universally Unique Identifier) 表示磁盘和分区 GPT分区表 自动备份在头和尾两份,并有CRC校验位 </p>
<p>UEFI (统一扩展固件接口)硬件支持GPT,使操作系统启动 </p>
<h3 id="管理分区"><a href="#管理分区" class="headerlink" title="管理分区"></a>管理分区</h3><p>列出块设备 </p>
<pre><code>• lsblk </code></pre><p>创建分区使用: </p>
<pre><code>• fdisk 创建MBR分区 

• gdisk 创建GPT分区 </code></pre><p>​    • parted 高级分区操作 </p>
<p>partprobe－重新设置内存中的内核分区表版本 </p>
<h4 id="parted命令"><a href="#parted命令" class="headerlink" title="parted命令"></a>parted命令</h4><p>parted的操作都是实时生效的,小心使用 </p>
<p>用法:parted [选项]… [设备 [命令 [参数]…]…] </p>
<pre><code>parted /dev/sdb mklabel gpt|msdos 

parted /dev/sdb print 

parted /dev/sdb mkpart primary 1 200 (默认M) 

parted /dev/sdb rm 1 

parted –l 列出分区信息 </code></pre><h4 id="分区工具fdisk和gdisk"><a href="#分区工具fdisk和gdisk" class="headerlink" title="分区工具fdisk和gdisk"></a>分区工具fdisk和gdisk</h4><p>gdisk /dev/sdb 类fdisk 的GPT分区工具 </p>
<pre><code>fdisk -l [ -u]/[device...] 查看分区 

fdisk /dev/sdb 管理分区 

子命令: 

    p 分区列表 

    t 更改分区类型 

    n 创建新分区 

    d 删除分区 

    v 校验分区 

    u 转换单位 

    w 保存并退出 

    q 不保存并退出 </code></pre><h4 id="同步分区表"><a href="#同步分区表" class="headerlink" title="同步分区表"></a>同步分区表</h4><p>查看内核是否已经识别新的分区: </p>
<pre><code>cat /proc/partations </code></pre><p>centos6通知内核重新读取硬盘分区表 </p>
<pre><code>新增分区用 

partx -a /dev/DEVICE 

kpartx -a /dev/DEVICE -f: force 

删除分区用 

partx -d --nr M-N /dev/DEVICE </code></pre><p>CentOS 5,7: 使用partprobe </p>
<p>​    partprobe [/dev/DEVICE] </p>
<p>同步分区表的时候注意系统的版本,centOS 5,7 是相同的,但是6和以上两个版本都不一样</p>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>文件系统是操作系统用于明确存储设备或分区上的文件的方法和数据结构;即 在存储设备上组织文件的方法。操作系统中负责管理和存储文件信息的软件结 构称为文件管理系统,简称文件系统 </p>
<p>从系统角度来看,文件系统是对文件存储设备的空间进行组织和分配,负责文 件存储并对存入的文件进行保护和检索的系统。具体地说,它负责为用户建立 文件,存入、读出、修改、转储文件,控制文件的存取,安全控制,日志,压 缩,加密等 </p>
<p>支持的文件系统:</p>
<pre><code>/lib/modules/\`uname –r`/kernel/fs </code></pre><p>各种文件系统: </p>
<pre><code>https://en.wikipedia.org/wiki/Comparison_of_file_systems </code></pre><h4 id="文件系统类型"><a href="#文件系统类型" class="headerlink" title="文件系统类型"></a>文件系统类型</h4><p> Linux文件系统: </p>
<pre><code>ext2(Extended file system) :适用于那些分区容量不是太大,更新也不频繁的情况,例如 /boot 分区。 

ext3:是 ext2 的改进版本,其支持日志功能,能够帮助系统从非正常关机导致的异常中 恢复。它通常被用作通用的文件系统 

ext4:是 ext 文件系统的最新版。提供了很多新的特性,包括纳秒级时间戳、创建和使 用巨型文件(16TB)、最大1EB的文件系统,以及速度的提升 

xfs:SGI,支持最大8EB的文件系统 

btrfs(Oracle), reiserfs, jfs(AIX), swap </code></pre><p> 光盘:iso9660 </p>
<p> Windows:FAT32, exFAT,NTFS </p>
<p> Unix: FFS(fast), UFS(unix), JFS2 </p>
<p> 网络文件系统:NFS, CIFS </p>
<p> 集群文件系统:GFS2, OCFS2(oracle) </p>
<p> 分布式文件系统: fastdfs,ceph, moosefs, mogilefs, glusterfs, Lustre </p>
<p> RAW:未经处理或者未经格式化产生的文件系统 </p>
<h4 id="文件系统分类"><a href="#文件系统分类" class="headerlink" title="文件系统分类"></a>文件系统分类</h4><p>根据其是否支持”journal”功能: </p>
<pre><code>日志型文件系统: ext3, ext4, xfs, ... 

非日志型文件系统: ext2, vfat </code></pre><p>文件系统的组成部分: </p>
<pre><code>内核中的模块:ext4, xfs, vfat 

用户空间的管理工具:mkfs.ext4, mkfs.xfs,mkfs.vfat </code></pre><p>Linux的虚拟文件系统:VFS </p>
<p>查前支持的文件系统:cat /proc/filesystems </p>
<h4 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h4><p>mkfs命令: </p>
<p>(1) mkfs.FS_TYPE /dev/DEVICE </p>
<pre><code>ext4 

xfs 

btrfs 

vfat </code></pre><p>(2) mkfs -t FS_TYPE /dev/DEVICE </p>
<pre><code>-L &apos;LABEL&apos;: 设定卷标 </code></pre><h4 id="创建ext文件系统"><a href="#创建ext文件系统" class="headerlink" title="创建ext文件系统"></a>创建ext文件系统</h4><p>mke2fs:ext系列文件系统专用管理工具 </p>
<pre><code>-t {ext2|ext3|ext4} 

-b {1024|2048|4096} 

-L &apos;LABEL&apos; 

-j: 相当于 -t ext3 

    mkfs.ext3 = mkfs -t ext3 = mke2fs -j = mke2fs -t ext3 

-i #: 为数据空间中每多少个字节创建一个inode;此大小不应该小于 block的大小 

-N #:指定分区中创建多少个inode 

-I 一个inode记录占用的磁盘空间大小,128---4096 

-m #: 默认5%,为管理人员预留空间占总空间的百分比 

-O FEATURE[,...]:启用指定特性 

-O ^FEATURE:关闭指定特性 </code></pre><h4 id="文件系统标签"><a href="#文件系统标签" class="headerlink" title="文件系统标签"></a>文件系统标签</h4><p>指向设备的另一种方法 </p>
<p>与设备无关 </p>
<p>blkid:块设备属性信息查看 </p>
<p>blkid [OPTION]… [DEVICE] </p>
<pre><code>-U UUID: 根据指定的UUID来查找对应的设备 

-L LABEL:根据指定的LABEL来查找对应的设备 </code></pre><p>e2label:管理ext系列文件系统的LABEL </p>
<pre><code>e2label DEVICE [LABEL] </code></pre><p>findfs :查找分区 </p>
<pre><code>findfs [options] LABEL= /&lt;/label/&gt;/

findfs [options] UUID= /&lt;/uuid/&gt;/</code></pre><h4 id="tune2fs"><a href="#tune2fs" class="headerlink" title="tune2fs"></a>tune2fs</h4><p>tune2fs:重新设定ext系列文件系统可调整参数的值 </p>
<pre><code>-l:查看指定文件系统超级块信息;super block 

-L &apos;LABEL&apos;:修改卷标 

-m #:修预留给管理员的空间百分比 

-j: 将ext2升级为ext3 

-O: 文件系统属性启用或禁用, –O ^has_journal 

-o: 调整文件系统的默认挂载选项,–o ^acl 

-U UUID: 修改UUID号 </code></pre><p>dumpe2fs: </p>
<pre><code>块分组管理,32768块 

-h:查看超级块信息,不显示分组信息 </code></pre><h4 id="文件系统检测和修复"><a href="#文件系统检测和修复" class="headerlink" title="文件系统检测和修复"></a>文件系统检测和修复</h4><p>常发生于死机或者非正常关机之后 </p>
<p>挂载为文件系统标记为“no clean” </p>
<p>注意:一定不要在挂载状态下修复 </p>
<p>fsck: File System Check </p>
<pre><code>fsck.FS_TYPE 

fsck -t FS_TYPE 

-p: 自动修复错误 

-r: 交互式修复错误 

FS_TYPE一定要与分区上已经文件类型相同 </code></pre><p>e2fsck:ext系列文件专用的检测修复工具 </p>
<pre><code>-y:自动回答为yes 

-f:强制修复 </code></pre>]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 磁盘存储和文件系统(三)</title>
    <url>/Linux-%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E4%B8%89/</url>
    <content><![CDATA[<h3 id="LVM"><a href="#LVM" class="headerlink" title="LVM"></a>LVM</h3><p>允许对卷进行方便操作的抽象层,包括重新设定文件系统的大小 </p>
<p>允许在多个物理设备间重新组织文件系统 </p>
<p>​    • 将设备指定为物理卷 </p>
<p>​    • 用一个或者多个物理卷来创建一个卷组 </p>
<p>​    • 物理卷是用固定大小的物理区域(Physical Extent,PE)来定义的 </p>
<p>​    • 在物理卷上创建的逻辑卷 是由物理区域(PE)组成 </p>
<p>​    • 可以在逻辑卷上创建文件系统 </p>
<h4 id="LVM介绍"><a href="#LVM介绍" class="headerlink" title="LVM介绍"></a>LVM介绍</h4><p>LVM: Logical Volume Manager, Version: 2 </p>
<p>dm: device mapper:将一个或多个底层块设备组织成一个逻辑设备的模块 </p>
<p>设备名:/dev/dm-# </p>
<p>软链接: </p>
<p>​    /dev/mapper/VG_NAME-LV_NAME </p>
<p>​        /dev/mapper/vol0-root </p>
<p>​    /dev/VG_NAME/LV_NAME </p>
<p>​        /dev/vol0/root </p>
<h4 id="pv管理工具"><a href="#pv管理工具" class="headerlink" title="pv管理工具"></a>pv管理工具</h4><p>显示pv信息 </p>
<p>​    pvs:简要pv信息显示 </p>
<p>​    pvdisplay </p>
<p>创建pv </p>
<p>​    pvcreate </p>
<p>​    /dev/DEVICE </p>
<h4 id="vg管理工具"><a href="#vg管理工具" class="headerlink" title="vg管理工具"></a>vg管理工具</h4><p>显示卷组 </p>
<p>​    vgs </p>
<p>​    vgdisplay </p>
<p>创建卷组 </p>
<p>​    vgcreate [-s #[kKmMgGtTpPeE]] VolumeGroupName </p>
<p>​    PhysicalDevicePath [PhysicalDevicePath…] </p>
<p>管理卷组 </p>
<p>​    vgextend VolumeGroupName PhysicalDevicePath [PhysicalDevicePath…] </p>
<p>​    vgreduce VolumeGroupName PhysicalDevicePath [PhysicalDevicePath…] </p>
<p>删除卷组 </p>
<p>​    先做pvmove,</p>
<p>​    再做vgremove </p>
<h4 id="lv管理工具"><a href="#lv管理工具" class="headerlink" title="lv管理工具"></a>lv管理工具</h4><p>显示逻辑卷 </p>
<p>​    lvs </p>
<p>​    Lvdisplay </p>
<p>创建逻辑卷 </p>
<p>​    lvcreate -L #[mMgGtT] -n NAME VolumeGroup </p>
<p>​    lvcreate -l 60%VG -n mylv testvg </p>
<p>​    lvcreate -l 100%FREE -n yourlv testvg </p>
<p>删除逻辑卷 </p>
<p>​    lvremove /dev/VG_NAME/LV_NAME </p>
<p>重设文件系统大小 </p>
<p>​    fsadm [options] resize device [new_size[BKMGTEP]] </p>
<p>​    resize2fs [-f]/[-F]/[-M]/[-P]/[-p] device [new_size]</p>
<h4 id="扩展和缩减逻辑卷"><a href="#扩展和缩减逻辑卷" class="headerlink" title="扩展和缩减逻辑卷"></a>扩展和缩减逻辑卷</h4><p>扩展逻辑卷: </p>
<p>​    lvextend -L [+]#[mMgGtT] /dev/VG_NAME/LV_NAME </p>
<p>​    resize2fs /dev/VG_NAME/LV_NAME </p>
<p>​    lvresize -r -l +100%FREE /dev/VG_NAME/LV_NAME </p>
<p>缩减逻辑卷: </p>
<p>​    umount /dev/VG_NAME/LV_NAME </p>
<p>​    e2fsck -f /dev/VG_NAME/LV_NAME </p>
<p>​    resize2fs /dev/VG_NAME/LV_NAME #[mMgGtT] </p>
<p>​    lvreduce -L [-]#[mMgGtT] /dev/VG_NAME/LV_NAME </p>
<p>​    mount </p>
<h4 id="跨主机迁移卷组"><a href="#跨主机迁移卷组" class="headerlink" title="跨主机迁移卷组"></a>跨主机迁移卷组</h4><p>源计算机上 </p>
<p>​    1 在旧系统中,umount所有卷组上的逻辑卷 </p>
<p>​    2 vgchange –a n vg0 lvdisplay </p>
<p>​    3 vgexport vg0 </p>
<p>​        pvscan </p>
<p>​        vgdisplay </p>
<p>​        拆下旧硬盘 </p>
<p> 在目标计算机上 </p>
<p>​    4 在新系统中安装旧硬盘,并vgimport vg0. </p>
<p>​    5 vgchange –ay vg0 </p>
<p>​    6 mount所有卷组上的逻辑卷 </p>
<h4 id="创建逻辑卷示例"><a href="#创建逻辑卷示例" class="headerlink" title="创建逻辑卷示例"></a>创建逻辑卷示例</h4><p>创建物理卷 </p>
<p>​    pvcreate /dev/sda3 </p>
<p>为卷组分配物理卷 </p>
<p>​    vgcreate vg0 /dev/sda3 </p>
<p>从卷组创建逻辑卷 </p>
<p>​    lvcreate -L 256M -n data vg0 </p>
<p>​    mke2fs -j /dev/vg0/data </p>
<p>mount /dev/vg0/data /mnt/data </p>
<h4 id="逻辑卷管理器快照"><a href="#逻辑卷管理器快照" class="headerlink" title="逻辑卷管理器快照"></a>逻辑卷管理器快照</h4><p>快照是特殊的逻辑卷,它是在生成快照时存在的逻辑卷的准确拷贝 </p>
<p>对于需要备份或者复制的现有数据临时拷贝以及其它操作来说,快照是最合适 的选择 </p>
<p>快照只有在它们和原来的逻辑卷不同时才会消耗空间 </p>
<p>​    在生成快照时会分配给它一定的空间,但只有在原来的逻辑卷或者快照有所 改变才会使用这些空间 </p>
<p>​    当原来的逻辑卷中有所改变时,会将旧的数据复制到快照中。 </p>
<p>​    快照中只含有原来的逻辑卷中更改的数据或者自生成快照后的快照中更改的 数据 </p>
<p>​    建立快照的卷大小只需要原始逻辑卷的15%～20%就够了,也可以使用 lvextend放大快照 </p>
<h4 id="逻辑卷管理器快照-1"><a href="#逻辑卷管理器快照-1" class="headerlink" title="逻辑卷管理器快照"></a>逻辑卷管理器快照</h4><p>快照就是将当时的系统信息记录下来,就好像照相一般,若将来有任何数据 改动了,则原始数据会被移动到快照区,没有改动的区域则由快照区和文件 系统共享 </p>
<p>由于快照区与原本的LV共用很多PE的区块,因此快照与被快照的LV必须在同 一个VG中.系统恢复的时候的文件数量不能高于快照区的实际容量 </p>
<h4 id="使用LVM快照"><a href="#使用LVM快照" class="headerlink" title="使用LVM快照"></a>使用LVM快照</h4><p>为现有逻辑卷创建快照 </p>
<p>​    lvcreate -l 64 -s -n data-snapshot -p r /dev/vg0/data </p>
<p>挂载快照 </p>
<p>​    mkdir -p /mnt/snap </p>
<p>​    mount -o ro /dev/vg0/data-snapshot /mnt/snap </p>
<p>恢复快照 </p>
<p>​    umount /dev/vg0/data-snapshot </p>
<p>​    umount /dev/vg0/data </p>
<p>​    lvconvert –merge /dev/vg0/data-snapshot </p>
<p>删除快照 </p>
<p>​    umount /mnt/databackup </p>
<p>​    lvremove /dev/vg0/databackup </p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 网络管理(一)</title>
    <url>/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86-%E4%B8%80/</url>
    <content><![CDATA[<p>信息化社会中每个人都和网络息息相关,大家都能享受到网络带来的快捷和便利.关于网络连接这其实是一个很复杂的事情,学习了很多资料,看过了很多博客之后终于找到阮老师关于互联网原理的讲解.有种恍然大悟的感觉,我转载了文章,希望可以帮助更多的人了解网络的基本原理.</p>
<hr>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="五层模型"><a href="#五层模型" class="headerlink" title="五层模型"></a>五层模型</h4><p>互联网的实现,分成好几层.每一层都有自己的功能,就像建筑物一样,每一层都靠下一层支持.</p>
<p>用户接触到的,只是最上面的一层,根本没有感觉到下面的层.要理解互联网,必须从最下层开始,自下而上理解每一层的功能.</p>
<p>如何分层有不同的模型,有的模型分七层,有的分四层.我觉得,把互联网分成五层,比较容易解释.</p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_1.png" alt=""></p>
<p>如上图所示,最底下的一层叫做”实体层”(Physical Layer),最上面的一层叫做”应用层”(Application Layer),中间的三层(自下而上)分别是”链接层”(Link Layer)、”网络层”(Network Layer)和”传输层”(Transport Layer).越下面的层,越靠近硬件:越上面的层,越靠近用户.</p>
<p>它们叫什么名字,其实并不重要.只需要知道,互联网分成若干层就可以了.</p>
<h4 id="层与协议"><a href="#层与协议" class="headerlink" title="层与协议"></a>层与协议</h4><p>每一层都是为了完成一种功能.为了实现这些功能,就需要大家都遵守共同的规则.</p>
<p>大家都遵守的规则,就叫做”协议”(protocol).</p>
<p>互联网的每一层,都定义了很多协议.这些协议的总称,就叫做”互联网协议”(Internet Protocol Suite).它们是互联网的核心,下面介绍每一层的功能,主要就是介绍每一层的主要协议.</p>
<h3 id="实体层"><a href="#实体层" class="headerlink" title="实体层"></a>实体层</h3><p>我们从最底下的一层开始.</p>
<p>电脑要组网,第一件事要干什么？当然是先把电脑连起来,可以用光缆、电缆、双绞线、无线电波等方式.</p>
<p><strong>这就叫做”实体层”,它就是把电脑连接起来的物理手段.它主要规定了网络的一些电气特性,作用是负责传送0和1的电信号.</strong> </p>
<h3 id="链接层"><a href="#链接层" class="headerlink" title="链接层"></a>链接层</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>单纯的0和1没有任何意义,必须规定解读方式：多少个电信号算一组？每个信号位有何意义？</p>
<p><strong>这就是”链接层”的功能,它在”实体层”的上方,确定了0和1的分组方式.</strong></p>
<h4 id="以太网协议"><a href="#以太网协议" class="headerlink" title="以太网协议"></a>以太网协议</h4><p>早期的时候,每家公司都有自己的电信号分组方式.逐渐地,一种叫做<a href="http://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E7%BD%91" target="_blank" rel="noopener">“以太网”</a>(Ethernet)的协议,占据了主导地位.</p>
<p>以太网规定,一组电信号构成一个数据包,叫做”帧”(Frame).每一帧分成两个部分：标头(Head)和数据(Data).</p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_2.png" alt=""></p>
<p>“标头”包含数据包的一些说明项,比如发送者、接受者、数据类型等等:”数据”则是数据包的具体内容.</p>
<p>“标头”的长度,固定为18字节.”数据”的长度,最短为46字节,最长为1500字节.因此,整个”帧”最短为64字节,最长为1518字节.如果数据很长,就必须分割成多个帧进行发送.</p>
<h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p>上面提到,以太网数据包的”标头”,包含了发送者和接受者的信息.那么,发送者和接受者是如何标识呢？</p>
<p>以太网规定,连入网络的所有设备,都必须具有”网卡”接口.数据包必须是从一块网卡,传送到另一块网卡.网卡的地址,就是数据包的发送地址和接收地址,这叫做MAC地址.</p>
<p>每块网卡出厂的时候,都有一个全世界独一无二的MAC地址,长度是48个二进制位,通常用12个十六进制数表示. </p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_3.png" alt=""></p>
<p>前6个十六进制数是厂商编号,后6个是该厂商的网卡流水号.有了MAC地址,就可以定位网卡和数据包的路径了. </p>
<h4 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h4><p>定义地址只是第一步,后面还有更多的步骤.</p>
<p>首先,一块网卡怎么会知道另一块网卡的MAC地址？</p>
<p>回答是有一种ARP协议,可以解决这个问题.这个留到后面介绍,这里只需要知道,以太网数据包必须知道接收方的MAC地址,然后才能发送.</p>
<p>其次,就算有了MAC地址,系统怎样才能把数据包准确送到接收方？</p>
<p>回答是以太网采用了一种很”原始”的方式,它不是把数据包准确送到接收方,而是向本网络内所有计算机发送,让每台计算机自己判断,是否为接收方.</p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_4.png" alt=""></p>
<p>上图中,1号计算机向2号计算机发送一个数据包,同一个子网络的3号、4号、5号计算机都会收到这个包.它们读取这个包的”标头”,找到接收方的MAC地址,然后与自身的MAC地址相比较,如果两者相同,就接受这个包,做进一步处理,否则就丢弃这个包.这种发送方式就叫做”广播”(broadcasting).</p>
<p>有了数据包的定义、网卡的MAC地址、广播的发送方式,”链接层”就可以在多台计算机之间传送数据了.</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h4 id="网络层的由来"><a href="#网络层的由来" class="headerlink" title="网络层的由来"></a>网络层的由来</h4><p>以太网协议,依靠MAC地址发送数据.理论上,单单依靠MAC地址,上海的网卡就可以找到洛杉矶的网卡了,技术上是可以实现的.</p>
<p>但是,这样做有一个重大的缺点.以太网采用广播方式发送数据包,所有成员人手一”包”,不仅效率低,而且局限在发送者所在的子网络.也就是说,如果两台计算机不在同一个子网络,广播是传不过去的.这种设计是合理的,否则互联网上每一台计算机都会收到所有包,那会引起灾难.</p>
<p>互联网是无数子网络共同组成的一个巨型网络,很像想象上海和洛杉矶的电脑会在同一个子网络,这几乎是不可能的.</p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_5.png" alt=""></p>
<p>因此,必须找到一种方法,能够区分哪些MAC地址属于同一个子网络,哪些不是.如果是同一个子网络,就采用广播方式发送,否则就采用”路由”方式发送.(“路由”的意思,就是指如何向不同的子网络分发数据包,这是一个很大的主题,本文不涉及.)遗憾的是,MAC地址本身无法做到这一点.它只与厂商有关,与所处网络无关.</p>
<p><strong>这就导致了”网络层”的诞生.它的作用是引进一套新的地址,使得我们能够区分不同的计算机是否属于同一个子网络.这套地址就叫做”网络地址”,简称”网址”.</strong></p>
<p>于是,”网络层”出现以后,每台计算机有了两种地址,一种是MAC地址,另一种是网络地址.两种地址之间没有任何联系,MAC地址是绑定在网卡上的,网络地址则是管理员分配的,它们只是随机组合在一起.</p>
<p>网络地址帮助我们确定计算机所在的子网络,MAC地址则将数据包送到该子网络中的目标网卡.因此,从逻辑上可以推断,必定是先处理网络地址,然后再处理MAC地址.</p>
<h4 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h4><p>规定网络地址的协议,叫做IP协议.它所定义的地址,就被称为IP地址.</p>
<p>目前,广泛采用的是IP协议第四版,简称IPv4.这个版本规定,网络地址由32个二进制位组成.</p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_6.png" alt=""></p>
<p>习惯上,我们用分成四段的十进制数表示IP地址,从0.0.0.0一直到255.255.255.255.</p>
<p>互联网上的每一台计算机,都会分配到一个IP地址.这个地址分成两个部分,前一部分代表网络,后一部分代表主机.比如,IP地址172.16.254.1,这是一个32位的地址,假定它的网络部分是前24位(172.16.254),那么主机部分就是后8位(最后的那个1).处于同一个子网络的电脑,它们IP地址的网络部分必定是相同的,也就是说172.16.254.2应该与172.16.254.1处在同一个子网络.</p>
<p>但是,问题在于单单从IP地址,我们无法判断网络部分.还是以172.16.254.1为例,它的网络部分,到底是前24位,还是前16位,甚至前28位,从IP地址上是看不出来的.</p>
<p>那么,怎样才能从IP地址,判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数”子网掩码”(subnet mask).</p>
<p>所谓”子网掩码”,就是表示子网络特征的一个参数.它在形式上等同于IP地址,也是一个32位二进制数字,它的网络部分全部为1,主机部分全部为0.比如,IP地址172.16.254.1,如果已知网络部分是前24位,主机部分是后8位,那么子网络掩码就是11111111.11111111.11111111.00000000,写成十进制就是255.255.255.0.</p>
<p>知道”子网掩码”,我们就能判断,任意两个IP地址是否处在同一个子网络.方法是将两个IP地址与子网掩码分别进行AND运算(两个数位都为1,运算结果为1,否则为0),然后比较结果是否相同,如果是的话,就表明它们在同一个子网络中,否则就不是.</p>
<p>比如,已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0,请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算,结果都是172.16.254.0,因此它们在同一个子网络.</p>
<p>总结一下,IP协议的作用主要有两个,一个是为每一台计算机分配IP地址,另一个是确定哪些地址在同一个子网络.</p>
<h4 id="IP数据包"><a href="#IP数据包" class="headerlink" title="IP数据包"></a>IP数据包</h4><p>根据IP协议发送的数据,就叫做IP数据包.不难想象,其中必定包括IP地址信息.</p>
<p>但是前面说过,以太网数据包只包含MAC地址,并没有IP地址的栏位.那么是否需要修改数据定义,再添加一个栏位呢？</p>
<p>回答是不需要,我们可以把IP数据包直接放进以太网数据包的”数据”部分,因此完全不用修改以太网的规格.这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构.</p>
<p>具体来说,IP数据包也分为”标头”和”数据”两个部分.</p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_7.png" alt=""></p>
<p>“标头”部分主要包括版本、长度、IP地址等信息,”数据”部分则是IP数据包的具体内容.它放进以太网数据包后,以太网数据包就变成了下面这样. </p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_8.png" alt=""></p>
<p>IP数据包的”标头”部分的长度为20到60字节,整个数据包的总长度最大为65,535字节.因此,理论上,一个IP数据包的”数据”部分,最长为65,515字节.前面说过,以太网数据包的”数据”部分,最长只有1500字节.因此,如果IP数据包超过了1500字节,它就需要分割成几个以太网数据包,分开发送了.</p>
<h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><p>关于”网络层”,还有最后一点需要说明.</p>
<p>因为IP数据包是放在以太网数据包里发送的,所以我们必须同时知道两个地址,一个是对方的MAC地址,另一个是对方的IP地址.通常情况下,对方的IP地址是已知的(后文会解释),但是我们不知道它的MAC地址.</p>
<p>所以,我们需要一种机制,能够从IP地址得到MAC地址.</p>
<p>这里又可以分成两种情况.第一种情况,如果两台主机不在同一个子网络,那么事实上没有办法得到对方的MAC地址,只能把数据包传送到两个子网络连接处的”网关”(gateway),让网关去处理.</p>
<p>第二种情况,如果两台主机在同一个子网络,那么我们可以用ARP协议,得到对方的MAC地址.ARP协议也是发出一个数据包(包含在以太网数据包中),其中包含它所要查询主机的IP地址,在对方的MAC地址这一栏,填的是FF:FF:FF:FF:FF:FF,表示这是一个”广播”地址.它所在子网络的每一台主机,都会收到这个数据包,从中取出IP地址,与自身的IP地址进行比较.如果两者相同,都做出回复,向对方报告自己的MAC地址,否则就丢弃这个包.</p>
<p>总之,有了ARP协议之后,我们就可以得到同一个子网络内的主机MAC地址,可以把数据包发送到任意一台主机之上了.</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><h4 id="输层的由来"><a href="#输层的由来" class="headerlink" title="输层的由来"></a>输层的由来</h4><p>有了MAC地址和IP地址,我们已经可以在互联网上任意两台主机上建立通信.</p>
<p>接下来的问题是,同一台主机上有许多程序都需要用到网络,比如,你一边浏览网页,一边与朋友在线聊天.当一个数据包从互联网上发来的时候,你怎么知道,它是表示网页的内容,还是表示在线聊天的内容？</p>
<p>也就是说,我们还需要一个参数,表示这个数据包到底供哪个程序(进程)使用.这个参数就叫做”端口”(port),它其实是每一个使用网卡的程序的编号.每个数据包都发到主机的特定端口,所以不同的程序就能取到自己所需要的数据.</p>
<p>“端口”是0到65535之间的一个整数,正好16个二进制位.0到1023的端口被系统占用,用户只能选用大于1023的端口.不管是浏览网页还是在线聊天,应用程序会随机选用一个端口,然后与服务器的相应端口联系.</p>
<p><strong>“传输层”的功能,就是建立”端口到端口”的通信.相比之下,”网络层”的功能是建立”主机到主机”的通信.只要确定主机和端口,我们就能实现程序之间的交流.</strong>因此,Unix系统就把主机+端口,叫做”套接字”(socket).有了它,就可以进行网络应用程序开发了.</p>
<h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><p>现在,我们必须在数据包中加入端口信息,这就需要新的协议.最简单的实现叫做UDP协议,它的格式几乎就是在数据前面,加上端口号.</p>
<p>UDP数据包,也是由”标头”和”数据”两部分组成.</p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_9.png" alt=""></p>
<p>“标头”部分主要定义了发出端口和接收端口,”数据”部分就是具体的内容.然后,把整个UDP数据包放入IP数据包的”数据”部分,而前面说过,IP数据包又是放在以太网数据包之中的,所以整个以太网数据包现在变成了下面这样： </p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_10.png" alt=""></p>
<p>UDP数据包非常简单,”标头”部分一共只有8个字节,总长度不超过65,535字节,正好放进一个IP数据包.</p>
<h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><p>UDP协议的优点是比较简单,容易实现,但是缺点是可靠性较差,一旦数据包发出,无法知道对方是否收到.</p>
<p>为了解决这个问题,提高网络可靠性,TCP协议就诞生了.这个协议非常复杂,但可以近似认为,它就是有确认机制的UDP协议,每发出一个数据包都要求确认.如果有一个数据包遗失,就收不到确认,发出方就知道有必要重发这个数据包了.</p>
<p>因此,TCP协议能够确保数据不会遗失.它的缺点是过程复杂、实现困难、消耗较多的资源.</p>
<p>TCP数据包和UDP数据包一样,都是内嵌在IP数据包的”数据”部分.TCP数据包没有长度限制,理论上可以无限长,但是为了保证网络的效率,通常TCP数据包的长度不会超过IP数据包的长度,以确保单个TCP数据包不必再分割.</p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用程序收到”传输层”的数据,接下来就要进行解读.由于互联网是开放架构,数据来源五花八门,必须事先规定好格式,否则根本无法解读.</p>
<p><strong>“应用层”的作用,就是规定应用程序的数据格式.</strong></p>
<p>举例来说,TCP协议可以为各种各样的程序传递数据,比如Email、WWW、FTP等等.那么,必须有不同协议规定电子邮件、网页、FTP数据的格式,这些应用程序协议就构成了”应用层”.</p>
<p>这是最高的一层,直接面对用户.它的数据就放在TCP数据包的”数据”部分.因此,现在的以太网的数据包就变成下面这样.</p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_11.png" alt=""></p>
<p>至此,整个互联网的五层结构,自下而上全部讲完了.这是从系统的角度,解释互联网是如何构成的. 下一篇反过来,从用户的角度,自上而下看看这个结构是如何发挥作用,完成一次网络数据交换的. </p>
<p>原文:</p>
<p>[1]  互联网协议入门</p>
<p><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html</a></p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>base</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 网络管理(三)</title>
    <url>/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86-%E4%B8%89/</url>
    <content><![CDATA[<h3 id="互联网协议入门"><a href="#互联网协议入门" class="headerlink" title="互联网协议入门"></a>互联网协议入门</h3><h4 id="物理拓扑分类"><a href="#物理拓扑分类" class="headerlink" title="物理拓扑分类"></a>物理拓扑分类</h4><p><strong>1.总线拓扑</strong></p>
<p>总线拓扑结构是将网络中的所有设备通过相应的硬件接口直接连接到公共总线上，结点之间按广播方式通信，一个结点发出的信息，总线上的其它结点均可“收听”到。优点：结构简单、布线容易、可靠性较高，易于扩充，是局域网常采用的拓扑结构。缺点：所有的数据都需经过总线传送，总线成为整个网络的瓶颈；出现故障诊断较为困难。最著名的总线拓扑结构是以太网(Ethernet)。</p>
<p><strong>2.星型拓扑</strong></p>
<p>每个结点都由一条单独的通信线路与中心结点连结。优点：结构简单、容易实现、便于管理，连接点的故障容易监测和排除。缺点：中心结点是全网络的可靠瓶颈，中心结点出现故障会导致网络的瘫痪。</p>
<p><strong>3.环形拓扑</strong></p>
<p>各结点通过通信线路组成闭合回路，环中数据只能单向传输。优点：结构简单、容易实现，适合使用光纤，传输距离远，传输延迟确定。缺点：环网中的每个结点均成为网络可靠性的瓶颈，任意结点出现故障都会造成网络瘫痪，另外故障诊断也较困难。最著名的环形拓扑结构网络是令牌环网(Token Ring)</p>
<p><strong>4.树型拓扑</strong></p>
<p>是一种层次结构，结点按层次连结，信息交换主要在上下结点之间进行，相邻结点或同层结点之间一般不进行数据交换。优点：连结简单，维护方便，适用于汇集信息的应用要求。缺点：资源共享能力较低，可靠性不高，任何一个工作站或链路的故障都会影响整个网络的运行。</p>
<p><strong>5.网状拓扑</strong></p>
<p>又称作无规则结构，结点之间的联结是任意的，没有规律。优点：系统可靠性高，比较容易扩展，但是结构复杂，每一结点都与多点进行连结，因此必须采用路由算法和流量控制方法。目前广域网基本上采用网状拓扑结构。</p>
<h3 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h3><p><strong>开放式系统互联通信参考模型</strong>（英语：Open System Interconnection Reference Model，缩写为 OSI），简称为<strong>OSI模型</strong> </p>
<h4 id="层次划分"><a href="#层次划分" class="headerlink" title="层次划分"></a>层次划分</h4><p>根据建议X.200，OSI将计算机网络体系结构划分为以下七层，标有1～7，第1层在底部。 现“OSI/RM”是“Open Systems Interconnection Reference Model”的缩写。 </p>
<h5 id="第7层-应用层"><a href="#第7层-应用层" class="headerlink" title="第7层 应用层"></a>第7层 应用层</h5><h5 id="主条目：应用层"><a href="#主条目：应用层" class="headerlink" title="主条目：应用层"></a>主条目：<a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E5%B1%82" target="_blank" rel="noopener">应用层</a></h5><p>应用层（Application Layer）提供为应用软件而设的接口，以设置与另一应用软件之间的通信。例如: HTTP，HTTPS，FTP，TELNET，SSH，SMTP，POP3等。</p>
<h5 id="第6层-表达层"><a href="#第6层-表达层" class="headerlink" title="第6层 表达层"></a>第6层 表达层</h5><h5 id="主条目：表达层"><a href="#主条目：表达层" class="headerlink" title="主条目：表达层"></a>主条目：<a href="https://zh.wikipedia.org/wiki/%E8%A1%A8%E9%81%94%E5%B1%82" target="_blank" rel="noopener">表达层</a></h5><p>表达层（Presentation Layer）把数据转换为能与接收者的系统格式兼容并适合传输的格式。</p>
<h5 id="第5层-会话层"><a href="#第5层-会话层" class="headerlink" title="第5层 会话层"></a>第5层 会话层</h5><p>主条目：<a href="https://zh.wikipedia.org/wiki/%E4%BC%9A%E8%AF%9D%E5%B1%82" target="_blank" rel="noopener">会话层</a></p>
<p>会话层（Session Layer）负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接。</p>
<h5 id="第4层-传输层"><a href="#第4层-传输层" class="headerlink" title="第4层 传输层"></a>第4层 传输层</h5><p>主条目：<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82" target="_blank" rel="noopener">传输层</a></p>
<p>传输层（Transport Layer）把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如:传输控制协议（TCP）等。</p>
<h5 id="第3层-网络层"><a href="#第3层-网络层" class="headerlink" title="第3层 网络层"></a>第3层 网络层</h5><p>主条目：<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%B1%82" target="_blank" rel="noopener">网络层</a></p>
<p>网络层（Network Layer）决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组。网络表头包含了网络数据。例如:互联网协议（IP）等。</p>
<h5 id="第2层-数据链路层"><a href="#第2层-数据链路层" class="headerlink" title="第2层 数据链路层"></a>第2层 数据链路层</h5><p>主条目：<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82" target="_blank" rel="noopener">数据链路层</a></p>
<p>数据链路层（Data Link Layer）负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成帧。数据链表头（DLH）是包含了物理地址和错误侦测及改错的方法。数据链表尾（DLT）是一串指示数据包末端的字符串。例如以太网、无线局域网（Wi-Fi）和通用分组无线服务（GPRS）等。</p>
<p>分为两个子层：逻辑链路控制（logic link control，LLC）子层和介质访问控制（media access control，MAC）子层。</p>
<h5 id="第1层-物理层"><a href="#第1层-物理层" class="headerlink" title="第1层 物理层"></a>第1层 物理层</h5><p>主条目：<a href="https://zh.wikipedia.org/wiki/%E7%89%A9%E7%90%86%E5%B1%82" target="_blank" rel="noopener">物理层</a></p>
<p>物理层（Physical Layer）在局部局域网上传送数据帧（data frame），它负责管理计算机通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机适配器等。</p>
<h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h3><p>OSI的核心思想:</p>
<p><strong>1) 通信两端的主机能够理解对方的语言</strong></p>
<p>这是要求主机使用相同协议格式来发送数据</p>
<p><strong>2) 希望通信系统模块化，每个模块提供标准接口</strong></p>
<p>每个模块给和直接耦合的模块提供标准化的流程接口，每个模块内部无论怎样实现没有硬性规定，但外在的接口一定是标准件，这样耦合的模块可以无缝对接起来。</p>
<p>这样做的好处有：<br>(1) 由于使用标准接口，每个通信模块可以独立开发，增加自由度，提高生产效率<br>(2) 增加代码的重复利用率，由于通信模块的标准化的外在接口，应用程序可以直接使用现成的通信模块，而无需重新编码，这大大减轻了开发者的负担，间接地提供了生产效率。</p>
<table>
<thead>
<tr>
<th>OSI参考模型</th>
<th>各层的解释</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>为应用程序提供服务</td>
</tr>
<tr>
<td>表示层</td>
<td>数据格式转化,数据加密</td>
</tr>
<tr>
<td>会话层</td>
<td>建立,管理和维护回话</td>
</tr>
<tr>
<td>传输层</td>
<td>建立,管理和维护端到端的连接</td>
</tr>
<tr>
<td>网络层</td>
<td>IP选址及路由选择</td>
</tr>
<tr>
<td>数据链路层</td>
<td>提供介质访问和链路管理</td>
</tr>
<tr>
<td>物理层</td>
<td>物理层</td>
</tr>
</tbody></table>
<p> 以上七道工序最终产生了二进制流，除了物理层之外，每道工序都会在原始数据前添加一串属于自己的协议头，每个协议头有源主机的每层工序产生，自然有理解这些协议头的对端，举例来说：</p>
<p><strong>链路层协议头</strong>，这个协议头只有源主机、端接路由器可以理解，只会存活在源主机与其端接的中继路由器，换句话说，其生命周期只限于一根链路，只要端接路由器能顺利接收，其使命就算完成了，那路由器会将其从二进制流剥离掉，剩下打头阵的就是网络层的协议头。</p>
<p><strong>网络层协议头</strong>，其中包含了目的地网络地址，用于指示沿途的路由器，这一串二进制流的目的地是哪里，路由器查询自己的网络地址表，决定再发给更靠近目的地的下一跳路由器。假如找到了一个出接口与下一跳路由器直连，则又要考虑如何添加链路层的协议头了，依据不同的接口类型，添加了适合此链路的链路层协议头，然后再依据物理层介质的不同，物理层将其以光、电、电磁波的信号发送出去。</p>
<p>依照上面类似的步骤，一串二进制流每经过沿途一跳路由器，变换一次链路特有的协议头，但网络层协议头一直不会变，最终这一串二进制流到达了终点。</p>
<p>至此，网络层协议头也完成了其使命，剥离掉网络层协议头，剥离掉之前，先读出网络层协议头的传输层协议代码，把这一串二进制流发给传输层，剩下打头阵的就是传输层的协议头。</p>
<p><strong>传输层协议</strong>，依据传输层协议头里会话层协议代码，先剥离掉传输层协议头，把这一串二进制流发给会话层，剩下打头阵的就是会话层协议头。</p>
<p><strong>会话层协议</strong>，依据会话层议头里表示层协议代码，先剥离掉会话层协议头，把这一串二进制流发给表示层，剩下的头阵的就是表示层协议头。</p>
<p><strong>表示层协议</strong>，依据表示层议头里应用层协议代码，先剥离掉表示层协议头，把这一串二进制流发给应用层，剩下的头阵的就是应用层协议头。</p>
<p><strong>应用层协议</strong>，经过以上一跳一跳路由器的中继、终点主机的一层层协议头的剥离，源主机发给终点主机的数据终于到达终点了，至于数据是文字、图片、音频、视频，则由应用层协议来最终解释。 </p>
<p><strong>PUD</strong> :</p>
<p>PDU: Protocol Data Unit,协议数据单元是指对等层次之间传递的数据单位 </p>
<p>物理层的 PDU是数据位 bit </p>
<p>数据链路层的 PDU是数据帧 frame </p>
<p>网络层的PDU是数据包 packet </p>
<p>传输层的 PDU是数据段 segment </p>
<p>其他更高层次的PDU是消息 message </p>
<p><strong>三种通讯模式</strong></p>
<p>单播:一对一</p>
<p>广播:一对多</p>
<p>组播:多对多</p>
<h3 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a>网络设备</h3><h4 id="Hub集线器"><a href="#Hub集线器" class="headerlink" title="Hub集线器"></a>Hub集线器</h4><p>Hub：多端口中继器 </p>
<p>Hub并不记忆该信息包是由哪个MAC地址发 出，哪个MAC地址在Hub的哪个端口 </p>
<p>Hub的特点： </p>
<p>​    共享带宽 </p>
<p>​    半双工 </p>
<h4 id="以太网桥"><a href="#以太网桥" class="headerlink" title="以太网桥"></a>以太网桥</h4><p>交换式以太网的优势 </p>
<p>• 扩展了网络带宽 </p>
<p>• 分割了网络冲突域，使网络冲突被限制在最小的范围内 </p>
<p>• 交换机作为更加智能的交换设备，能够提供更多用户所要求的功能：优先级、 虚拟网、远程检测…… </p>
<h4 id="以太网桥工作原理"><a href="#以太网桥工作原理" class="headerlink" title="以太网桥工作原理"></a>以太网桥工作原理</h4><p>以太网桥监听数据帧中源MAC地址，学习MAC，建立MAC表 </p>
<p>对于未知MAC地址，网桥将转发到除接收该帧的端口之外的所有端口 </p>
<p>当网桥接到一个数据帧时，如果该帧的目的位于接收端口所在网段上，它就过 滤掉该数据帧；如果目的MAC地址在位于另外一个端口，网桥就将该帧转发到 该端口 </p>
<p>当网桥接到广播帧时候，它立即转发到除接收端口之外的所有其他端口 </p>
<h4 id="HUB和交换机"><a href="#HUB和交换机" class="headerlink" title="HUB和交换机"></a>HUB和交换机</h4><p> 集线器属于OSI的第一层物理层设备，而网桥属于OSI的第二层数据链路层设备 </p>
<p> 从工作方式来看，集线器是一种广播模式，所有端口在一个冲突域里面。网桥 的可以通过端口隔离冲突 </p>
<p> Hub是所有共享总线和共享带宽。网桥每个端口占一个带宽 </p>
<h4 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h4><p>为了实现路由,路由器需要做下列事情: </p>
<p>分隔广播域 </p>
<p>选择路由表中到达目标最好的路径 </p>
<p>维护和检查路由信息 </p>
<p>连接广域网 </p>
<h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><p>把一个数据包从一个设备发送到不同网络里的另一个设备上去。这些工 作依靠路由器来完成。路由器只关心网络的状态和决定网络中的最佳路径。 路由的实现依靠路由器中的路由表来完成 </p>
<h4 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h4><p>• 分隔广播域 </p>
<p>• 安全 </p>
<p>• 灵活管理</p>
<p>资料来源:</p>
<p>[1] 拓扑</p>
<p> <a href="https://baike.baidu.com/item/%E6%8B%93%E6%89%91" target="_blank" rel="noopener">https://baike.baidu.com/item/%E6%8B%93%E6%89%91</a></p>
<p>[2]OSI模型</p>
<p> <a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B</a></p>
<p>[3] 如何生动形象、切中要点地讲解 OSI 七层模型和两主机传输过程? - 车小胖的回答 - 知乎</p>
<p> <a href="https://www.zhihu.com/question/24002080/answer/150830722" target="_blank" rel="noopener">https://www.zhihu.com/question/24002080/answer/150830722</a> </p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>base</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-网络管理(二)</title>
    <url>/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86-%E4%BA%8C/</url>
    <content><![CDATA[<p>上一篇文章分析了互联网的总体构思,从下至上,每一层协议的设计思想.</p>
<p>这是从设计者的角度看问题,今天我想切换到用户的角度,看看用户是如何从上至下,与这些协议互动的.</p>
<hr>
<h3 id="前文小结"><a href="#前文小结" class="headerlink" title="前文小结"></a>前文小结</h3><p>先对前面的内容,做一个小结.</p>
<p>我们已经知道,网络通信就是交换数据包.电脑A向电脑B发送一个数据包,后者收到了,回复一个数据包,从而实现两台电脑之间的通信.数据包的结构,基本上是下面这样:</p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_12.png" alt=""></p>
<p>发送这个包,需要知道两个地址: </p>
<blockquote>
<ul>
<li><p>对方的MAC地址</p>
</li>
<li><p>对方的IP地址</p>
</li>
</ul>
</blockquote>
<p>有了这两个地址,数据包才能准确送到接收者手中.但是,前面说过,MAC地址有局限性,如果两台电脑不在同一个子网络,就无法知道对方的MAC地址,必须通过网关(gateway)转发. </p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_13.jpg" alt=""></p>
<p>上图中,1号电脑要向4号电脑发送一个数据包.它先判断4号电脑是否在同一个子网络,结果发现不是(后文介绍判断方法),于是就把这个数据包发到网关A.网关A通过路由协议,发现4号电脑位于子网络B,又把数据包发给网关B,网关B再转发到4号电脑.</p>
<p>1号电脑把数据包发到网关A,必须知道网关A的MAC地址.所以,数据包的目标地址,实际上分成两种情况:</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>数据包地址</th>
</tr>
</thead>
<tbody><tr>
<td>同一个子网络</td>
<td>对方的MAC地址,对方的IP地址</td>
</tr>
<tr>
<td>非同一个子网络</td>
<td>网关的MAC地址,对方的IP地址</td>
</tr>
</tbody></table>
<p>发送数据包之前,电脑必须判断对方是否在同一个子网络,然后选择相应的MAC地址.接下来,我们就来看,实际使用中,这个过程是怎么完成的. </p>
<h3 id="用户的上网设置"><a href="#用户的上网设置" class="headerlink" title="用户的上网设置"></a>用户的上网设置</h3><h4 id="静态IP地址"><a href="#静态IP地址" class="headerlink" title="静态IP地址"></a>静态IP地址</h4><p>你买了一台新电脑,插上网线,开机,这时电脑能够上网吗？ </p>
<p>通常你必须做一些设置.有时,管理员(或者ISP)会告诉你下面四个参数,你把它们填入操作系统,计算机就能连上网了: </p>
<blockquote>
<ul>
<li>本机的IP地址 　　</li>
<li>子网掩码 　　</li>
<li>网关的IP地址 　　</li>
<li>DNS的IP地址 </li>
</ul>
</blockquote>
<p>这四个参数缺一不可,后文会解释为什么需要知道它们才能上网.由于它们是给定的,计算机每次开机,都会分到同样的IP地址,所以这种情况被称作”静态IP地址上网”.</p>
<p>但是,这样的设置很专业,普通用户望而生畏,而且如果一台电脑的IP地址保持不变,其他电脑就不能使用这个地址,不够灵活.出于这两个原因,大多数用户使用”动态IP地址上网”.</p>
<h4 id="动态IP地址"><a href="#动态IP地址" class="headerlink" title="动态IP地址"></a>动态IP地址</h4><p>所谓”动态IP地址”,指计算机开机后,会自动分配到一个IP地址,不用人为设定.它使用的协议叫做<a href="http://zh.wikipedia.org/zh/DHCP" target="_blank" rel="noopener">DHCP协议</a>.</p>
<p>这个协议规定,每一个子网络中,有一台计算机负责管理本网络的所有IP地址,它叫做”DHCP服务器”.新的计算机加入网络,必须向”DHCP服务器”发送一个”DHCP请求”数据包,申请IP地址和相关的网络参数.</p>
<p>前面说过,如果两台计算机在同一个子网络,必须知道对方的MAC地址和IP地址,才能发送数据包.但是,新加入的计算机不知道这两个地址,怎么发送数据包呢？</p>
<p>DHCP协议做了一些巧妙的规定.</p>
<h4 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h4><p>首先,它是一种应用层协议,建立在UDP协议之上,所以整个数据包是这样的:</p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_14.png" alt=""></p>
<p>(1)最前面的”以太网标头”,设置发出方(本机)的MAC地址和接收方(DHCP服务器)的MAC地址.前者就是本机网卡的MAC地址,后者这时不知道,就填入一个广播地址:FF-FF-FF-FF-FF-FF.</p>
<p>(2)后面的”IP标头”,设置发出方的IP地址和接收方的IP地址.这时,对于这两者,本机都不知道.于是,发出方的IP地址就设为0.0.0.0,接收方的IP地址设为255.255.255.255.</p>
<p>(3)最后的”UDP标头”,设置发出方的端口和接收方的端口.这一部分是DHCP协议规定好的,发出方是68端口,接收方是67端口.</p>
<p>这个数据包构造完成后,就可以发出了.以太网是广播发送,同一个子网络的每台计算机都收到了这个包.因为接收方的MAC地址是FF-FF-FF-FF-FF-FF,看不出是发给谁的,所以每台收到这个包的计算机,还必须分析这个包的IP地址,才能确定是不是发给自己的.当看到发出方IP地址是0.0.0.0,接收方是255.255.255.255,于是DHCP服务器知道”这个包是发给我的”,而其他计算机就可以丢弃这个包.</p>
<p>接下来,DHCP服务器读出这个包的数据内容,分配好IP地址,发送回去一个”DHCP响应”数据包.这个响应包的结构也是类似的,以太网标头的MAC地址是双方的网卡地址,IP标头的IP地址是DHCP服务器的IP地址(发出方)和255.255.255.255(接收方),UDP标头的端口是67(发出方)和68(接收方),分配给请求端的IP地址和本网络的具体参数则包含在Data部分.</p>
<p>新加入的计算机收到这个响应包,于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数.</p>
<h4 id="上网设置-小结"><a href="#上网设置-小结" class="headerlink" title="上网设置:小结"></a>上网设置:小结</h4><p>这个部分,需要记住的就是一点:不管是”静态IP地址”还是”动态IP地址”,电脑上网的首要步骤,是确定四个参数.这四个值很重要,值得重复一遍: </p>
<blockquote>
<ul>
<li>本机的IP地址 　　</li>
<li>子网掩码 　　</li>
<li>网关的IP地址 　　</li>
<li>DNS的IP地址 </li>
</ul>
</blockquote>
<p>有了这几个数值,电脑就可以上网”冲浪”了.接下来,我们来看一个实例,当用户访问网页的时候,互联网协议是怎么运作的.</p>
<h3 id="一个实例-访问网页"><a href="#一个实例-访问网页" class="headerlink" title="一个实例:访问网页"></a>一个实例:访问网页</h3><h4 id="本机参数"><a href="#本机参数" class="headerlink" title="本机参数"></a>本机参数</h4><p>我们假定,经过上一节的步骤,用户设置好了自己的网络参数:</p>
<blockquote>
<ul>
<li>本机的IP地址:192.168.1.100</li>
<li>子网掩码:255.255.255.0</li>
<li>网关的IP地址:192.168.1.1</li>
<li>DNS的IP地址:8.8.8.8</li>
</ul>
</blockquote>
<p>然后他打开浏览器,想要访问Google,在地址栏输入了网址:<a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a>.</p>
<p>这意味着,浏览器要向google发送一个网页请求的数据包.</p>
<h4 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h4><p>我们知道,发送数据包,必须要知道对方的IP地址.但是,现在,我们只知道网址<a href="http://www.google.com,不知道它的IP地址" target="_blank" rel="noopener">www.google.com,不知道它的IP地址</a>.</p>
<p><a href="http://en.wikipedia.org/wiki/Domain_Name_System" target="_blank" rel="noopener">DNS协议</a>可以帮助我们,将这个网址转换成IP地址.已知DNS服务器为8.8.8.8,于是我们向这个地址发送一个DNS数据包(53端口).</p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_15.png" alt=""></p>
<p>然后,DNS服务器做出响应,告诉我们google的IP地址是172.194.72.105.于是,我们知道了对方的IP地址.</p>
<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>接下来,我们要判断,这个IP地址是不是在同一个子网络,这就要用到子网掩码.</p>
<p>已知子网掩码是255.255.255.0,本机用它对自己的IP地址192.168.1.100,做一个二进制的AND运算(两个数位都为1,结果为1,否则为0),计算结果为192.168.1.0；然后对Google的IP地址172.194.72.105也做一个AND运算,计算结果为172.194.72.0.这两个结果不相等,所以结论是,Google与本机不在同一个子网络.</p>
<p>因此,我们要向Google发送数据包,必须通过网关192.168.1.1转发,也就是说,接收方的MAC地址将是网关的MAC地址.</p>
<h4 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h4><p>浏览网页用的是HTTP协议,它的整个数据包构造是这样的:</p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_16.png" alt=""></p>
<p>HTTP部分的内容,类似于下面这样:</p>
<blockquote>
<p>　　GET / HTTP/1.1<br>　　Host: <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a><br>　　Connection: keep-alive<br>　　User-Agent: Mozilla/5.0 (Windows NT 6.1) ……<br>　　Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8<br>　　Accept-Encoding: gzip,deflate,sdch<br>　　Accept-Language: zh-CN,zh;q=0.8<br>　　Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3<br>　　Cookie: … …</p>
</blockquote>
<p>我们假定这个部分的长度为4960字节,它会被嵌在TCP数据包之中.</p>
<h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><p>TCP数据包需要设置端口,接收方(Google)的HTTP端口默认是80,发送方(本机)的端口是一个随机生成的1024-65535之间的整数,假定为51775.</p>
<p>TCP数据包的标头长度为20字节,加上嵌入HTTP的数据包,总长度变为4980字节.</p>
<h4 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h4><p>然后,TCP数据包再嵌入IP数据包.IP数据包需要设置双方的IP地址,这是已知的,发送方是192.168.1.100(本机),接收方是172.194.72.105(Google).</p>
<p>IP数据包的标头长度为20字节,加上嵌入的TCP数据包,总长度变为5000字节.</p>
<h4 id="以太网协议"><a href="#以太网协议" class="headerlink" title="以太网协议"></a>以太网协议</h4><p>最后,IP数据包嵌入以太网数据包.以太网数据包需要设置双方的MAC地址,发送方为本机的网卡MAC地址,接收方为网关192.168.1.1的MAC地址(通过ARP协议得到).</p>
<p>以太网数据包的数据部分,最大长度为1500字节,而现在的IP数据包长度为5000字节.因此,IP数据包必须分割成四个包.因为每个包都有自己的IP标头(20字节),所以四个包的IP数据包的长度分别为1500、1500、1500、560. </p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_17.png" alt=""></p>
<h4 id="服务器端响应"><a href="#服务器端响应" class="headerlink" title="服务器端响应"></a>服务器端响应</h4><p>经过多个网关的转发,Google的服务器172.194.72.105,收到了这四个以太网数据包.</p>
<p>根据IP标头的序号,Google将四个包拼起来,取出完整的TCP数据包,然后读出里面的”HTTP请求”,接着做出”HTTP响应”,再用TCP协议发回来.</p>
<p>本机收到HTTP响应以后,就可以将网页显示出来,完成一次网络通信.</p>
<p>资料参考:<br>[1] 互联网协议入门</p>
<p><a href="http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html</a></p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>base</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 网络管理(四)</title>
    <url>/Linux-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86-%E5%9B%9B/</url>
    <content><![CDATA[<h3 id="TCP协议的三次握手和四次分手"><a href="#TCP协议的三次握手和四次分手" class="headerlink" title="TCP协议的三次握手和四次分手"></a>TCP协议的三次握手和四次分手</h3><blockquote>
<p>在Google Groups的TopLanguage中看到一帖讨论TCP“三次握手”觉得很有意思.贴主提出“TCP建立连接为什么是三次握手？”的问题,在众多回复中,有一条回复写道:“这个问题的本质是, 信道不可靠, 但是通信双发需要就某个问题达成一致. 而要解决这个问题, 无论你在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足”在不可靠信道上可靠地传输信息”这一需求所导致的. 请注意这里的本质需求,信道不可靠, 数据传输要可靠. 三次达到了, 那后面你想接着握手也好, 发数据也好, 跟进行可靠信息传输的需求就没关系了. 因此,如果信道是可靠的, 即无论什么时候发出消息, 对方一定能收到, 或者你不关心是否要保证对方收到你的消息, 那就能像UDP那样直接发送消息就可以了.”.这可视为对“三次握手”目的的另一种解答思路. </p>
</blockquote>
<h3 id="HTTP连接"><a href="#HTTP连接" class="headerlink" title="HTTP连接"></a>HTTP连接</h3><p>HTTP协议即超文本传送协议(Hypertext Transfer Protocol ),是Web联网的基础,也是手机联网常用的协议之一,HTTP协议是建立在TCP协议之上的一种应用.<br>HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应,在请求结束后,会主动释放连接.从建立连接到关闭连接的过程称为“一次连接”.<br>1)在HTTP 1.0中,客户端的每次请求都要求建立一次单独的连接,在处理完本次请求后,就自动释放连接.</p>
<p>2)在HTTP 1.1中则可以在一次连接中处理多个请求,并且多个请求可以重叠进行,不需要等待一个请求结束后再发送下一个请求.</p>
<p>由于HTTP在每次请求结束后都会主动释放连接,因此HTTP连接是一种“短连接”,要保持客户端程序的在线状态,需要不断地向服务器发起连接请求.通常 的做法是即时不需要获得任何数据,客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求,服务器在收到该请求后对客户端进行回复,表明知道 客户端“在线”.若服务器长时间无法收到客户端的请求,则认为客户端“下线”,若客户端长时间无法收到服务器的回复,则认为网络已经断开.</p>
<hr>
<h3 id="SOCKET原理"><a href="#SOCKET原理" class="headerlink" title="SOCKET原理"></a>SOCKET原理</h3><h4 id="套接字-socket-概念"><a href="#套接字-socket-概念" class="headerlink" title="套接字(socket)概念"></a>套接字(socket)概念</h4><p>套接字(socket)是通信的基石,是支持TCP/IP协议的网络通信的基本操作单元.它是网络通信过程中端点的抽象表示,包含进行网络通信必须的五种信息:连接使用的协议,本地主机的IP地址,本地进程的协议端口,远地主机的IP地址,远地进程的协议端口.<br>应用层通过传输层进行数据通信时,TCP会遇到同时为多个应用程序进程提供并发服务的问题.多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据.为了区别不同的应用程序进程和连接,许多计算机操作系统为应用程序与TCP/IP协议交互提供了套接字(Socket)接口.应 用层可以和传输层通过Socket接口,区分来自不同应用程序进程或网络连接的通信,实现数据传输的并发服务.</p>
<h4 id="建立socket连接"><a href="#建立socket连接" class="headerlink" title="建立socket连接"></a>建立socket连接</h4><p>建立Socket连接至少需要一对套接字,其中一个运行于客户端,称为ClientSocket ,另一个运行于服务器端,称为ServerSocket .<br>套接字之间的连接过程分为三个步骤:服务器监听,客户端请求,连接确认.<br>服务器监听:服务器端套接字并不定位具体的客户端套接字,而是处于等待连接的状态,实时监控网络状态,等待客户端的连接请求.<br>客户端请求:指客户端的套接字提出连接请求,要连接的目标是服务器端的套接字.为此,客户端的套接字必须首先描述它要连接的服务器的套接字,指出服务器端套接字的地址和端口号,然后就向服务器端套接字提出连接请求.<br>连接确认:当服务器端套接字监听到或者说接收到客户端套接字的连接请求时,就响应客户端套接字的请求,建立一个新的线程,把服务器端套接字的描述发 给客户端,一旦客户端确认了此描述,双方就正式建立连接.而服务器端套接字继续处于监听状态,继续接收其他客户端套接字的连接请求.</p>
<h4 id="SOCKET连接与TCP连接"><a href="#SOCKET连接与TCP连接" class="headerlink" title="SOCKET连接与TCP连接"></a>SOCKET连接与TCP连接</h4><p>创建Socket连接时,可以指定使用的传输层协议,Socket可以支持不同的传输层协议(TCP或UDP),当使用TCP协议进行连接时,该Socket连接就是一个TCP连接.</p>
<h4 id="Socket连接与HTTP连接"><a href="#Socket连接与HTTP连接" class="headerlink" title="Socket连接与HTTP连接"></a>Socket连接与HTTP连接</h4><p>由于通常情况下Socket连接就是TCP连接,因此Socket连接一旦建立,通信双方即可开始相互发送数据内容,直到双方连接断开.但在实际网 络应用中,客户端到服务器之间的通信往往需要穿越多个中间节点,例如路由器、网关、防火墙等,大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连,因此需要通过轮询告诉网络,该连接处于活跃状态.<br>而HTTP连接使用的是“请求—响应”的方式,不仅在请求时需要先建立连接,而且需要客户端向服务器发出请求后,服务器端才能回复数据.<br>很多情况下,需要服务器端主动向客户端推送数据,保持客户端与服务器数据的实时与同步.此时若双方建立的是Socket连接,服务器就可以直接将数 据传送给客户端；若双方建立的是HTTP连接,则服务器需要等到客户端发送一次请求后才能将数据传回给客户端,因此,客户端定时向服务器端发送连接请求, 不仅可以保持在线,同时也是在“询问”服务器是否有新的数据,如果有就将数据传给客户端.TCP(Transmission Control Protocol)　传输控制协议</p>
<p>TCP是主机对主机层的传输控制协议,提供可靠的连接服务,采用三次握手确认建立一个连接:</p>
<blockquote>
<p>位码即tcp标志位,有6种标示:</p>
<p>SYN(synchronous建立联机) </p>
<p>ACK(acknowledgement 确认) </p>
<p>PSH(push传送) </p>
<p>FIN(finish结束) </p>
<p>RST(reset重置) </p>
<p>URG(urgent紧急)</p>
<p>Sequence number(顺序号码) </p>
<p>Acknowledge number(确认号码)</p>
</blockquote>
<hr>
<h3 id="TCP是什么？"><a href="#TCP是什么？" class="headerlink" title="TCP是什么？"></a>TCP是什么？</h3><p>TCP(Transmission Control Protocol 传输控制协议)是一种面向连接的、可靠的、基于字节流的传输层通信协议.</p>
<p>具体的关于TCP是什么,我不打算详细的说了；当你看到这篇文章时,我想你也知道TCP的概念了,想要更深入的了解TCP的工作,我们就继续.它只是一个超级麻烦的协议,而它又是互联网的基础,也是每个程序员必备的基本功.首先来看看OSI的七层模型:</p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_22.png" alt=""></p>
<p>我们需要知道TCP工作在网络OSI的七层模型中的第四层——Transport层,IP在第三层——Network层,ARP在第二层——Data Link层；在第二层上的数据,我们把它叫Frame,在第三层上的数据叫Packet,第四层的数据叫Segment. 同时,我们需要简单的知道,数据从应用层发下来,会在每一层都会加上头部信息,进行封装,然后再发送到数据接收端.这个基本的流程你需要知道,就是每个数据都会经过数据的封装和解封装的过程. 在OSI七层模型中,每一层的作用和对应的协议如下:</p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_19.gif" alt=""></p>
<p>TCP是一个协议,那这个协议是如何定义的,它的数据格式是什么样子的呢？要进行更深层次的剖析,就需要了解,甚至是熟记TCP协议中每个字段的含义. </p>
<hr>
<h3 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h3><p>其中 ACK SYN 序号 这三个部分在以下会用到,它们的介绍也在下面</p>
<p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_20.jpg" alt=""></p>
<p>上面就是TCP协议头部的格式,由于它太重要了,是理解其它内容的基础,下面就将每个字段的信息都详细的说明一下.</p>
<ul>
<li>Source Port和Destination Port:分别占用16位,表示源端口号和目的端口号；用于区别主机中的不同进程,而IP地址是用来区分不同的主机的,源端口号和目的端口号配合上IP首部中的源IP地址和目的IP地址就能唯一的确定一个TCP连接；</li>
<li>Sequence Number:用来标识从TCP发端向TCP收端发送的数据字节流,它表示在这个报文段中的的第一个数据字节在数据流中的序号；主要用来解决网络报乱序的问题；</li>
<li>Acknowledgment Number:32位确认序列号包含发送确认的一端所期望收到的下一个序号,因此,确认序号应当是上次已成功收到数据字节序号加1.不过,只有当标志位中的ACK标志(下面介绍)为1时该确认序列号的字段才有效.主要用来解决不丢包的问题；</li>
<li>Offset:给出首部中32 bit字的数目,需要这个值是因为任选字段的长度是可变的.这个字段占4bit(最多能表示15个32bit的的字,即4*15=60个字节的首部长度),因此TCP最多有60字节的首部.然而,没有任选字段,正常的长度是20字节；</li>
<li>TCP Flags:TCP首部中有6个标志比特,它们中的多个可同时被设置为1,主要是用于操控TCP的状态机的,依次为URG,ACK,PSH,RST,SYN,FIN.每个标志位的意思如下:</li>
</ul>
<blockquote>
<p>URG:此标志表示TCP包的紧急指针域(后面马上就要说到)有效,用来保证TCP连接不被中断,并且督促中间层设备要尽快处理这些数据；</p>
<p>ACK:此标志表示应答域有效,就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值:0和1,为1的时候表示应答域有效,反之为0；</p>
<p>PSH:这个标志位表示Push操作.所谓Push操作就是指在数据包到达接收端以后,立即传送给应用程序,而不是在缓冲区中排队；</p>
<p>RST:这个标志表示连接复位请求.用来复位那些产生错误的连接,也被用来拒绝错误和非法的数据包；</p>
<p>SYN:表示同步序号,用来建立连接.SYN标志位和ACK标志位搭配使用,当连接请求的时候,SYN=1,ACK=0；连接被响应的时候,SYN=1,ACK=1；这个标志的数据包经常被用来进行端口扫描.扫描者发送一个只有SYN的数据包,如果对方主机响应了一个数据包回来 ,就表明这台主机存在这个端口；但是由于这种扫描方式只是进行TCP三次握手的第一次握手,因此这种扫描的成功表示被扫描的机器不很安全,一台安全的主机将会强制要求一个连接严格的进行TCP的三次握手；</p>
<p>FIN: 表示发送端已经达到数据末尾,也就是说双方的数据传送完成,没有数据可以传送了,发送FIN标志位的TCP数据包后,连接将被断开.这个标志的数据包也经常被用于进行端口扫描.</p>
</blockquote>
<ul>
<li>Window:窗口大小,也就是有名的滑动窗口,用来进行流量控制；这是一个复杂的问题,这篇博文中并不会进行总结的；</li>
</ul>
<p>暂时需要的信息有:</p>
<p><strong>ACK : TCP协议规定,只有ACK=1时有效,也规定连接建立后所有发送的报文的ACK必须为1</strong></p>
<p><strong>SYN(SYNchronization) : 在连接建立时用来同步序号.当SYN=1而ACK=0时,表明这是一个连接请求报文.对方若同意建立连接,则应在响应报文中使SYN=1和ACK=1. 因此, SYN置1就表示这是一个连接请求或连接接受报文.</strong></p>
<p><strong>FIN (finis)即完,终结的意思, 用来释放一个连接.当 FIN = 1 时,表明此报文段的发送方的数据已经发送完毕,并要求释放连接.</strong></p>
<h4 id="三次握手的过程"><a href="#三次握手的过程" class="headerlink" title="三次握手的过程"></a>三次握手的过程</h4><p><img data-src="https://raw.githubusercontent.com/Markupzh/Markupzh.github.io/master/photo/post_network_21.jpg" alt=""></p>
<ol>
<li>第一次握手:建立连接.客户端发送连接请求报文段,将SYN位置为1,Sequence Number为x；然后,客户端进入SYN_SEND状态,等待服务器的确认；</li>
<li>第二次握手:服务器收到客户端的SYN报文段,需要对这个SYN报文段进行确认,设置Acknowledgment Number为x+1(Sequence Number+1)；同时,自己自己还要发送SYN请求信息,将SYN位置为1,Sequence Number为y；服务器端将上述所有信息放到一个报文段(即SYN+ACK报文段)中,一并发送给客户端,此时服务器进入SYN_RECV状态；</li>
<li>第三次握手:客户端收到服务器的SYN+ACK报文段.然后将Acknowledgment Number设置为y+1,向服务器发送ACK报文段,这个报文段发送完毕以后,客户端和服务器端都进入ESTABLISHED状态,完成TCP三次握手.<br>完成了三次握手,客户端和服务器端就可以开始传送数据.以上就是TCP三次握手的总体介绍.</li>
</ol>
<h4 id="四次分手的过程"><a href="#四次分手的过程" class="headerlink" title="四次分手的过程"></a>四次分手的过程</h4><p>当客户端和服务器通过三次握手建立了TCP连接以后,当数据传送完毕,肯定是要断开TCP连接的啊.那对于TCP的断开连接,这里就有了神秘的“四次分手”.</p>
<ol>
<li>第一次分手:主机1(可以使客户端,也可以是服务器端),设置Sequence Number和Acknowledgment Number,向主机2发送一个FIN报文段；此时,主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</li>
<li>第二次分手:主机2收到了主机1发送的FIN报文段,向主机1回一个ACK报文段,Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1,我“同意”你的关闭请求；</li>
<li>第三次分手:主机2向主机1发送FIN报文段,请求关闭连接,同时主机2进入LAST_ACK状态；</li>
<li>第四次分手:主机1收到主机2发送的FIN报文段,向主机2发送ACK报文段,然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后,就关闭连接；此时,主机1等待2MSL后依然没有收到回复,则证明Server端已正常关闭,那好,主机1也可以关闭连接了.</li>
</ol>
<p>至此,TCP的四次分手就这么愉快的完成了.当你看到这里,你的脑子里会有很多的疑问,很多的不懂,感觉很凌乱；没事,我们继续总结.</p>
<h4 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h4><blockquote>
<p>在谢希仁著《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端,因而产生错误”.在另一部经典的《计算机网络》一书中讲“三次握手”的目的是为了解决“网络中存在延迟的重复分组”的问题.</p>
</blockquote>
<p>在谢希仁著《计算机网络》书中同时举了一个例子,如下:</p>
<blockquote>
<p>为什么A还要发送一次确认呢?这主要是为了防止已失效的链接请求报文段突然又传到了B,因而产生了错误.</p>
<p>所以”已失效的连接请求报文段”是这样产生的,考虑一种正常情况.A发出连接请求,但因连接请求报文丢失而未收到确认,于是A再重传一次连接请求.后来收到了确认,建立了连接.数据传输完毕后,就释放了连接.A共发送了两个连接请求报文段,其中一个丢失,第二个到达了B.没有”已失效的连接请求报文段”.</p>
<p>现假定出现了一种异常情况,即A发出的第一个连接请求报文段并没有丢失,而是在某个网络结点长时间滞留了,以致延误到连接释放以后的某个时间才到达B.本来这是一个早已失效的报文段.但B收到此失效的连接请求报文段后,就误认为是A又发出一次新的连接请求.于是就向A发出确认报文段,同意建立连接,假定不采用三次握手,那么只要B发出确认,新的连接就建立了.</p>
<p>由于现在A并没有发出建立连接的请求,因此不会理睬B的确认,也不会向B发送数据.但B却以为新的数据连接已经建立了,并一直等待A发来数据.B的许多资源就这样浪费了.</p>
<p>采用三次握手的方法可以防止上述现象的发生.例如在刚才的情况下,A不会向B的确认发出确认.B由于收不到确认,就知道A并没有要求建立连接.</p>
</blockquote>
<p><strong>这就很明白了,防止了服务器端的一直等待而浪费资源.</strong></p>
<h4 id="为什么要四次分手"><a href="#为什么要四次分手" class="headerlink" title="为什么要四次分手"></a>为什么要四次分手</h4><p>那四次分手又是为何呢？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议.TCP是全双工模式,这就意味着,当主机1发出FIN报文段时,只是表示主机1已经没有数据要发送了,主机1告诉主机2,它的数据已经全部发送完毕了；但是,这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时,表示它已经知道主机1没有数据发送了,但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时,这个时候就表示主机2也没有数据要发送了,就会告诉主机1,我也没有数据要发送了,之后彼此就会愉快的中断这次TCP连接.如果要正确的理解四次分手的原理,就需要了解四次分手过程中的状态变化.</p>
<ul>
<li>FIN_WAIT_1: 这个状态要好好解释一下,其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文.而这两种状态的区别是:FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时,它想主动关闭连接,向对方发送了FIN报文,此时该SOCKET即进入到FIN_WAIT_1状态.而当对方回应ACK报文后,则进入到FIN_WAIT_2状态,当然在实际的正常情况下,无论对方何种情况下,都应该马上回应ACK报文,所以FIN_WAIT_1状态一般是比较难见到的,而FIN_WAIT_2状态还有时常常可以用netstat看到.(主动方)</li>
<li>FIN_WAIT_2:上面已经详细解释了这种状态,实际上FIN_WAIT_2状态下的SOCKET,表示半连接,也即有一方要求close连接,但另外还告诉对方,我暂时还有点数据需要传送给你(ACK信息),稍后再关闭连接.(主动方)</li>
<li>CLOSE_WAIT:这种状态的含义其实是表示在等待关闭.怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己,你系统毫无疑问地会回应一个ACK报文给对方,此时则进入到CLOSE_WAIT状态.接下来呢,实际上你真正需要考虑的事情是察看你是否还有数据发送给对方,如果没有的话,那么你也就可以 close这个SOCKET,发送FIN报文给对方,也即关闭连接.所以你在CLOSE_WAIT状态下,需要完成的事情是等待你去关闭连接.(被动方)</li>
<li>LAST_ACK: 这个状态还是比较容易好理解的,它是被动关闭一方在发送FIN报文后,最后等待对方的ACK报文.当收到ACK报文后,也即可以进入到CLOSED可用状态了.(被动方)</li>
<li>TIME_WAIT: 表示收到了对方的FIN报文,并发送出了ACK报文,就等2MSL后即可回到CLOSED可用状态了.如果FINWAIT1状态下,收到了对方同时带FIN标志和ACK标志的报文时,可以直接进入到TIME_WAIT状态,而无须经过FIN_WAIT_2状态.(主动方)</li>
<li>CLOSED: 表示连接中断.</li>
</ul>
<hr>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例:"></a>实例:</h3><p>TCP的作用是流量控制,主要是控制数据流的传输.下面以浏览网页为例,根据自身理解来解释一下这个过程.(注:第二个ack属于代码段ack位)</p>
<p>握手过程中传送的包里不包含数据,三次握手完毕后,客户端与服务器才正式开始传送数据.</p>
<p>第一次握手:客户端发送syn包(syn=j)到服务器,并进入SYN_SEND状态,等待服务器确认;</p>
<p>第二次握手:服务器收到syn包,必须确认客户的SYN(ack=j+1),同时自己也发送一个SYN包(syn=k),即SYN+ACK包,此时服务器进入SYN_RECV状态;<br>第三次握手:客户端收到服务器的SYN＋ACK包,向服务器发送确认包ACK(ack=k+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手.<br>握手过程中传送的包里不包含数据,三次握手完毕后,客户端与服务器才正式开始传送数据.理想状态下,TCP连接一旦建立,在通信双方中的任何一方主 动关闭连接之前,TCP 连接都将被一直保持下去.断开连接时服务器和客户端均可以主动发起断开TCP连接的请求,断开过程需要经过“四次握手”(过程就不细写了,就是服务器和客 户端交互,最终确定断开)</p>
<h4 id="对应的实例"><a href="#对应的实例" class="headerlink" title="对应的实例"></a>对应的实例</h4><p>IP 192.168.1.116.3337 &gt; 192.168.1.123.7788: S 3626544836:3626544836<br>IP 192.168.1.123.7788 &gt; 192.168.1.116.3337: S 1739326486:1739326486 ack 3626544837<br>IP 192.168.1.116.3337 &gt; 192.168.1.123.7788: ack 1739326487,ack 1</p>
<p>第一次握手:192.168.1.116发送位码syn＝1,随机产生seq number=3626544836的数据包到192.168.1.123,192.168.1.123由SYN=1知道192.168.1.116要求建立联机;</p>
<p>第二次握手:192.168.1.123收到请求后要确认联机信息,向192.168.1.116发送ack number=3626544837,syn=1,ack=1,随机产生seq=1739326486的包;</p>
<p>第三次握手:192.168.1.116收到后检查ack number是否正确,即第一次发送的seq number+1,以及位码ack是否为1,若正确,192.168.1.116会再发送ack number=1739326487,ack=1,192.168.1.123收到后确认seq=seq+1,ack=1则连接建立成功.</p>
<p>资料来源:</p>
<p>[1] 通俗大白话来理解TCP协议的三次握手和四次分手</p>
<p><a href="https://github.com/jawil/blog/issues/14" target="_blank" rel="noopener">https://github.com/jawil/blog/issues/14</a></p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>base</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux进程间通信的几种方式</title>
    <url>/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>进程间通信也是Linux中一个相对基础的内容,网上检索学习回顾一番之后将其记录下来加深记忆,共同学习.</p>
<hr>
<h2 id="进程间通信概述"><a href="#进程间通信概述" class="headerlink" title="进程间通信概述"></a>进程间通信概述</h2><h3 id="进程通信的目的"><a href="#进程通信的目的" class="headerlink" title="进程通信的目的"></a>进程通信的目的</h3><h4 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h4><p>一个进程需要将它的数据发送给另一个进程,发送的数据量在一个字节到几M字节之间</p>
<h4 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h4><p>多个进程想要操作共享数据,一个进程对共享数据</p>
<h4 id="通知事件"><a href="#通知事件" class="headerlink" title="通知事件"></a>通知事件</h4><p>一个进程需要向另一个或一组进程发送消息,通知它（它们）发生了某种事件（如进程终止时要通知父进程）.</p>
<h4 id="资源共享"><a href="#资源共享" class="headerlink" title="资源共享"></a>资源共享</h4><p>多个进程之间共享同样的资源.为了作到这一点,需要内核提供锁和同步机制.</p>
<h4 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h4><p>有些进程希望完全控制另一个进程的执行（如Debug进程）,此时控制进程希望能够拦截另一个进程的所有陷入和异常,并能够及时知道它的状态改变.</p>
<h3 id="Linux-进程间通信（IPC）的发展"><a href="#Linux-进程间通信（IPC）的发展" class="headerlink" title="Linux 进程间通信（IPC）的发展"></a>Linux 进程间通信（IPC）的发展</h3><p>linux下的进程通信手段基本上是从Unix平台上的进程通信手段继承而来的.而对Unix发展做出重大贡献的两大主力AT&amp;T的贝尔实验室及BSD（加州大学伯克利分校的伯克利软件发布中心）在进程间通信方面的侧重点有所不同.</p>
<p>前者对Unix早期的进程间通信手段进行了系统的改进和扩充,形成了“system V IPC”,通信进程局限在单个计算机内；</p>
<p>后者则跳过了该限制,形成了基于套接口（socket）的进程间通信机制.</p>
<p>Linux则把两者继承了下来</p>
<blockquote>
<p>早期UNIX进程间通信</p>
<p>基于System V进程间通信</p>
<p>基于Socket进程间通信</p>
<p>POSIX进程间通信.</p>
</blockquote>
<p>UNIX进程间通信方式包括：管道、FIFO、信号.</p>
<p>System V进程间通信方式包括：System V消息队列、System V信号灯、System V共享内存</p>
<p>POSIX进程间通信包括：posix消息队列、posix信号灯、posix共享内存.</p>
<p>由于Unix版本的多样性,电子电气工程协会（IEEE）开发了一个独立的Unix标准,这个新的ANSI Unix标准被称为计算机环境的可移植性操作系统界面（PSOIX）.现有大部分Unix和流行版本都是遵循POSIX标准的,而Linux从一开始就遵循POSIX标准；</p>
<p>BSD并不是没有涉足单机内的进程间通信（socket本身就可以用于单机内的进程间通信）.事实上,很多Unix版本的单机IPC留有BSD的痕迹,如4.4BSD支持的匿名内存映射、4.3+BSD对可靠信号语义的实现等等.</p>
<h3 id="linux使用的进程间通信方式"><a href="#linux使用的进程间通信方式" class="headerlink" title="linux使用的进程间通信方式"></a>linux使用的进程间通信方式</h3><p>1.管道（pipe）,流管道(s_pipe)和有名管道（FIFO）</p>
<p>2.信号（signal）</p>
<p>3.消息队列</p>
<p>4.共享内存</p>
<p>5.信号量</p>
<p>6.套接字（socket)</p>
<h4 id="管道-pipe"><a href="#管道-pipe" class="headerlink" title="管道( pipe )"></a>管道( pipe )</h4><p>管道这种通讯方式有两种限制,一是半双工的通信,数据只能单向流动,二是只能在具有亲缘关系的进程间使用.进程的亲缘关系通常是指父子进程关系.</p>
<h4 id="流管道-s-pipe"><a href="#流管道-s-pipe" class="headerlink" title="流管道(s_pipe)"></a>流管道(s_pipe)</h4><p>去除了第一种限制,可以双向传输.管道可用于具有亲缘关系进程间的通信,命名管道:name_pipe克服了管道没有名字的限制,因此,除具有管道所具有的功能外,它还允许无亲缘关系进程间的通信；</p>
<h4 id="信号量-semophore"><a href="#信号量-semophore" class="headerlink" title="信号量( semophore )"></a>信号量( semophore )</h4><p>信号量是一个计数器,可以用来控制多个进程对共享资源的访问.它常作为一种锁机制,防止某进程正在访问共享资源时,其他进程也访问该资源.因此,主要作为进程间以及同一进程内不同线程之间的同步手段.</p>
<p>信号是比较复杂的通信方式,用于通知接受进程有某种事件发生,除了用于进程间通信外,进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外,还支持语义符合Posix.1标准的信号函数sigaction（实际上,该函数是基于BSD的,BSD为了实现可靠信号机制,又能够统一对外接口,用sigaction函数重新实现了signal函数）；</p>
<h4 id="消息队列-message-queue"><a href="#消息队列-message-queue" class="headerlink" title="消息队列( message queue )"></a>消息队列( message queue )</h4><p>消息队列是由消息的链表,存放在内核中并由消息队列标识符标识.消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点.</p>
<p>消息队列是消息的链接表,包括Posix消息队列system V消息队列.有足够权限的进程可以向队列中添加消息,被赋予读权限的进程则可以读走队列中的消息.消息队列克服了信号承载信息量少,管道只能承载无格式字节流以及缓冲区大小受限等缺点.</p>
<h4 id="信号-singal"><a href="#信号-singal" class="headerlink" title="信号 ( singal )"></a>信号 ( singal )</h4><p>信号是一种比较复杂的通信方式,用于通知接收进程某个事件已经发生.</p>
<p>主要作为进程间以及同一进程不同线程之间的同步手段.</p>
<h4 id="共享内存-shared-memory"><a href="#共享内存-shared-memory" class="headerlink" title="共享内存( shared memory )"></a>共享内存( shared memory )</h4><p>共享内存就是映射一段能被其他进程所访问的内存,这段共享内存由一个进程创建,但多个进程都可以访问.共享内存是最快的 IPC 方式,它是针对其他进程间通信方式运行效率低而专门设计的.它往往与其他通信机制,如信号量,配合使用,来实现进程间的同步和通信.</p>
<p>使得多个进程可以访问同一块内存空间,是最快的可用IPC形式.是针对其他通信机制运行效率较低而设计的.往往与其它通信机制,如信号量结合使用,来达到进程间的同步及互斥.</p>
<h4 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字( socket )"></a>套接字( socket )</h4><p>套解口也是一种进程间通信机制,与其他通信机制不同的是,它可用于不同机器间的进程通信</p>
<p>更为一般的进程间通信机制,可用于不同机器之间的进程间通信.起初是由Unix系统的BSD分支开发出来的,但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字.</p>
<p>进程间通信各种方式效率比较</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>无连接</th>
<th>可靠</th>
<th>流控制</th>
<th>优先级</th>
</tr>
</thead>
<tbody><tr>
<td>普通PIPE</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>流PIPE</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>命名PIPE(FIFO)</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>消息队列</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>信号量</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>共享存储</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>UNIX流SOCKET</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>UNIX数据包SOCKET</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
</tbody></table>
<p>注:无连接: 指无需调用某种形式的OPEN,就有发送消息的能力流控制;如果系统资源短缺或者不能接收更多消息,则发送进程能进行流量控制</p>
<h3 id="各种通信方式的比较和优缺点"><a href="#各种通信方式的比较和优缺点" class="headerlink" title="各种通信方式的比较和优缺点"></a>各种通信方式的比较和优缺点</h3><p>管道：速度慢,容量有限,只有父子进程能通讯</p>
<p>FIFO：任何进程间都能通讯,但速度慢</p>
<p>消息队列：容量受到系统限制,且要注意第一次读的时候,要考虑上一次没有读完数据的问题</p>
<p>信号量：不能传递复杂消息,只能用来同步</p>
<p>共享内存区：能够很容易控制容量,速度快,但要保持同步,比如一个进程在写的时候,另一个进程要注意读写的问题,相当于线程中的线程安全,当然,共享内存区同样可以用作线程间通讯,不过没这个必要,线程间本来就已经共享了同一进程内的一块内存</p>
<p>如果用户传递的信息较少或是需要通过信号来触发某些行为．前文提到的软中断信号机制不失为一种简捷有效的进程间通信方式．</p>
<p>但若是进程间要求传递的信息量比较大或者进程间存在交换数据的要求,那就需要考虑别的通信方式了.</p>
<p>无名管道简单方便．但局限于单向通信的工作方式．并且只能在创建它的进程及其子孙进程之间实现管道的共享：</p>
<p>有名管道虽然可以提供给任意关系的进程使用．但是由于其长期存在于系统之中,使用不当容易出错．所以普通用户一般不建议使用.</p>
<p>消息缓冲可以不再局限于父子进程,而允许任意进程通过共享消息队列来实现进程间通信,并由系统调用函数来实现消息发送和接收之间的同步,从而使得用户在使用消息缓冲进行通信时不再需要考虑同步问题,使用方便,但是信息的复制需要额外消耗CPU的时间,不适宜于信息量大或操作频繁的场合.</p>
<p>共享内存针对消息缓冲的缺点改而利用内存缓冲区直接交换信息,无须复制,快捷、信息量大是其优点.</p>
<p>但是共享内存的通信方式是通过将共享的内存缓冲区直接附加到进程的虚拟地址空间中来实现的,因此,这些进程之间的读写操作的同步问题操作系统无法实现.必须由各进程利用其他同步工具解决.另外,由于内存实体存在于计算机系统中,所以只能由处于同一个计算机系统中的诸进程共享.不方便网络通信.</p>
<p>共享内存块提供了在任意数量的进程之间进行高效双向通信的机制.每个使用者都可以读取写入数据,但是所有程序之间必须达成并遵守一定的协议,以防止诸如在读取信息之前覆写内存空间等竞争状态的出现.</p>
<p>不幸的是,Linux无法严格保证提供对共享内存块的独占访问,甚至是在您通过使用IPC_PRIVATE创建新的共享内存块的时候也不能保证访问的独占性. 同时,多个使用共享内存块的进程之间必须协调使用同一个键值.</p>
<p>感谢原文作者:</p>
<p> <a href="https://me.csdn.net/gatieme" target="_blank" rel="noopener">JeanCheng</a></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 软件包管理</title>
    <url>/Linux-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h3 id="软件运行和编译"><a href="#软件运行和编译" class="headerlink" title="软件运行和编译"></a>软件运行和编译</h3><p>ABI:Application Binary Interface </p>
<p>​    Windows与Linux不兼容 </p>
<p>​        ELF(Executable and Linkable Format) </p>
<p>​        PE（Portable Executable） </p>
<p>​    库级别的虚拟化: </p>
<p>​        Linux: WINE </p>
<p>​        Windows: Cygwin </p>
<p>API:Application Programming Interface </p>
<p>​    POSIX:Portable OS </p>
<p>程序源代码 –&gt; 预处理 –&gt; 编译 –&gt; 汇编 –&gt; 链接 </p>
<p>​    静态编译:.a </p>
<p>​    动态编译:.so </p>
<h4 id="静态和动态链接"><a href="#静态和动态链接" class="headerlink" title="静态和动态链接"></a>静态和动态链接</h4><p>链接主要作用是把各个模块之间相互引用的部分处理好,使得各个模块之间能 够正确地衔接,分为静态链接和动态链接 </p>
<p>静态链接 </p>
<p>​    把程序对应的依赖库复制一份到包 </p>
<p>​    libxxx.a </p>
<p>​    嵌入程序包 </p>
<p>​    升级难,需重新编译 </p>
<p>​    占用较多空间,迁移容易 </p>
<p>动态链接 </p>
<p>​    只把依赖加做一个动态链接 </p>
<p>​    libxxx.so </p>
<p>​    连接指向 </p>
<p>​    占用较少空间,升级方便 </p>
<h3 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h3><p>二进制应用程序的组成部分: </p>
<p>​    二进制文件、库文件、配置文件、帮助文件 </p>
<p>程序包管理器: </p>
<p>​    debian:deb文件,dpkg包管理器 </p>
<p>​    redhat:     rpm文件,rpm包管理器 </p>
<p>​    rpm:         Redhat Package Manager </p>
<p>​                RPM Package Manager </p>
<h4 id="包命名"><a href="#包命名" class="headerlink" title="包命名"></a>包命名</h4><p>源代码:name-VERSION.tar.gz|bz2|xz </p>
<p>​    VERSION: major.minor.release </p>
<p>rpm包命名方式: </p>
<p>​    name-VERSION-release.arch.rpm </p>
<p>​    例:bash-4.2.46-19.el7.x86_64.rpm </p>
<p>​    VERSION: major.minor.release </p>
<p>​    release:release.OS </p>
<p>​    常见的arch: </p>
<p>​    x86: i386,i486,i586,i686 </p>
<p>​    x86_64: x64,x86_64,amd64 </p>
<p>​    powerpc: ppc </p>
<p>​    跟平台无关:noarch </p>
<h4 id="包命名和工具"><a href="#包命名和工具" class="headerlink" title="包命名和工具"></a>包命名和工具</h4><p>包:分类和拆包 </p>
<p>​    Application-VERSION-ARCH.rpm: 主包 </p>
<p>​    Application-devel-VERSION-ARCH.rpm 开发子包 </p>
<p>​    Application-utils-VERSION-ARHC.rpm 其它子包 </p>
<p>​    Application-libs-VERSION-ARHC.rpm 其它子包 </p>
<p>包之间:可能存在依赖关系,甚至循环依赖 </p>
<p>解决依赖包管理工具: </p>
<p>​    yum:rpm包管理器的前端工具 </p>
<p>​    apt-get:deb包管理器前端工具 </p>
<p>​    zypper: suse上的rpm前端管理工具 </p>
<p>​    dnf: Fedora 18+ rpm包管理器前端管理工具</p>
<h4 id="库文件"><a href="#库文件" class="headerlink" title="库文件"></a>库文件</h4><p>查看二进制程序所依赖的库文件 </p>
<p>​    ldd /PATH/TO/BINARY_FILE </p>
<p>管理及查看本机装载的库文件 </p>
<p>​    ldconfig 加载库文件 </p>
<p>​    /sbin/ldconfig -p: 显示本机已经缓存的所有可用库文件名及文件路径 映射关系 </p>
<p>​    配置文件:/etc/ld.so.conf,/etc/ld.so.conf.d/*.conf </p>
<p>​    缓存文件:/etc/ld.so.cache </p>
<h4 id="包管理器-1"><a href="#包管理器-1" class="headerlink" title="包管理器"></a>包管理器</h4><p>程序包管理器: </p>
<p>​    功能:将编译好的应用程序的各组成文件打包一个或几个程序包文件,从而 方便快捷地实现程序包的安装、卸载、查询、升级和校验等管理操作 </p>
<p>包文件组成 (每个包独有) </p>
<p>​    RPM包内的文件 </p>
<p>​    RPM的元数据,如名称,版本,依赖性,描述等 </p>
<p>​    安装或卸载时运行的脚本 </p>
<p>数据库(公共):/var/lib/rpm </p>
<p>​    程序包名称及版本 </p>
<p>​    依赖关系 </p>
<p>​    功能说明 </p>
<p>​    包安装后生成的各文件路径及校验码信息 </p>
<h4 id="程序包的来源"><a href="#程序包的来源" class="headerlink" title="程序包的来源"></a>程序包的来源</h4><p>管理程序包的方式: </p>
<p>​    使用包管理器:rpm </p>
<p>​    使用前端工具:yum,dnf </p>
<p>获取程序包的途径: </p>
<p>​    (1) 系统发版的光盘或官方的服务器 </p>
<p>​        CentOS镜像: </p>
<p>​        <a href="https://www.centos.org/download/" target="_blank" rel="noopener">https://www.centos.org/download/</a> </p>
<p>​        <a href="http://mirrors.aliyun.com" target="_blank" rel="noopener">http://mirrors.aliyun.com</a> </p>
<p>​        <a href="http://mirrors.sohu.com" target="_blank" rel="noopener">http://mirrors.sohu.com</a> </p>
<p>​        <a href="http://mirrors.163.com" target="_blank" rel="noopener">http://mirrors.163.com</a> </p>
<p>​    (2) 项目官方站点 </p>
<p>​    (3) 第三方组织: </p>
<p>​        Fedora-EPEL: </p>
<p>​            Extra Packages for Enterprise Linux </p>
<p>​        Rpmforge:RHEL推荐,包很全 </p>
<p>​        搜索引擎: </p>
<p>​            <a href="http://pkgs.org" target="_blank" rel="noopener">http://pkgs.org</a> </p>
<p>​            <a href="http://rpmfind.net" target="_blank" rel="noopener">http://rpmfind.net</a> </p>
<p>​            <a href="http://rpm.pbone.net" target="_blank" rel="noopener">http://rpm.pbone.net</a> </p>
<p>​            <a href="https://sourceforge.net/" target="_blank" rel="noopener">https://sourceforge.net/</a> </p>
<p>​    (4) 自己制作 </p>
<p>​    注意:第三方包建议要检查其合法性 来源合法性,程序包的完整性 </p>
<h3 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h3><h4 id="rpm包管理"><a href="#rpm包管理" class="headerlink" title="rpm包管理"></a>rpm包管理</h4><p>CentOS系统上使用rpm命令管理程序包: </p>
<p>​    安装、卸载、升级、查询、校验、数据库维护 </p>
<p>​    安装: </p>
<p>​    rpm {-i|–install} [install-options] PACKAGE_FILE… </p>
<p>​        -v: verbose </p>
<p>​        -vv: </p>
<p>​        -h: 以#显示程序包管理执行进度 </p>
<p>​    rpm -ivh PACKAGE_FILE  </p>
<h4 id="rpm包安装"><a href="#rpm包安装" class="headerlink" title="rpm包安装"></a>rpm包安装</h4><p>[install-options] </p>
<p>​    –test: 测试安装,但不真正执行安装,即dry run模式 </p>
<p>​    –nodeps:忽略依赖关系 </p>
<p>​    –replacepkgs | replacefiles </p>
<p>​    –nosignature: 不检查来源合法性 </p>
<p>​    –nodigest:不检查包完整性 </p>
<p>​    –noscripts:不执行程序包脚本 </p>
<p>​        %pre: 安装前脚本     –nopre </p>
<p>​        %post: 安装后脚本 –nopost </p>
<p>​        %preun: 卸载前脚本 –nopreun </p>
<p>​        %postun: 卸载后脚本 –nopostun </p>
<h4 id="rpm包升级"><a href="#rpm包升级" class="headerlink" title="rpm包升级"></a>rpm包升级</h4><p>rpm {-U|–upgrade} [install-options] PACKAGE_FILE… </p>
<p>rpm {-F|–freshen} [install-options] PACKAGE_FILE…     </p>
<p>​    upgrade:安装有旧版程序包,则“升级” 如果不存在旧版程序包,则“安装” </p>
<p>​    freshen:安装有旧版程序包,则“升级” 如果不存在旧版程序包,则不执行升级操作 </p>
<p>​    rpm -Uvh PACKAGE_FILE … </p>
<p>​    rpm -Fvh PACKAGE_FILE … </p>
<p>​    –oldpackage:降级 </p>
<p>​    –force: 强制安装 </p>
<h4 id="升级注意事项"><a href="#升级注意事项" class="headerlink" title="升级注意事项"></a>升级注意事项</h4><p>(1) 不要对内核做升级操作；Linux支持多内核版本并存,因此,对直接安装新版本内核 </p>
<p>(2) 如果原程序包的配置文件安装后曾被修改,升级时,新版本的提供的同一个配 置文件并不会直接覆盖老版本的配置文件,而把新版本的文件重命名 (FILENAME.rpmnew)后保留 </p>
<h4 id="包查询"><a href="#包查询" class="headerlink" title="包查询"></a>包查询</h4><p>rpm {-q|–query} [select-options]/[query-options] </p>
<p>[select-options] </p>
<p>​    -a: 所有包 </p>
<p>​    -f: 查看指定的文件由哪个程序包安装生成 </p>
<p>​    -p rpmfile:针对尚未安装的程序包文件做查询操作 </p>
<p>​    –whatprovides CAPABILITY:查询指定的CAPABILITY由哪个包所提供 </p>
<p>​    –whatrequires CAPABILITY:查询指定的CAPABILITY被哪个包所依赖 </p>
<p>rpm2cpio 包文件|cpio –itv 预览包内文件 </p>
<p>rpm2cpio 包文件|cpio –id “*.conf” 释放包内文件 </p>
<p>[query-options] </p>
<p>​    –changelog:查询rpm包的changelog </p>
<p>​    -c: 查询程序的配置文件 </p>
<p>​    -d: 查询程序的文档 </p>
<p>​    -i: information </p>
<p>​    -l: 查看指定的程序包安装后生成的所有文件 </p>
<p>​    –scripts:程序包自带的脚本 </p>
<p>​    –provides: 列出指定程序包所提供的CAPABILITY </p>
<p>​    -R: 查询指定的程序包所依赖的CAPABILITY </p>
<p>常用查询用法: </p>
<p>​    -qi PACKAGE,</p>
<p>​    -qf FILE,</p>
<p>​    -qc PACKAGE,</p>
<p>​    -ql PACKAGE,</p>
<p>​    -qd PACKAGE </p>
<p>​    -qpi PACKAGE_FILE,</p>
<p>​    -qpl PACKAGE_FILE,… </p>
<p>​    -qa </p>
<p>包卸载: rpm {-e|–erase} [–allmatches]/[–nodeps]/[–noscripts]/[–notriggers]/[–test] PACKAGE_NAME … </p>
<h4 id="包校验"><a href="#包校验" class="headerlink" title="包校验"></a>包校验</h4><p>rpm {-V|–verify} [select-options]/[verify-options] </p>
<p>​    S file Size differs </p>
<p>​    M Mode differs (includes permissions and file type) </p>
<p>​    5 digest (formerly MD5 sum) differs </p>
<p>​    D Device major/minor number mismatch </p>
<p>​    L readLink(2) path mismatch </p>
<p>​    U User ownership differs </p>
<p>​    G Group ownership differs </p>
<p>​    T mTime differs </p>
<p>​    P capabilities differ </p>
<p>包来源合法性验正及完整性验正 </p>
<p>​    完整性验正:SHA256 </p>
<p>​    来源合法性验正:RSA </p>
<p> 公钥加密 </p>
<p>​    对称加密:加密、解密使用同一密钥 </p>
<p>​    非对称加密:密钥是成对儿的 </p>
<p>​        public key: 公钥,公开所有人 </p>
<p>​        secret key: 私钥,不能公开 </p>
<p> 导入所需要公钥 </p>
<p>​    rpm -K|checksig rpmfile 检查包的完整性和签名 </p>
<p>​    rpm –import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7         </p>
<p>​    CentOS 7发行版光盘提供:RPM-GPG-KEY-CentOS-7 </p>
<p>​    rpm -qa “gpg-pubkey*” </p>
<h4 id="rpm数据库"><a href="#rpm数据库" class="headerlink" title="rpm数据库"></a>rpm数据库</h4><p>数据库重建: </p>
<p>​    /var/lib/rpm </p>
<p>rpm {–initdb|–rebuilddb} </p>
<p>​    initdb: 初始化 </p>
<p>​        如果事先不存在数据库,则新建之 </p>
<p>​        否则,不执行任何操作 </p>
<p>​    rebuilddb:重建已安装的包头的数据库索引目录 </p>
<h3 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h3><h4 id="yum包管理"><a href="#yum包管理" class="headerlink" title="yum包管理"></a>yum包管理</h4><p>CentOS: yum,dnf </p>
<p>YUM: Yellowdog Update Modifier,rpm的前端程序,可解决软件包相关依 赖性,可在多个库之间定位软件包,up2date的替代工具 </p>
<p>​    yum repository: yum repo,存储了众多rpm包,以及包的相关的元数据文件（放置于特定目录repodata下） </p>
<p>​    文件服务器: </p>
<p>​        http:// </p>
<p>​        https:// </p>
<p>​        ftp:// </p>
<p>​        file:// </p>
<h4 id="yum配置文件"><a href="#yum配置文件" class="headerlink" title="yum配置文件"></a>yum配置文件</h4><p>yum客户端配置文件: </p>
<p>​    /etc/yum.conf:为所有仓库提供公共配置     </p>
<p>​    /etc/yum.repos.d/*.repo:为仓库的指向提供配置 </p>
<p>​    仓库指向的定义: </p>
<p>​    [repositoryID] </p>
<p>​    name=Some name for this repository </p>
<p>​    baseurl=url://path/to/repository/ enabled={1|0} </p>
<p>​    gpgcheck={1|0} gpgkey=URL enablegroups={1|0} </p>
<p>​    failovermethod={roundrobin|priority} </p>
<p>​        roundrobin:意为随机挑选,默认值 </p>
<p>​        priority:按顺序访问 </p>
<p>​    cost= 默认为1000 </p>
<h4 id="yum仓库"><a href="#yum仓库" class="headerlink" title="yum仓库"></a>yum仓库</h4><p>yum的repo配置文件中可用的变量: </p>
<p>​    $releasever: 当前OS的发行版的主版本号 </p>
<p>​    $arch: 平台,i386,i486,i586,x86_64等 </p>
<p>​    $basearch:基础平台；i386,x86_64 </p>
<p>​    $YUM0-$YUM9:自定义变量 </p>
<p>实例: </p>
<p>​    <a href="http://server/centos/$releasever/$basearch/" target="_blank" rel="noopener">http://server/centos/$releasever/$basearch/</a> </p>
<p>​    <a href="http://server/centos/7/x86_64" target="_blank" rel="noopener">http://server/centos/7/x86_64</a> </p>
<p>​    <a href="http://server/centos/6/i384" target="_blank" rel="noopener">http://server/centos/6/i384</a> </p>
<h4 id="yum源"><a href="#yum源" class="headerlink" title="yum源"></a>yum源</h4><p>阿里云repo文件: </p>
<p>​    <a href="http://mirrors.aliyun.com/repo/" target="_blank" rel="noopener">http://mirrors.aliyun.com/repo/</a> </p>
<p>CentOS系统的yum源 </p>
<p>​    阿里云:</p>
<p>​    <a href="https://mirrors.aliyun.com/centos/$releasever/os/x86_64/" target="_blank" rel="noopener">https://mirrors.aliyun.com/centos/$releasever/os/x86_64/</a>     清华大学:</p>
<p>​    <a href="https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/os/x86_64/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/os/x86_64/</a> </p>
<p>EPEL的yum源: </p>
<p>​    阿里云:</p>
<p>​    <a href="https://mirrors.aliyun.com/epel/$releasever/x86_64" target="_blank" rel="noopener">https://mirrors.aliyun.com/epel/$releasever/x86_64</a> </p>
<h4 id="yum-config-manager"><a href="#yum-config-manager" class="headerlink" title="yum-config-manager"></a>yum-config-manager</h4><p>生成172.16.0.1_cobbler_ks_mirror_CentOS-X-x86_64_.repo </p>
<p>yum-config-manager –add-repo= <a href="http://172.16.0.1/cobbler/ks_mirror/7/" target="_blank" rel="noopener">http://172.16.0.1/cobbler/ks_mirror/7/</a> </p>
<p>yum-config-manager –disable “仓库名” 禁用仓库 </p>
<p>yum-config-manager –enable “仓库名” 启用仓库 </p>
<h4 id="yum命令"><a href="#yum命令" class="headerlink" title="yum命令"></a>yum命令</h4><p>yum命令的用法: </p>
<p>​    yum [options]/[command]/[package …] </p>
<p>显示仓库列表: </p>
<p>​    yum repolist [all|enabled|disabled] </p>
<p>显示程序包: </p>
<p>​    yum list </p>
<p>​    yum list [all | glob_exp1]/[glob_exp2]/[…] </p>
<p>​    yum list {available|installed|updates} [glob_exp1]/[…] </p>
<p>安装程序包: </p>
<p>​    yum install package1 [package2]/[…] </p>
<p>​    yum reinstall package1 [package2]/[…] (重新安装) </p>
<p>升级程序包: </p>
<p>​    yum update [package1]/[package2] /[…] </p>
<p>​    yum downgrade package1 [package2]/[…] (降级) </p>
<p>检查可用升级: </p>
<p>​    yum check-update </p>
<p>卸载程序包: </p>
<p>​    yum remove | erase package1 [package2]/[…] </p>
<p>查看程序包information: </p>
<p>​    yum info […] </p>
<p>查看指定的特性(可以是某文件)是由哪个程序包所提供: </p>
<p>​    yum provides | whatprovides feature1 [feature2]/[…] </p>
<p>清理本地缓存: </p>
<p>​    清除/var/cache/yum/$basearch/$releasever缓存 </p>
<p>​    yum clean [ packages | metadata | expire-cache | rpmdb | plugins | all ] </p>
<p>构建缓存: </p>
<p>​    yum makecache </p>
<p>搜索:yum search string1 [string2]/[…] </p>
<p>​    以指定的关键字搜索程序包名及summary信息 </p>
<p>查看指定包所依赖的capabilities: yum deplist package1 [package2][…] </p>
<p>查看yum事务历史: </p>
<p>​    yum history [info|list|packages-list|packages-info| </p>
<p>​    summary|addon-info|redo|undo| </p>
<p>​    rollback|new|sync|stats] </p>
<p>​    yum history </p>
<p>​    yum history info 6 </p>
<p>​    yum history undo 6 </p>
<p>日志 :/var/log/yum.log </p>
<p>安装及升级本地程序包: </p>
<p>​    yum localinstall rpmfile1 [rpmfile2]/[…] </p>
<p>​    (用install替代) </p>
<p>​    yum localupdate rpmfile1 rpmfile2]/[…] </p>
<p>​    (用update替代) </p>
<p>包组管理的相关命令: </p>
<p>​    yum groupinstall group1 [group2]/[…] </p>
<p>​    yum groupupdate group1 [group2]/[…] </p>
<p>​    yum grouplist [hidden]/[groupwildcard]/[…] </p>
<p>​    yum groupremove group1 [group2]/[…] </p>
<p>​    yum groupinfo group1 […] </p>
<p>yum的命令行选项: </p>
<p>​    –nogpgcheck:禁止进行gpg check </p>
<p>​    -y: 自动回答为“yes” </p>
<p>​    -q:静默模式 </p>
<p>​    –disablerepo=repoidglob:临时禁用此处指定的repo </p>
<p>​    –enablerepo=repoidglob:临时启用此处指定的repo </p>
<p>​    –noplugins:禁用所有插件 </p>
<h4 id="系统光盘的yum仓库"><a href="#系统光盘的yum仓库" class="headerlink" title="系统光盘的yum仓库"></a>系统光盘的yum仓库</h4><p>系统安装光盘作为本地yum仓库: </p>
<p>​    (1) 挂载光盘至某目录,例如/mnt/cdrom </p>
<p>​        mount /dev/cdrom /mnt/cdrom </p>
<p>​    (2) 创建配置文件 </p>
<p>​        [CentOS7] </p>
<p>​        name= </p>
<p>​        baseurl= </p>
<p>​        gpgcheck= </p>
<p>​        enabled= </p>
<p>创建yum仓库: </p>
<p>​    createrepo [options]  <directory></p>
<h3 id="程序包编译"><a href="#程序包编译" class="headerlink" title="程序包编译"></a>程序包编译</h3><p>程序包编译安装: </p>
<p>Application-VERSION-release.src.rpm –&gt; 安装后,使用rpmbuild命令制作 成二进制格式的rpm包,而后再安装 </p>
<p>源代码–&gt;预处理–&gt;编译–&gt;汇编–&gt;链接–&gt;执行 </p>
<p>源代码组织格式: </p>
<p>​    多文件:文件中的代码之间,很可能存在跨文件依赖关系 </p>
<p>​    C、C++:make 项目管理器 </p>
<p>​        configure脚本 –&gt; Makefile.in –&gt; Makefile </p>
<p>​    java: maven </p>
<h4 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h4><p>C语言源代码编译安装三步骤: </p>
<p>​     1、./configure </p>
<p>​    (1) 通过选项传递参数,指定启用特性、安装路径等；执行时会参考用户的 指定以及Makefile.in文件生成Makefile </p>
<p>​    (2) 检查依赖到的外部环境,如依赖的软件包 </p>
<p>​     2、make 根据Makefile文件,构建应用程序 </p>
<p>​     3、make install 复制文件到相应路径 </p>
<p>开发工具: </p>
<p>​    autoconf: 生成configure脚本 </p>
<p>​    automake:生成Makefile.in </p>
<p>注意:安装前查看INSTALL,README </p>
<p>开源程序源代码的获取: </p>
<p>​    官方自建站点: </p>
<p>​    apache.org (ASF:Apache Software Foundation) </p>
<p>​    mariadb.org </p>
<p>​    … </p>
<p>​    代码托管: </p>
<p>​    SourceForge.net </p>
<p>​    Github.com </p>
<p>​    code.google.com </p>
<p>c/c++编译器: gcc (GNU C Complier) </p>
<p>编译C源代码: </p>
<p>​    准备:提供开发工具及开发环境 </p>
<p>​        开发工具:make,gcc等 </p>
<p>​        开发环境:开发库,头文件 </p>
<p>​            glibc:标准库 </p>
<p>​    实现:通过“包组”提供开发组件 </p>
<p>​        Development Tools </p>
<p>​        Server Platform Development </p>
<p>第一步:configure脚本 </p>
<p>​    选项:指定安装位置、指定启用的特性 </p>
<p>​        –help: 获取其支持使用的选项 </p>
<p>​    选项分类: </p>
<p>​        安装路径设定: </p>
<p>​        –prefix=/PATH: 指定默认安装位置,默认为/usr/local/ </p>
<p>​        –sysconfdir=/PATH:配置文件安装位置 </p>
<p>​    System types:支持交叉编译 </p>
<p>​    Optional Features: 可选特性 </p>
<p>​        –disable-FEATURE </p>
<p>​        –enable-FEATURE[=ARG] </p>
<p>​     Optional Packages: 可选包 </p>
<p>​        –with-PACKAGE[=ARG],依赖包 </p>
<p>​        –without-PACKAGE,禁用依赖关系 </p>
<p>​     注意:通常被编译操作依赖的程序包,需要安装此程序包的“开发”组件,其包名 一般类似于name-devel-VERSION </p>
<p>第二步:make </p>
<p>第三步:make install </p>
<p>安装后的配置: </p>
<p>​     (1) 二进制程序目录导入至PATH环境变量中 </p>
<p>​        编辑文件/etc/profile.d/NAME.sh </p>
<p>​        export PATH=/PATH/TO/BIN:$PATH </p>
<p>​     (2) 导入库文件路径 </p>
<p>​        编辑/etc/ld.so.conf.d/NAME.conf </p>
<p>​            添加新的库文件所在目录至此文件中 </p>
<p>​        让系统重新生成缓存: </p>
<p>​            ldconfig [-v] </p>
<p>​    (3) 导入头文件 </p>
<p>​        基于链接的方式实现: </p>
<p>​            ln -sv </p>
<p>​    (4) 导入帮助手册 </p>
<p>​        编辑/etc/man.config|man_db.conf文件 </p>
<p>​        添加一个MANPATH </p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 中使用static,class,abstract方法</title>
    <url>/Python-%E4%B8%AD%E4%BD%BF%E7%94%A8static-class-abstract%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h4 id="方法在Python中是如何工作的"><a href="#方法在Python中是如何工作的" class="headerlink" title="方法在Python中是如何工作的"></a>方法在Python中是如何工作的</h4><p>方法就是一个函数，它作为一个类属性而存在，你可以用如下方式来声明、访问一个函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, size)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.size = size</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">get_size</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> self.size</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Pizza.get_size</span><br><span class="line">&lt;unbound method Pizza.get_size&gt;</span><br></pre></td></tr></table></figure>

<p><em>Python在告诉你，属性_get_size</em>是类<em>Pizza</em>的一个<strong>未绑定</strong>方法。这是什么意思呢？很快我们就会知道答案：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Pizza.get_size()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unbound method get_size() must be called <span class="keyword">with</span> Pizza instance <span class="keyword">as</span> first argument (got nothing instead)</span><br></pre></td></tr></table></figure>

<p>我们不能这么调用，因为它还没有绑定到<em>Pizza</em>类的任何实例上，它需要一个实例作为第一个参数传递进去（Python2必须是该类的实例，Python3中可以是任何东西），尝试一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Pizza.get_size(Pizza(<span class="number">42</span>))</span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure>

<p>太棒了，现在用一个实例作为它的的第一个参数来调用，整个世界都清静了，如果我说这种调用方式还不是最方便的，你也会这么认为的；没错，现在每次调用这个方法的时候我们都不得不引用这个类，如果不知道哪个类是我们的对象，长期看来这种方式是行不通的。</p>
<p><em>那么Python为我们做了什么呢，它绑定了所有来自类_Pizza</em>的方法以及该类的任何一个实例的方法。也就意味着现在属性<em>get_size</em>是<em>Pizza</em>的一个实例对象的绑定方法，这个方法的第一个参数就是该实例本身。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Pizza(<span class="number">42</span>).get_size</span><br><span class="line">&lt;bound method Pizza.get_size of &lt;__main__.Pizza object at <span class="number">0x7f3138827910</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Pizza(<span class="number">42</span>).get_size()</span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure>

<p><em>和我们预期的一样，现在不再需要提供任何参数给_get_size</em>，因为它已经是绑定的，它的<em>self</em>参数会自动地设置给<em>Pizza</em>实例，下面代码是最好的证明：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = Pizza(<span class="number">42</span>).get_size</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m()</span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure>

<p>更有甚者，你都没必要使用持有<em>Pizza</em>对象的引用了，因为该方法已经绑定到了这个对象，所以这个方法对它自己来说是已经足够了。</p>
<p>也许，如果你想知道这个绑定的方法是绑定在哪个对象上，下面这种手段就能得知：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = Pizza(<span class="number">42</span>).get_size</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.__self__</span><br><span class="line">&lt;__main__.Pizza object at <span class="number">0x7f3138827910</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># You could guess, look at this:</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m == m.__self__.get_size</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>显然，该对象仍然有一个引用存在，只要你愿意你还是可以把它找回来。</p>
<p>在Python3中，依附在类上的函数不再当作是<strong>未绑定</strong>的方法，而是把它当作一个简单地函数，如果有必要它会绑定到一个对象身上去，原则依然和Python2保持一致，但是模块更简洁：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, size)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.size = size</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">get_size</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> self.size</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Pizza.get_size</span><br><span class="line">&lt;function Pizza.get_size at <span class="number">0x7f307f984dd0</span>&gt;</span><br></pre></td></tr></table></figure>

<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>静态方法是一类特殊的方法，有时你可能需要写一个属于这个类的方法，但是这些代码完全不会使用到实例对象本身，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mix_ingredients</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cook</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.mix_ingredients(self.cheese, self.vegetables)</span><br></pre></td></tr></table></figure>

<p><em>这个例子中，如果把_mix_ingredients<em>作为非静态方法同样可以运行，但是它要提供</em>self*参数，而这个参数在方法中根本不会被使用到。这里的</em>@staticmethod*装饰器可以给我们带来一些好处：</p>
<ul>
<li>Python不再需要为<em>Pizza</em>对象实例初始化一个绑定方法，绑定方法同样是对象，但是创建他们需要成本，而静态方法就可以避免这些。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Pizza().cook <span class="keyword">is</span> Pizza().cook</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Pizza().mix_ingredients <span class="keyword">is</span> Pizza.mix_ingredients</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Pizza().mix_ingredients <span class="keyword">is</span> Pizza().mix_ingredients</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可读性更好的代码，看到<em>@staticmethod</em>我们就知道这个方法并不需要依赖对象本身的状态。</li>
<li>可以在子类中被覆盖，如果是把<em>mix_ingredients</em>作为模块的顶层函数，那么继承自<em>Pizza</em>的子类就没法改变pizza的<em>mix_ingredients</em>了如果不覆盖<em>cook</em>的话。</li>
</ul>
<h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><p>话虽如此，什么是类方法呢？类方法不是绑定到对象上，而是绑定在类上的方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    radius = <span class="number">42</span></span><br><span class="line"><span class="meta">... </span>    @classmethod</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">get_radius</span><span class="params">(cls)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> cls.radius</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Pizza.get_radius</span><br><span class="line">&lt;bound method type.get_radius of &lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Pizza</span>'&gt;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">Pizza</span><span class="params">()</span>.<span class="title">get_radius</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">bound</span> <span class="title">method</span> <span class="title">type</span>.<span class="title">get_radius</span> <span class="title">of</span> &lt;<span class="title">class</span> '<span class="title">__main__</span>.<span class="title">Pizza</span>'&gt;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">Pizza</span>.<span class="title">get_radius</span> <span class="title">is</span> <span class="title">Pizza</span><span class="params">()</span>.<span class="title">get_radius</span></span></span><br><span class="line"><span class="class"><span class="title">True</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">Pizza</span>.<span class="title">get_radius</span><span class="params">()</span></span></span><br><span class="line"><span class="class">42</span></span><br></pre></td></tr></table></figure>

<p>无论你用哪种方式访问这个方法，它总是绑定到了这个类身上，它的第一个参数是这个类本身（记住：类也是对象）。</p>
<p>什么时候使用这种方法呢？类方法通常在以下两种场景是非常有用的：</p>
<ul>
<li>工厂方法：它用于创建类的实例，例如一些预处理。如果使用<em>@staticmethod</em>代替，那我们不得不硬编码<em>Pizza</em>类名在函数中，这使得任何继承<em>Pizza</em>的类都不能使用我们这个工厂方法给它自己用。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ingredients)</span>:</span></span><br><span class="line">        self.ingredients = ingredients</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_fridge</span><span class="params">(cls, fridge)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls(fridge.get_cheese() + fridge.get_vegetables())</span><br></pre></td></tr></table></figure>

<ul>
<li>调用静态类：如果你把一个静态方法拆分成多个静态方法，除非你使用类方法，否则你还是得硬编码类名。使用这种方式声明方法，<em>Pizza</em>类名明永远都不会在被直接引用，继承和方法覆盖都可以完美的工作。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, radius, height)</span>:</span></span><br><span class="line">        self.radius = radius</span><br><span class="line">        self.height = height</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_area</span><span class="params">(radius)</span>:</span></span><br><span class="line">         <span class="keyword">return</span> math.pi * (radius ** <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_volume</span><span class="params">(cls, height, radius)</span>:</span></span><br><span class="line">         <span class="keyword">return</span> height * cls.compute_area(radius)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_volume</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.compute_volume(self.height, self.radius)</span><br></pre></td></tr></table></figure>

<h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><p>抽象方法是定义在基类中的一种方法，它没有提供任何实现，类似于Java中接口(Interface)里面的方法。</p>
<p>在Python中实现抽象方法最简单地方式是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_radius</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br></pre></td></tr></table></figure>

<p><em>任何继承自_Pizza</em>的类必须覆盖实现方法<em>get_radius</em>，否则会抛出异常。</p>
<p>这种抽象方法的实现有它的弊端，如果你写一个类继承<em>Pizza</em>，但是忘记实现<em>get_radius</em>，异常只有在你真正使用的时候才会抛出来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Pizza()</span><br><span class="line">&lt;__main__.Pizza object at <span class="number">0x7fb747353d90</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Pizza().get_radius()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">3</span>, <span class="keyword">in</span> get_radius</span><br><span class="line">NotImplementedError</span><br></pre></td></tr></table></figure>

<p>还有一种方式可以让错误更早的触发，使用Python提供的<strong>abc</strong>模块，对象被初始化之后就可以抛出异常：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasePizza</span><span class="params">(object)</span>:</span></span><br><span class="line">    __metaclass__  = abc.ABCMeta</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_radius</span><span class="params">(self)</span>:</span></span><br><span class="line">         <span class="string">"""Method that should do something."""</span></span><br></pre></td></tr></table></figure>

<p>使用<em>abc</em>后，当你尝试初始化<em>BasePizza</em>或者任何子类的时候立马就会得到一个<em>TypeError</em>，而无需等到真正调用<em>get_radius</em>的时候才发现异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>BasePizza()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: Can<span class="string">'t instantiate abstract class BasePizza with abstract methods get_radius</span></span><br></pre></td></tr></table></figure>

<h4 id="混合静态方法、类方法、抽象方法"><a href="#混合静态方法、类方法、抽象方法" class="headerlink" title="混合静态方法、类方法、抽象方法"></a>混合静态方法、类方法、抽象方法</h4><p>当你开始构建类和继承结构时，混合使用这些装饰器的时候到了，所以这里列出了一些技巧。</p>
<p>记住，声明一个抽象的方法，不会固定方法的原型，这就意味着虽然你必须实现它，但是我可以用任何参数列表来实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasePizza</span><span class="params">(object)</span>:</span></span><br><span class="line">    __metaclass__  = abc.ABCMeta</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_ingredients</span><span class="params">(self)</span>:</span></span><br><span class="line">         <span class="string">"""Returns the ingredient list."""</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calzone</span><span class="params">(BasePizza)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_ingredients</span><span class="params">(self, with_egg=False)</span>:</span></span><br><span class="line">        egg = Egg() <span class="keyword">if</span> with_egg <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.ingredients + egg</span><br></pre></td></tr></table></figure>

<p>这样是允许的，因为<em>Calzone</em>满足<em>BasePizza</em>对象所定义的接口需求。同样我们也可以用一个类方法或静态方法来实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasePizza</span><span class="params">(object)</span>:</span></span><br><span class="line">    __metaclass__  = abc.ABCMeta</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_ingredients</span><span class="params">(self)</span>:</span></span><br><span class="line">         <span class="string">"""Returns the ingredient list."""</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DietPizza</span><span class="params">(BasePizza)</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_ingredients</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>这同样是正确的,因为它遵循抽象类<em>BasePizza</em>设定的契约。事实上<em>get_ingredients</em>方法并不需要知道返回结果是什么，结果是实现细节，不是契约条件。</p>
<p>因此，你不能强制抽象方法的实现是一个常规方法、或者是类方法还是静态方法，也没什么可争论的。从Python3开始（在Python2中不能如你期待的运行，见<a href="http://bugs.python.org/issue5867" target="_blank" rel="noopener">issue5867</a>），在<em>abstractmethod*方法上面使用</em>@staticmethod<em>和</em>@classmethod*装饰器成为可能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasePizza</span><span class="params">(object)</span>:</span></span><br><span class="line">    __metaclass__  = abc.ABCMeta</span><br><span class="line"> </span><br><span class="line">    ingredient = [<span class="string">'cheese'</span>]</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_ingredients</span><span class="params">(cls)</span>:</span></span><br><span class="line">         <span class="string">"""Returns the ingredient list."""</span></span><br><span class="line">         <span class="keyword">return</span> cls.ingredients</span><br></pre></td></tr></table></figure>

<p>别误会了，如果你认为它会强制子类作为一个类方法来实现<em>get_ingredients</em>那你就错了，它仅仅表示你实现的<em>get_ingredients</em>在<em>BasePizza</em>中是一个类方法。</p>
<p>可以在抽象方法中做代码的实现？没错，Python与Java接口中的方法相反，你可以在抽象方法编写实现代码通过<em>super()</em>来调用它。（译注：在Java8中，接口也提供的默认方法，允许在接口中写方法的实现）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasePizza</span><span class="params">(object)</span>:</span></span><br><span class="line">    __metaclass__  = abc.ABCMeta</span><br><span class="line"> </span><br><span class="line">    default_ingredients = [<span class="string">'cheese'</span>]</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_ingredients</span><span class="params">(cls)</span>:</span></span><br><span class="line">         <span class="string">"""Returns the ingredient list."""</span></span><br><span class="line">         <span class="keyword">return</span> cls.default_ingredients</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DietPizza</span><span class="params">(BasePizza)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_ingredients</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'egg'</span>] + super(DietPizza, self).get_ingredients()</span><br></pre></td></tr></table></figure>

<p>这个例子中，你构建的每个pizza都通过继承<em>BasePizza</em>的方式，你不得不覆盖<em>get_ingredients</em>方法，但是能够使用默认机制通过<em>super()</em>来获取<em>ingredient</em>列表。</p>
<p>感谢原文作者:</p>
<p><a href="http://www.jobbole.com/members/liuzhijun" target="_blank" rel="noopener">刘志军</a></p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/hello-world/</url>
    <content><![CDATA[<p>全新启航 敬请期待</p>
]]></content>
  </entry>
  <entry>
    <title>Python 多进程与多线程</title>
    <url>/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>今天电话面试被问到Python中多线程和多进程之间的关系和区别,说来丢人距上次使用Python时间久远,有些概念已经模糊了,检索查阅资料之后在此记录一下.</p>
<h3 id="1-线程和进程的基本概念"><a href="#1-线程和进程的基本概念" class="headerlink" title="1 线程和进程的基本概念"></a>1 线程和进程的基本概念</h3><p>现在的 PC 都是多核的，使用多线程能充分利用 CPU 来提供程序的执行效率。</p>
<h4 id="1-1-线程"><a href="#1-1-线程" class="headerlink" title="1.1 线程"></a>1.1 线程</h4><p>线程是一个基本的 CPU 执行单元。它必须依托于进程存活。一个线程是一个<strong>execution context（执行上下文）</strong>，即一个 CPU 执行时所需要的一串指令。</p>
<h4 id="1-2-进程"><a href="#1-2-进程" class="headerlink" title="1.2 进程"></a>1.2 进程</h4><p>进程是指一个程序在给定数据集合上的一次执行过程，是系统进行资源分配和运行调用的独立单位。可以简单地理解为操作系统中正在执行的程序。也就说，每个应用程序都有一个自己的进程。</p>
<p>每一个进程启动时都会最先产生一个线程，即主线程。然后主线程会再创建其他的子线程。</p>
<h4 id="1-3-两者的区别"><a href="#1-3-两者的区别" class="headerlink" title="1.3 两者的区别"></a>1.3 两者的区别</h4><ul>
<li>线程必须在某个进程中执行。</li>
<li>一个进程可包含多个线程，其中有且只有一个主线程。</li>
<li>多线程共享同个地址空间、打开的文件以及其他资源。</li>
<li>多进程共享物理内存、磁盘、打印机以及其他资源。</li>
</ul>
<h4 id="1-4-线程的类型"><a href="#1-4-线程的类型" class="headerlink" title="1.4 线程的类型"></a>1.4 线程的类型</h4><p>线程的因作用可以划分为不同的类型。大致可分为：</p>
<ul>
<li>主线程</li>
<li>子线程</li>
<li>守护线程（后台线程）</li>
<li>前台线程</li>
</ul>
<h3 id="2-Python-多线程"><a href="#2-Python-多线程" class="headerlink" title="2 Python 多线程"></a>2 Python 多线程</h3><h4 id="2-1-GIL"><a href="#2-1-GIL" class="headerlink" title="2.1 GIL"></a>2.1 GIL</h4><p>其他语言，CPU 是多核时是支持多个线程同时执行。但在 Python 中，无论是单核还是多核，同时只能由一个线程在执行。其根源是 GIL 的存在。</p>
<p>GIL 的全称是 Global Interpreter Lock(全局解释器锁)，来源是 Python 设计之初的考虑，为了数据安全所做的决定。某个线程想要执行，必须先拿到 GIL，我们可以把 GIL 看作是“通行证”，并且在一个 Python 进程中，GIL 只有一个。拿不到通行证的线程，就不允许进入 CPU 执行。</p>
<p>而目前 Python 的解释器有多种，例如：</p>
<ul>
<li><strong>CPython</strong>：CPython 是用C语言实现的 Python 解释器。 作为官方实现，它是最广泛使用的 Python 解释器。</li>
<li><strong>PyPy</strong>：PyPy 是用RPython实现的解释器。RPython 是 Python 的子集， 具有静态类型。这个解释器的特点是即时编译，支持多重后端（C, CLI, JVM）。PyPy 旨在提高性能，同时保持最大兼容性（参考 CPython 的实现）。</li>
<li><strong>Jython</strong>：Jython 是一个将 Python 代码编译成 Java 字节码的实现，运行在JVM (Java Virtual Machine) 上。另外，它可以像是用 Python 模块一样，导入 并使用任何Java类。</li>
<li><strong>IronPython</strong>：IronPython 是一个针对 .NET 框架的 Python 实现。它 可以用 Python 和 .NET framewor k的库，也能将 Python 代码暴露给 .NET 框架中的其他语言。</li>
</ul>
<p>GIL 只在 CPython 中才有，而在 PyPy 和 Jython 中是没有 GIL 的。</p>
<p>每次释放 GIL锁，线程进行锁竞争、切换线程，会消耗资源。这就导致打印线程执行时长，会发现耗时更长的原因。</p>
<p>并且由于 GIL 锁存在，Python 里一个进程永远只能同时执行一个线程(拿到 GIL 的线程才能执行)，这就是为什么在多核CPU上，Python 的多线程效率并不高的根本原因。</p>
<h4 id="2-2-创建多线程"><a href="#2-2-创建多线程" class="headerlink" title="2.2 创建多线程"></a>2.2 创建多线程</h4><p>Python提供两个模块进行多线程的操作，分别是<code>thread</code>和<code>threading</code>，<br> 前者是比较低级的模块，用于更底层的操作，一般应用级别的开发不常用。</p>
<ul>
<li>方法1：直接使用<code>threading.Thread()</code> </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个函数名可随便定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">"current task："</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    t1 = threading.Thread(target=run, args=(<span class="string">"thread 1"</span>,))</span><br><span class="line">    t2 = threading.Thread(target=run, args=(<span class="string">"thread 2"</span>,))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure>

<ul>
<li>方法2：继承<code>threading.Thread</code>来自定义线程类，重写<code>run</code>方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        super(MyThread, self).__init__()  <span class="comment"># 重构run函数必须要写</span></span><br><span class="line">        self.n = n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"current task："</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    t1 = MyThread(<span class="string">"thread 1"</span>)</span><br><span class="line">    t2 = MyThread(<span class="string">"thread 2"</span>)</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure>

<h4 id="2-3-线程合并"><a href="#2-3-线程合并" class="headerlink" title="2.3 线程合并"></a>2.3 线程合并</h4><p><code>Join</code>函数执行顺序是逐个执行每个线程，执行完毕后继续往下执行。主线程结束后，子线程还在运行，<code>join</code>函数使得主线程等到子线程结束时才退出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    t1 = threading.Thread(target=count, args=(<span class="string">"100000"</span>,))</span><br><span class="line">    t2 = threading.Thread(target=count, args=(<span class="string">"100000"</span>,))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    <span class="comment"># 将 t1 和 t2 加入到主线程中</span></span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br></pre></td></tr></table></figure>

<h4 id="2-4-线程同步与互斥锁"><a href="#2-4-线程同步与互斥锁" class="headerlink" title="2.4 线程同步与互斥锁"></a>2.4 线程同步与互斥锁</h4><p>线程之间数据共享的。当多个线程对某一个共享数据进行操作时，就需要考虑到线程安全问题。<code>threading</code>模块中定义了Lock 类，提供了互斥锁的功能来保证多线程情况下数据的正确性。</p>
<p>用法的基本步骤：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建锁</span></span><br><span class="line">mutex = threading.Lock()</span><br><span class="line"><span class="comment">#锁定</span></span><br><span class="line">mutex.acquire([timeout])</span><br><span class="line"><span class="comment">#释放</span></span><br><span class="line">mutex.release()</span><br></pre></td></tr></table></figure>

<p>其中，锁定方法acquire可以有一个超时时间的可选参数timeout。如果设定了timeout，则在超时后通过返回值可以判断是否得到了锁，从而可以进行一些其他的处理。</p>
<p>具体用法见示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line">mutex = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> num </span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> mutex.acquire(<span class="number">1</span>):  </span><br><span class="line">            num = num + <span class="number">1</span></span><br><span class="line">            msg = self.name + <span class="string">': num value is '</span> + str(num)</span><br><span class="line">            print(msg)</span><br><span class="line">            mutex.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        t = MyThread()</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure>

<h4 id="2-5-可重入锁（递归锁）"><a href="#2-5-可重入锁（递归锁）" class="headerlink" title="2.5 可重入锁（递归锁）"></a>2.5 可重入锁（递归锁）</h4><p>为了满足在同一线程中多次请求同一资源的需求，Python 提供了可重入锁（RLock）。<br> <code>RLock</code>内部维护着一个<code>Lock</code>和一个<code>counter</code>变量，counter 记录了 acquire 的次数，从而使得资源可以被多次 require。直到一个线程所有的 acquire 都被 release，其他的线程才能获得资源。</p>
<p>具体用法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建 RLock</span></span><br><span class="line">mutex = threading.RLock()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> mutex.acquire(<span class="number">1</span>):</span><br><span class="line">            print(<span class="string">"thread "</span> + self.name + <span class="string">" get mutex"</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            mutex.acquire()</span><br><span class="line">            mutex.release()</span><br><span class="line">            mutex.release()</span><br></pre></td></tr></table></figure>

<h4 id="2-6-守护线程"><a href="#2-6-守护线程" class="headerlink" title="2.6 守护线程"></a>2.6 守护线程</h4><p>如果希望主线程执行完毕之后，不管子线程是否执行完毕都随着主线程一起结束。我们可以使用<code>setDaemon(bool)</code>函数，它跟<code>join</code>函数是相反的。它的作用是设置子线程是否随主线程一起结束，必须在<code>start()</code> 之前调用，默认为<code>False</code>。</p>
<h4 id="2-7-定时器"><a href="#2-7-定时器" class="headerlink" title="2.7 定时器"></a>2.7 定时器</h4><p>如果需要规定函数在多少秒后执行某个操作，需要用到<code>Timer</code>类。具体用法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Timer</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Pyhton"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定一秒钟之后执行 show 函数</span></span><br><span class="line">t = Timer(<span class="number">1</span>, hello)</span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure>

<h3 id="3-Python-多进程"><a href="#3-Python-多进程" class="headerlink" title="3 Python 多进程"></a>3 Python 多进程</h3><h4 id="3-1-创建多进程"><a href="#3-1-创建多进程" class="headerlink" title="3.1 创建多进程"></a>3.1 创建多进程</h4><p>Python 要进行多进程操作，需要用到<code>muiltprocessing</code>库，其中的<code>Process</code>类跟<code>threading</code>模块的<code>Thread</code>类很相似。所以直接看代码熟悉多进程。</p>
<ul>
<li>方法1：直接使用<code>Process</code>, 代码如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"Process name is "</span> + name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>: </span><br><span class="line">    proc = Process(target=show, args=(<span class="string">'subprocess'</span>,))  </span><br><span class="line">    proc.start()  </span><br><span class="line">    proc.join()</span><br></pre></td></tr></table></figure>

<ul>
<li>方法2：继承<code>Process</code>来自定义进程类，重写<code>run</code>方法, 代码如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span><span class="params">(Process)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        super(MyProcess, self).__init__()</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'process name :'</span> + str(self.name))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        p = MyProcess(i)</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        p.join()</span><br></pre></td></tr></table></figure>

<h4 id="3-2-多进程通信"><a href="#3-2-多进程通信" class="headerlink" title="3.2 多进程通信"></a>3.2 多进程通信</h4><p>进程之间不共享数据的。如果进程之间需要进行通信，则要用到<code>Queue模块</code>或者<code>Pipi模块</code>来实现。</p>
<ul>
<li><strong>Queue</strong></li>
</ul>
<p>Queue 是多进程安全的队列，可以实现多进程之间的数据传递。它主要有两个函数,<code>put</code>和<code>get</code>。</p>
<p>put() 用以插入数据到队列中，put 还有两个可选参数：blocked 和 timeout。如果 blocked 为 True（默认值），并且 timeout 为正值，该方法会阻塞 timeout 指定的时间，直到该队列有剩余的空间。如果超时，会抛出 Queue.Full 异常。如果 blocked 为 False，但该 Queue 已满，会立即抛出 Queue.Full 异常。</p>
<p>get()可以从队列读取并且删除一个元素。同样，get 有两个可选参数：blocked 和 timeout。如果 blocked 为 True（默认值），并且 timeout 为正值，那么在等待时间内没有取到任何元素，会抛出 Queue.Empty 异常。如果blocked 为 False，有两种情况存在，如果 Queue 有一个值可用，则立即返回该值，否则，如果队列为空，则立即抛出 Queue.Empty 异常。</p>
<p>具体用法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(queue)</span>:</span></span><br><span class="line">    queue.put(<span class="string">'Queue 用法'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    queue = Queue()</span><br><span class="line">    pro = Process(target=put, args=(queue,))</span><br><span class="line">    pro.start()</span><br><span class="line">    print(queue.get())   </span><br><span class="line">    pro.join()</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Pipe</strong></li>
</ul>
<p>Pipe的本质是进程之间的用管道数据传递，而不是数据共享，这和socket有点像。pipe() 返回两个连接对象分别表示管道的两端，每端都有send() 和recv()函数。</p>
<p>如果两个进程试图在同一时间的同一端进行读取和写入那么，这可能会损坏管道中的数据。</p>
<p>具体用法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Pipe</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(conn)</span>:</span></span><br><span class="line">    conn.send(<span class="string">'Pipe 用法'</span>)</span><br><span class="line">    conn.close()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    parent_conn, child_conn = Pipe() </span><br><span class="line">    pro = Process(target=show, args=(child_conn,))</span><br><span class="line">    pro.start()</span><br><span class="line">    print(parent_conn.recv())   </span><br><span class="line">    pro.join()</span><br></pre></td></tr></table></figure>

<h4 id="3-3-进程池"><a href="#3-3-进程池" class="headerlink" title="3.3 进程池"></a>3.3 进程池</h4><p>创建多个进程，我们不用傻傻地一个个去创建。我们可以使用<code>Pool</code>模块来搞定。</p>
<p>Pool 常用的方法如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>apply()</td>
<td>同步执行（串行）</td>
</tr>
<tr>
<td>apply_async()</td>
<td>异步执行（并行）</td>
</tr>
<tr>
<td>terminate()</td>
<td>立刻关闭进程池</td>
</tr>
<tr>
<td>join()</td>
<td>主进程等待所有子进程执行完毕。必须在close或terminate()之后使用</td>
</tr>
<tr>
<td>close()</td>
<td>等待所有进程结束后，才关闭进程池</td>
</tr>
</tbody></table>
<p>具体用法见示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(num)</span>:</span></span><br><span class="line">    print(<span class="string">'num : '</span> + str(num))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    pool = Pool(processes = <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">6</span>):</span><br><span class="line">        <span class="comment"># 维持执行的进程总数为processes，当一个进程执行完毕后会添加新的进程进去</span></span><br><span class="line">        pool.apply_async(show, args=(i, ))       </span><br><span class="line">    print(<span class="string">'======  apply_async  ======'</span>)</span><br><span class="line">    pool.close()</span><br><span class="line">    <span class="comment">#调用join之前，先调用close函数，否则会出错。执行完close后不会有新的进程加入到pool,join函数等待所有子进程结束</span></span><br><span class="line">    pool.join()</span><br></pre></td></tr></table></figure>

<h3 id="4-选择多线程还是多进程？"><a href="#4-选择多线程还是多进程？" class="headerlink" title="4 选择多线程还是多进程？"></a>4 选择多线程还是多进程？</h3><p>在这个问题上，首先要看下你的程序是属于哪种类型的。一般分为两种 CPU 密集型 和 I/O 密集型。</p>
<ul>
<li>CPU 密集型：程序比较偏重于计算，需要经常使用 CPU 来运算。例如科学计算的程序，机器学习的程序等。</li>
<li>I/O 密集型：顾名思义就是程序需要频繁进行输入输出操作。爬虫程序就是典型的 I/O 密集型程序。</li>
</ul>
<p>如果程序是属于 CPU 密集型，建议使用多进程。而多线程就更适合应用于 I/O 密集型程序。</p>
<p>感谢原文作者:</p>
<p><a href="https://www.jianshu.com/u/f46becd1ed83" target="_blank" rel="noopener">猴哥Yuri</a></p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell脚本的调试方法</title>
    <url>/Shell%E8%84%9A%E6%9C%AC%E7%9A%84%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="Shell脚本的调试方法"><a href="#Shell脚本的调试方法" class="headerlink" title="Shell脚本的调试方法"></a>Shell脚本的调试方法</h3><p>Shell提供了一些用于调试脚本的选项，如下所示：</p>
<ul>
<li><p>-n</p>
<p>读一遍脚本中的命令但不执行，用于检查脚本中的语法错误</p>
</li>
<li><p>-v</p>
<p>一边执行脚本，一边将执行过的脚本命令打印到标准错误输出</p>
</li>
<li><p>-x</p>
<p>提供跟踪执行信息，将执行的每一条命令和结果依次打印出来</p>
</li>
</ul>
<p>使用这些选项有三种方法，一是在命令行提供参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sh -x ./script.sh</span></span><br></pre></td></tr></table></figure>

<p>二是在脚本开头提供参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/sh -x</span></span><br></pre></td></tr></table></figure>

<p>第三种方法是在脚本中用set命令启用或禁用参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/sh</span></span><br><span class="line">if [ -z "$1" ]; then</span><br><span class="line">  set -x</span><br><span class="line">  echo "ERROR: Insufficient Args."</span><br><span class="line">  exit 1</span><br><span class="line">  set +x</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p><code>set -x</code>和<code>set +x</code>分别表示启用和禁用<code>-x</code>参数，这样可以只对脚本中的某一段进行跟踪调试。</p>
<h3 id="跟踪脚本的执行"><a href="#跟踪脚本的执行" class="headerlink" title="跟踪脚本的执行"></a>跟踪脚本的执行</h3><p>你可以让bash打印出你脚本执行的过程中的所有语句。这很简单，只需要使用bash的-x选项就可以做到，下面让我们来看一下。</p>
<p>下面的这段脚本，先是输出一个问候语句，然后输出当前的时间：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "Hello $USER," </span><br><span class="line">echo "Today is $(date +'%Y-%m-%d')"</span><br></pre></td></tr></table></figure>

<p>下面让我们使用-x选项来运行这段脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bash -x example_script.sh  </span></span><br><span class="line">+ echo 'Hello chenhao,'  </span><br><span class="line">Hello chenhao,  </span><br><span class="line">++ date   +%Y-%m-%d  </span><br><span class="line">+ echo 'Today is 2009-08-31'</span><br><span class="line">Today is 2009-08-31</span><br></pre></td></tr></table></figure>

<p>这时，我们可以看到，bash在运行前打印出了每一行命令。而且每行前面的+号表明了嵌套。这样的输出可以让你看到命令执行的顺序并可以让你知道整个脚本的行为。<br><strong>在跟踪里输出行号</strong></p>
<p>在一个很大的脚本中，你会看到很多很多的执行跟踪的输出，阅读起来非常费劲，所以，你可以在每一行前加上文件的行号，这会非常有用。要做到这样，你只需要设置下面的环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PS4='+$&#123;BASH_SOURCE&#125;:$&#123;LINENO&#125;:$&#123;FUNCNAME[0]&#125;: '</span><br></pre></td></tr></table></figure>

<p>让我们看看设置上了PS4这个环境变量后会是什么样的输出。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bash -x example_script.sh</span></span><br><span class="line">+example_script.sh:2:: echo 'Hello chenhao,'</span><br><span class="line">Hello chenhao,</span><br><span class="line">++example_script.sh:3:: date +%Y-%m-%d</span><br><span class="line">+example_script.sh:3:: echo 'Today is 2009-08-31'</span><br><span class="line">Today is 2009-08-31</span><br></pre></td></tr></table></figure>


<p><strong>调试部份的脚本</strong></p>
<p>有些时候，你并不想调试整个脚本，你只要调试其中的一部份，那么，你可以在你想要调试的脚本之前，调用“set -x”，结束的时候调用“set +x”就可以了。如下面的脚本所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "Hello $USER,"</span><br><span class="line">set -x</span><br><span class="line">echo "Today is $(date %Y-%m-%d)"</span><br><span class="line">set +x</span><br></pre></td></tr></table></figure>

<p> 让我们看看运行起来是啥样？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./example_script.sh</span></span><br><span class="line">Hello chenhao,</span><br><span class="line">++example_script.sh:4:: date +%Y-%m-%d</span><br><span class="line">+example_script.sh:4:: echo 'Today is 2009-08-31'</span><br><span class="line">Today is 2009-08-31</span><br><span class="line">+example_script.sh:5:: set +x</span><br></pre></td></tr></table></figure>

<p> 注意：我们在运行脚本的时候，不需要使用bash -x了。</p>
<h3 id="日志输出"><a href="#日志输出" class="headerlink" title="日志输出"></a>日志输出</h3><p>跟踪日志有时候太多了，多得都受不了，而且，输出的内容很难阅读。一般来说，我们很多时候只关心于条件表达式，变量值，或是函数调用，或是循环等。。在这种情况下，log一些感兴趣的特定的信息，可能会更好。</p>
<p>使用log前，我们先写一个函数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">_log() &#123;</span><br><span class="line">	if [ "$_DEBUG" == "true" ]; then        </span><br><span class="line">		echo 1&gt;&amp;2 "$@"</span><br><span class="line">	fi&#125;</span><br></pre></td></tr></table></figure>

<p> 于是，你就可以在你的脚本中如下使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">_log "Copying files..."</span><br><span class="line">cp src/* dst/</span><br></pre></td></tr></table></figure>

<p> 我们可以看到，上面那个_log函数，需要检查一个_DEBUG 变量，只有这个变量是真，才会真正开发输出日志。这样，你就只需要控制这个开关，而不需要删除你的debug信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> _DEBUG=<span class="literal">true</span> ./example_script.sh</span></span><br></pre></td></tr></table></figure>



<p>参考原文作者:</p>
<h5 id="陈皓"><a href="#陈皓" class="headerlink" title="陈皓"></a><a href="https://coolshell.cn/articles/author/haoel" target="_blank" rel="noopener">陈皓</a></h5>]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>new_test</title>
    <url>/new-test/</url>
    <content><![CDATA[<p>这是mark的测试内容</p>
]]></content>
  </entry>
  <entry>
    <title>SELinux 简介</title>
    <url>/SELinux-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h3 id="SELinux介绍"><a href="#SELinux介绍" class="headerlink" title="SELinux介绍"></a>SELinux介绍</h3><p>SELinux: Secure Enhanced Linux, 是美国国家安全局(NSA=The National Security Agency)和SCC(Secure Computing Corporation)开发的 Linux的一个强制访问控制的安全模块.2000年以GNU GPL发布,Linux内核2.6版本后集成在内核中<br>DAC:Discretionary Access Control自由访问控制<br>MAC:Mandatory Access Control 强制访问控制<br>• DAC环境下进程是无束缚的<br>• MAC环境下策略的规则决定控制的严格程度<br>• MAC环境下进程可以被限制的<br>• 策略被用来定义被限制的进程能够使用那些资源(文件和端口)<br>• 默认情况下,没有被明确允许的行为将被拒绝</p>
<h3 id="SELinux工作类型"><a href="#SELinux工作类型" class="headerlink" title="SELinux工作类型"></a>SELinux工作类型</h3><p>SELinux有四种工作类型:<br>    strict: centos5,每个进程都受到selinux的控制<br>    targeted: 用来保护常见的网络服务,仅有限进程受到selinux控制,只监控容易被入侵的进程,centos4只保护13个服务,centos5保护88个服务<br>    minimum:centos7,修改的targeted,只对选择的网络服务<br>    mls:提供MLS(多级安全)机制的安全性<br>targeted为默认类型,minimum和mls稳定性不足,未加以应用,strict已不再使用</p>
<h3 id="SELinux安全上下文"><a href="#SELinux安全上下文" class="headerlink" title="SELinux安全上下文"></a>SELinux安全上下文</h3><p>传统Linux,一切皆文件,由用户,组,权限控制访问<br>在SELinux中,一切皆对象(object),由存放在inode的扩展属性域的安全元素所控制其访问<br>所有文件和端口资源和进程都具备安全标签:安全上下文(security context)<br>安全上下文有五个元素组成:<br>    user:role:type:sensitivity:category<br>    user_u:object_r:tmp_t:s0:c0<br> 实际上下文:存放在文件系统中,ls –Z;ps –Z<br>期望(默认)上下文:存放在二进制的SELinux策略库(映射目录和期望安全上下<br>文)中<br>    semanage fcontext –l</p>
<h3 id="五个安全元素"><a href="#五个安全元素" class="headerlink" title="五个安全元素"></a>五个安全元素</h3><p>User:指示登录系统的用户类型,进程:如system_u为系统服务进程,是受到管制的,unconfined_u为不管制的进程,用户自己开启的,如 bash,文件:system_u系统进程创建的文件, unconfined_u为用户自已创建的文件<br>Role:定义文件,进程和用户的用途:进程:system_r为系统服务进程,受到管制.unconfined_r 为不管制进程,通常都是用户自己开启的,如 bash,文件:object_r<br>Type:指定数据类型,规则中定义何种进程类型访问何种文件Target策略基于type实现,多服务共用:public_content_t<br>Sensitivity:限制访问的需要,由组织定义的分层安全级别,如<br>unclassified,secret,top,secret, 一个对象有且只有一个sensitivity,分0-15级,s0最低,Target策略默认使用s0<br>Category:对于特定组织划分不分层的分类,如FBI Secret,NSA secret, 一个对象可以有多个categroy, c0-c1023共1024个分类, Target 策略不使用category</p>
<h3 id="SELinux策略"><a href="#SELinux策略" class="headerlink" title="SELinux策略"></a>SELinux策略</h3><p>对象(object):所有可以读取的对象,包括文件、目录和进程,端口等<br>主体:进程称为主体(subject)<br>SELinux中对所有的文件都赋予一个type的文件类型标签,对于所有的进程也赋予各自的一个domain的标签.domain标签能够执行的操作由安全策略里定义<br>当一个subject试图访问一个object,Kernel中的策略执行服务器将检查AVC (访问矢量缓存Access Vector Cache), 在AVC中,subject和object的权限被缓存(cached),查找“应用+文件”的安全环境.然后根据查询结果允许或拒绝访问<br>安全策略:定义主体读取对象的规则数据库,规则中记录了哪个类型的主体使用哪个方法读取哪一个对象是允许还是拒绝的,并且定义了哪种行为是充许或拒绝</p>
<h3 id="设置SELinux"><a href="#设置SELinux" class="headerlink" title="设置SELinux"></a>设置SELinux</h3><p>配置SELinux:<br>    SELinux是否启用<br>    给文件重新打安全标签<br>    给端口设置安全标签<br>    设定某些操作的布尔型开关<br>    SELinux的日志管理<br>SELinux的状态:<br>    enforcing: 强制,每个受限的进程都必然受限<br>    permissive: 允许,每个受限的进程违规操作不会被禁止,但会被记录于审<br>计日志<br>    disabled: 禁用</p>
<h3 id="配置SELinux"><a href="#配置SELinux" class="headerlink" title="配置SELinux"></a>配置SELinux</h3><p>相关命令:<br>    getenforce: 获取selinux当前状态<br>    sestatus :查看selinux状态<br>    setenforce 0|1<br>        0: 设置为permissive<br>        1: 设置为enforcing<br>配置文件:<br>    /boot/grub/grub.conf<br>        在kernel行使用selinux=0禁用SELinux<br>    /etc/selinux/config<br>    /etc/sysconfig/selinux<br>    SELINUX={disabled|enforcing|permissive}</p>
<h3 id="修改SELinux安全标签"><a href="#修改SELinux安全标签" class="headerlink" title="修改SELinux安全标签"></a>修改SELinux安全标签</h3><p>给文件重新打安全标签:<br>    chcon [OPTION]… [-u USER][-r ROLE] [-t TYPE] FILE…<br>    chcon [OPTION]… –reference=RFILE FILE…<br>    -R:递归打标<br>恢复目录或文件默认的安全上下文:<br>    restorecon [-R] /path/to/somewhere</p>
<h3 id="默认安全上下文查询与修改"><a href="#默认安全上下文查询与修改" class="headerlink" title="默认安全上下文查询与修改"></a>默认安全上下文查询与修改</h3><p>semanage:来自policycoreutils-python包<br>查看默认的安全上下文<br>    semanage fcontext –l<br>添加安全上下文<br>    semanage fcontext -a –t httpd_sys_content_t ‘/testdir(/.*)?’</p>
<pre><code>restorecon –Rv /testdir</code></pre><p>删除安全上下文<br>    semanage fcontext -d –t httpd_sys_content_t ‘/testdir(/.*)?’</p>
<h3 id="SElinux端口标签"><a href="#SElinux端口标签" class="headerlink" title="SElinux端口标签"></a>SElinux端口标签</h3><p>查看端口标签<br>    semanage port –l<br>添加端口<br>    semanage port -a -t port_label -p tcp|udp PORT<br>    semanage port -a -t http_port_t -p tcp 9527<br>删除端口<br>    semanage port -d -t port_label -p tcp|udp PORT<br>    semanage port -d -t http_port_t -p tcp 9527<br>修改现有端口为新标签<br>    semanage port -m -t port_label -p tcp|udp PORT<br>    semanage port -m -t http_port_t -p tcp 9527 </p>
<h3 id="SELinux布尔值"><a href="#SELinux布尔值" class="headerlink" title="SELinux布尔值"></a>SELinux布尔值</h3><p>布尔型规则:<br>    getsebool<br>    setsebool<br>查看bool命令:<br>    getsebool [-a][boolean]<br>    semanage boolean –l<br>    semanage boolean -l –C 查看修改过的布尔值<br>设置bool值命令:<br>    setsebool [-P] boolean value(on,off)<br>    setsebool [-P] Boolean=value(0,1)</p>
<h3 id="SELinux日志管理"><a href="#SELinux日志管理" class="headerlink" title="SELinux日志管理"></a>SELinux日志管理</h3><p>yum install setroubleshoot(重启生效)<br>将错误的信息写入/var/log/message<br>    grep setroubleshoot /var/log/messages<br>查看安全事件日志说明<br>    sealert -l UUID<br>扫描并分析日志<br>    sealert -a /var/log/audit/audit.log</p>
<h3 id="SELinux帮助"><a href="#SELinux帮助" class="headerlink" title="SELinux帮助"></a>SELinux帮助</h3><p>yum –y install selinux-policy-devel ( centos7.2)<br>yum –y install selinux-policy-doc<br>mandb | makewhatis<br>man -k _selinux</p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>shell 中特殊变量的用法</title>
    <url>/shell-%E4%B8%AD%E7%89%B9%E6%AE%8A%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>Shell 编程中的有很多特殊的变量可以打印出来很多有用的信息.在网上检索之后做个笔记.希望也可以帮助更多有需要的人</p>
<p><strong>$$</strong> </p>
<p>Shell本身的PID（ProcessID） </p>
<p><strong>$!</strong> </p>
<p>Shell最后运行的后台Process的PID </p>
<p><strong>$?</strong> </p>
<p>最后运行的命令的结束代码（返回值） </p>
<p><strong>$-</strong> </p>
<p>使用Set命令设定的Flag一览 <strong>$</strong></p>
<p><strong>S*</strong> </p>
<p>所有参数列表。如”$*”用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。 </p>
<p><strong>$@</strong> </p>
<p>所有参数列表。如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。 </p>
<p><strong>$#</strong></p>
<p> 添加到Shell的参数个数 </p>
<p><strong>$0</strong></p>
<p> Shell本身的文件名 $1～$n 添加到Shell的各参数值。$1是第1参数、$2是第2参数…。 </p>
<hr>
<p>我们先写一个简单的脚本，执行以后再解释各个变量的意义 </p>
<p><code># touch variable</code> </p>
<p><code># vi variable</code> </p>
<p>脚本内容如下： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh </span></span><br><span class="line"></span><br><span class="line">echo "number:$#" </span><br><span class="line"></span><br><span class="line">echo "scname:$0" </span><br><span class="line"></span><br><span class="line">echo "first :$1" </span><br><span class="line"></span><br><span class="line">echo "second:$2" </span><br><span class="line"></span><br><span class="line">echo "argume:$@"</span><br></pre></td></tr></table></figure>

<p>保存退出 赋予脚本执行权限 </p>
<p><code># chmod +x variable</code> </p>
<p>执行脚本 </p>
<p><code># ./variable aa bb</code> </p>
<p>执行结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">number:2 </span><br><span class="line">scname:./variable </span><br><span class="line">first: aa </span><br><span class="line">second:bb </span><br><span class="line">argume:aa bb</span><br></pre></td></tr></table></figure>

<p> 通过显示结果可以看到： </p>
<p>$# 是传给脚本的参数个数 </p>
<p>$0 是脚本本身的名字 </p>
<p>$1是传递给该shell脚本的第一个参数 </p>
<p>$2是传递给该shell脚本的第二个参数 </p>
<p>$@ 是传给脚本的所有参数的列表 </p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>使用shell脚本实现俄罗斯方块</title>
    <url>/%E4%BD%BF%E7%94%A8shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/</url>
    <content><![CDATA[<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>学习 shell 的最好方法就是去实践,网上有很多的源码可供参考</p>
<h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>源码分析:</p>
<p>先从游戏主程序开始分析:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [[ "$1" == "-h" || "$1" == "--help" ]]; then</span><br><span class="line">        Usage</span><br><span class="line">elif [[ "$1" == "--version" ]]; then</span><br><span class="line">        echo "$APP_NAME $APP_VERSION"</span><br><span class="line">elif [[ "$1" == "--show" ]]; then</span><br><span class="line">        #当发现具有参数--show时，运行显示函数</span><br><span class="line">        RunAsDisplayer</span><br><span class="line">else</span><br><span class="line">        bash $0 --show&amp;        #以参数--show将本程序再运行一遍</span><br><span class="line">        RunAsKeyReceiver $!        #以上一行产生的进程的进程号作为参数</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>里面出现了两个变量,查看定义后发现</p>
<p>APP_NAME : 打印了脚本名</p>
<p><code>APP_NAME=&quot;${0##*[\\/]}&quot;</code></p>
<p>APP_VERSION : 自己定义了版本号</p>
<p><code>APP_VERSION=&quot;1.0&quot;</code></p>
<p>其中出现了3个函数</p>
<p>Usage :显示脚本用法的函数</p>
<p>RunAsDisplayer :处理显示和游戏流程的主函数</p>
<p>RunAsKeyReceiver :接收输入的进程的主函数</p>
<p>我们从头开始分析这些函数的实现</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function Usage</span><br><span class="line">&#123;</span><br><span class="line">        cat &lt;&lt; EOF</span><br><span class="line">Usage: $APP_NAME</span><br><span class="line">Start tetris game.</span><br><span class="line">  </span><br><span class="line">  -h, --help              display this help and exit</span><br><span class="line">      --version           output version information and exit</span><br><span class="line">EOF</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 Usage 函数就是打印了一些信息,主要是用户提示.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function RunAsDisplayer()</span><br><span class="line">&#123;</span><br><span class="line">        local sigThis	#定义了局部变量 sigThis</span><br><span class="line">        InitDraw</span><br><span class="line">  </span><br><span class="line">        #挂载各种信号的处理函数</span><br><span class="line">        trap "sig=$sigRotate;" $sigRotate</span><br><span class="line">        trap "sig=$sigLeft;" $sigLeft</span><br><span class="line">        trap "sig=$sigRight;" $sigRight</span><br><span class="line">        trap "sig=$sigDown;" $sigDown</span><br><span class="line">        trap "sig=$sigAllDown;" $sigAllDown</span><br><span class="line">        trap "ShowExit;" $sigExit</span><br><span class="line">  </span><br><span class="line">        while :</span><br><span class="line">        do</span><br><span class="line">                #根据当前的速度级iLevel不同，设定相应的循环的次数</span><br><span class="line">                for ((i = 0; i &lt; 21 - iLevel; i++))</span><br><span class="line">                do</span><br><span class="line">                        sleep 0.02</span><br><span class="line">                        sigThis=$sig</span><br><span class="line">                        sig=0</span><br><span class="line">  </span><br><span class="line">                        #根据sig变量判断是否接受到相应的信号</span><br><span class="line">                        if ((sigThis == sigRotate)); then BoxRotate;        #旋转</span><br><span class="line">                        elif ((sigThis == sigLeft)); then BoxLeft;        #左移一列</span><br><span class="line">                        elif ((sigThis == sigRight)); then BoxRight;        #右移一列</span><br><span class="line">                        elif ((sigThis == sigDown)); then BoxDown;        #下落一行</span><br><span class="line">                        elif ((sigThis == sigAllDown)); then BoxAllDown;        #下落到底</span><br><span class="line">                        fi</span><br><span class="line">                done</span><br><span class="line">                #kill -$sigDown $$</span><br><span class="line">                BoxDown        #下落一行</span><br><span class="line">        done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>暂时先不管 RunAsDisplayer 中调用的 InitDraw 函数,先看一下这个函数的功能.</p>
<p>从流程上分析这个函数实现了按键信号的捕捉,然后在一个死循环中以操作时间为0.02秒,不断的执行对方块的移动操作,然后执行下落一行的操作.</p>
<p>接下来对其中出现的参数和函数进行分析:</p>
<p>trap 这个命令实现了shell中脚本信号的获取,可以在脚本运行中执行额外的操作,比如获取键盘的输入用来控制方块的运动轨迹.</p>
<p>iLevel 这个参数是定义的速度级,这个稍后会提到.</p>
<p>BoxDown : 控制方块下落的函数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function RunAsKeyReceiver()</span><br><span class="line">&#123;</span><br><span class="line">        local pidDisplayer key aKey sig cESC sTTY</span><br><span class="line">  </span><br><span class="line">        pidDisplayer=$1</span><br><span class="line">        aKey=(0 0 0)</span><br><span class="line">  </span><br><span class="line">        cESC=`echo -ne "\033"`</span><br><span class="line">        cSpace=`echo -ne "\040"`</span><br><span class="line">  </span><br><span class="line">        #保存终端属性。在read -s读取终端键时，终端的属性会被暂时改变。</span><br><span class="line">        #如果在read -s时程序被不幸杀掉，可能会导致终端混乱，</span><br><span class="line">        #需要在程序退出时恢复终端属性。</span><br><span class="line">        sTTY=`stty -g`</span><br><span class="line">  </span><br><span class="line">        #捕捉退出信号</span><br><span class="line">        trap "MyExit;" INT TERM</span><br><span class="line">        trap "MyExitNoSub;" $sigExit</span><br><span class="line">  </span><br><span class="line">        #隐藏光标</span><br><span class="line">        echo -ne "\033[?25l"</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        while :</span><br><span class="line">        do</span><br><span class="line">                #读取输入。注-s不回显，-n读到一个字符立即返回</span><br><span class="line">                read -s -n 1 key</span><br><span class="line">  </span><br><span class="line">                aKey[0]=$&#123;aKey[1]&#125;</span><br><span class="line">                aKey[1]=$&#123;aKey[2]&#125;</span><br><span class="line">                aKey[2]=$key</span><br><span class="line">                sig=0</span><br><span class="line">  </span><br><span class="line">                #判断输入了何种键</span><br><span class="line">                if [[ $key == $cESC &amp;&amp; $&#123;aKey[1]&#125; == $cESC ]]</span><br><span class="line">                then</span><br><span class="line">                        #ESC键</span><br><span class="line">                        MyExit</span><br><span class="line">                elif [[ $&#123;aKey[0]&#125; == $cESC &amp;&amp; $&#123;aKey[1]&#125; == "[" ]]</span><br><span class="line">                then</span><br><span class="line">                        if [[ $key == "A" ]]; then sig=$sigRotate        #&lt;向上键&gt;</span><br><span class="line">                        elif [[ $key == "B" ]]; then sig=$sigDown        #&lt;向下键&gt;</span><br><span class="line">                        elif [[ $key == "D" ]]; then sig=$sigLeft        #&lt;向左键&gt;</span><br><span class="line">                        elif [[ $key == "C" ]]; then sig=$sigRight        #&lt;向右键&gt;</span><br><span class="line">                        fi</span><br><span class="line">                elif [[ $key == "W" || $key == "w" ]]; then sig=$sigRotate        #W, w</span><br><span class="line">                elif [[ $key == "S" || $key == "s" ]]; then sig=$sigDown        #S, s</span><br><span class="line">                elif [[ $key == "A" || $key == "a" ]]; then sig=$sigLeft        #A, a</span><br><span class="line">                elif [[ $key == "D" || $key == "d" ]]; then sig=$sigRight        #D, d</span><br><span class="line">                elif [[ "[$key]" == "[]" ]]; then sig=$sigAllDown        #空格键</span><br><span class="line">                elif [[ $key == "Q" || $key == "q" ]]                        #Q, q</span><br><span class="line">                then</span><br><span class="line">                        MyExit</span><br><span class="line">                fi</span><br><span class="line">  </span><br><span class="line">                if [[ $sig != 0 ]]</span><br><span class="line">                then</span><br><span class="line">                        #向另一进程发送消息</span><br><span class="line">                        kill -$sig $pidDisplayer</span><br><span class="line">                fi</span><br><span class="line">        done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数是接收输入的进程的主程序,然后判断用户的输入,在这个脚本中,可以使用方向键和wasd来控制方块的运行轨迹,然后不断显示直到游戏结束.</p>
<p>里面调用了一个MyExit的函数.</p>
<p>接下来分析一下 RunAsDisplayer中BoxDown 这个函数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function BoxDown()</span><br><span class="line">&#123;</span><br><span class="line">        local y s</span><br><span class="line">        ((y = boxCurY + 1))        #新的y坐标</span><br><span class="line">        if BoxMove $y $boxCurX        #测试是否可以下落一行</span><br><span class="line">        then</span><br><span class="line">                s="`DrawCurBox 0`"        #将旧的方块抹去</span><br><span class="line">                ((boxCurY = y))</span><br><span class="line">                s="$s`DrawCurBox 1`"        #显示新的下落后方块</span><br><span class="line">                echo -ne $s</span><br><span class="line">        else</span><br><span class="line">                #走到这儿, 如果不能下落了</span><br><span class="line">                Box2Map                #将当前移动中的方块贴到背景方块中</span><br><span class="line">                RandomBox        #产生新的方块</span><br><span class="line">        fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数主要是定义了控制方块下落的功能,首先会判断是否可也下落,如果可以消除的话,先把可以消除的方块抹去,然后显示新的下落后的方块,如果不能下落了就将当前移动中的方块贴到背景方块中,然后继续产生新的方块.</p>
<p>里面调用了四个函数</p>
<p>BoxMove : 测试是否可以下落一行</p>
<p>DrawCurBox : 显示方块</p>
<p>Box2Map : 将当前移动中的方块贴到背景方块中</p>
<p>RandomBox : 产生新的方块</p>
<p>查看一下BoxMove这个函数,看看其中的功能是怎么实现的:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function BoxMove()</span><br><span class="line">&#123;</span><br><span class="line">        local j i x y xTest yTest</span><br><span class="line">        yTest=$1</span><br><span class="line">        xTest=$2</span><br><span class="line">        for ((j = 0; j &lt; 8; j += 2))</span><br><span class="line">        do</span><br><span class="line">                ((i = j + 1))</span><br><span class="line">                ((y = $&#123;boxCur[$j]&#125; + yTest))</span><br><span class="line">                ((x = $&#123;boxCur[$i]&#125; + xTest))</span><br><span class="line">                if (( y &lt; 0 || y &gt;= iTrayHeight || x &lt; 0 || x &gt;= iTrayWidth))</span><br><span class="line">                then</span><br><span class="line">                        #撞到墙壁了</span><br><span class="line">                        return 1</span><br><span class="line">                fi</span><br><span class="line">                if (($&#123;iMap[y * iTrayWidth + x]&#125; != -1 ))</span><br><span class="line">                then</span><br><span class="line">                        #撞到其他已经存在的方块了</span><br><span class="line">                        return 1</span><br><span class="line">                fi</span><br><span class="line">        done</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面定义了方块移动的相关信息,通过判断方块的位置来确定是否可以进行移动</p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>加密与安全(一)</title>
    <url>/%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8-%E4%B8%80/</url>
    <content><![CDATA[<p>关于安全,首先要介绍以下墨菲定律:</p>
<p>墨菲定律:一种心理学效应,是由爱德华·墨菲(Edward A. Murphy)提出的,原话:如果有两种或两种以上的方式去做某件事情,而其中一种选择方式将导致灾难,则必定有人会做出这种选择<br>主要内容:<br>任何事都没有表面看起来那么简单<br>所有的事都会比你预计的时间长<br>会出错的事总会出错<br>如果你担心某种情况发生,那么它就更有可能发生</p>
<h3 id="安全机制"><a href="#安全机制" class="headerlink" title="安全机制"></a>安全机制</h3><p>信息安全防护的目标<br>保密性         Confidentiality<br>完整性         Integrity<br>可用性         Usability<br>可控制性     Controlability<br>不可否认性     Non-repudiation<br>安全防护环节<br>物理安全:各种设备/主机、机房环境<br>系统安全:主机或设备的操作系统<br>应用安全:各种网络服务、应用程序<br>网络安全:对网络访问的控制、防火墙规则<br>数据安全:信息的备份与恢复、加密解密<br>管理安全:各种保障性的规范、流程、方法</p>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>安全攻击: STRIDE<br>Spoofing                      假冒<br>Tampering                      篡改<br>Repudiation                      否认<br>Information Disclosure         信息泄漏<br>Denial of Service                      拒绝服务<br>Elevation of Privilege              提升权限</p>
<h4 id="安全设计基本原则"><a href="#安全设计基本原则" class="headerlink" title="安全设计基本原则"></a>安全设计基本原则</h4><p>使用成熟的安全系统<br>以小人之心度输入数据<br>外部系统是不安全的<br>最小授权<br>减少外部接口<br>缺省使用安全模式<br>安全不是似是而非<br>从STRIDE思考<br>在入口处检查<br>从管理上保护好你的系统</p>
<h3 id="安全算法"><a href="#安全算法" class="headerlink" title="安全算法"></a>安全算法</h3><p><strong>常用安全技术</strong><br>    认证<br>    授权<br>    审计<br>    安全通信<br><strong>密码算法和协议</strong><br>    对称加密<br>    公钥加密<br>    单向加密<br>    认证协议</p>
<h4 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h4><p>对称加密:加密和解密使用同一个密钥<br>    DES:Data Encryption Standard,56bits<br>    3DES:<br>    AES:Advanced (128, 192, 256bits)<br>    Blowfish,Twofish<br>    IDEA,RC6,CAST5<br><strong>特性:</strong><br>    1、加密、解密使用同一个密钥,效率高<br>    2、将原始数据分割成固定大小的块,逐个进行加密<br><strong>缺陷:</strong><br>    1、密钥过多<br>    2、密钥分发<br>    3、数据来源无法确认</p>
<h4 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h4><p>公钥加密:密钥是成对出现<br>    公钥:公开给所有人；public key<br>    私钥:自己留存,必须保证其私密性；secret key<br><strong>特点</strong>:用公钥加密数据,只能使用与之配对的私钥解密；反之亦然<br><strong>功能:</strong><br>    数字签名:主要在于让接收方确认发送方身份<br>    对称密钥交换:发送方用对方的公钥加密一个对称密钥后发送给对方<br>    数据加密:适合加密较小数据<br><strong>缺点:</strong>密钥长,加密解密效率低下<br><strong>算法:</strong><br>    RSA(加密,数字签名)<br>    DSA(数字签名)<br>    ELGamal</p>
<h5 id="非对称加密实现"><a href="#非对称加密实现" class="headerlink" title="非对称加密实现"></a>非对称加密实现</h5><p>基于一对公钥/密钥对<br>    • 用密钥对中的一个加密,另一个解密<br>实现加密:<br>    • 接收者<br>        生成公钥/密钥对:P和S<br>        公开公钥P,保密密钥S<br>    • 发送者<br>        使用接收者的公钥来加密消息M<br>        将P(M)发送给接收者<br>    • 接收者<br>        使用密钥S来解密:M=S(P(M))</p>
<p>实现数字签名:<br>    • 发送者<br>        生成公钥/密钥对:P和S<br>        公开公钥P,保密密钥S<br>        使用密钥S来加密消息M<br>        发送给接收者S(M)<br>    • 接收者<br>        使用发送者的公钥来解密M=P(S(M))<br>结合签名和加密<br>分离签名</p>
<h4 id="单向散列"><a href="#单向散列" class="headerlink" title="单向散列"></a>单向散列</h4><p>将任意数据缩小成固定大小的“指纹”<br>    • 任意长度输入<br>    • 固定长度输出<br>    • 若修改数据,指纹也会改变(“不会产生冲突”)<br>    • 无法从指纹中重新生成数据(“单向”)<br>功能:数据完整性<br>常见算法<br>    md5: 128bits、sha1: 160bits、sha224、sha256、sha384、sha512<br>常用工具<br>    • md5sum | sha1sum [ –check ] file<br>    • openssl、gpg<br>    • rpm -V</p>
<h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><p><img data-src="https://github.com/Markupzh/Markupzh.github.io/blob/master/photo/post_secure_safe_01.png" alt=""></p>
<h4 id="密钥交换"><a href="#密钥交换" class="headerlink" title="密钥交换"></a>密钥交换</h4><p>密钥交换:IKE( Internet Key Exchange ) </p>
<p>公钥加密: DH (Deffie-Hellman):生成会话密钥,由惠特菲尔德·迪菲(Bailey Whitfield Diffie)和马丁·赫尔曼(Martin Edward Hellman)在1976年发表 参看:<a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange</a> </p>
<p>DH: </p>
<p>A: g,p 协商生成公开的整数g, 大素数p  </p>
<p>B: g,p </p>
<p>A:生成隐私数据:a (a &lt; p),计算得出g^a%p,发送给B</p>
<p>B:生成隐私数据:b,计算得出 g^b%p, 发送给A</p>
<p>A:计算得出[(g^b%p)^a]%p=g^ab%p,生成为密钥</p>
<p>B:计算得出[(g^a%p)^b]%p=g^ab%p,生成为密钥</p>
<h4 id="应用程序-RPM"><a href="#应用程序-RPM" class="headerlink" title="应用程序: RPM"></a>应用程序: RPM</h4><p>文件完整性的两种实施方式<br>    被安装的文件<br>        • MD5单向散列<br>        • rpm –verify package_name (or -V)<br>    发行的软件包文件<br>        • GPG公钥签名<br>        • rpm –import /etc/pki/rpm-gpg/RPM-GPG-KEY-redhat*<br>        • rpm –checksig pakage_file_name (or -K)</p>
<h4 id="使用-gpg-实现对称加密"><a href="#使用-gpg-实现对称加密" class="headerlink" title="使用 gpg 实现对称加密"></a>使用 gpg 实现对称加密</h4><p>对称加密file文件<br>    gpg -c file<br>    ls file.gpg<br>在另一台主机上解密file<br>    gpg -o file -d file.gpg</p>
<h4 id="使用-gpg-工具实现公钥加密"><a href="#使用-gpg-工具实现公钥加密" class="headerlink" title="使用 gpg 工具实现公钥加密"></a>使用 gpg 工具实现公钥加密</h4><p><strong>在hostB主机上用公钥加密,在hostA主机上解密</strong></p>
<p>在hostA主机上生成公钥/私钥对<br>    gpg –gen-key<br>在hostA主机上查看公钥<br>    gpg –list-keys<br>在hostA主机上导出公钥到mark.pubkey<br>    gpg -a –export -o mark.pubkey<br>从hostA主机上复制公钥文件到需加密的B主机上<br>    scp mark.pubkey hostB:</p>
<p>在需加密数据的hostB主机上生成公钥/私钥对<br>    gpg –list-keys<br>    gpg –gen-key<br>在hostB主机上导入公钥<br>    gpg –import mark.pubkey<br>    gpg –list-keys<br>用从hostA主机导入的公钥,加密hostB主机的文件file,生成file.gpg<br>    gpg -e -r mark file<br>    file file.gpg</p>
<p>复制加密文件到hostA主机<br>    scp fstab.gpg hostA:<br>在hostA主机解密文件<br>    gpg -d file.gpg<br>    gpg -o file -d file.gpg<br>删除公钥和私钥<br>    gpg –delete-keys mark<br>    gpg –delete-secret-keys mark</p>
<h4 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h4><p><img data-src="https://github.com/Markupzh/Markupzh.github.io/blob/master/photo/post_secure_safe_02.png" alt=""></p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>加密与安全(二)</title>
    <url>/%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8-%E4%BA%8C/</url>
    <content><![CDATA[<h3 id="CA和证书"><a href="#CA和证书" class="headerlink" title="CA和证书"></a>CA和证书</h3><p>PKI: Public Key Infrastructure<br>    签证机构:CA(Certificate Authority)<br>    注册机构:RA<br>    证书吊销列表:CRL<br>    证书存取库:<br>X.509:定义了证书的结构以及认证协议标准<br>    版本号</p>
<pre><code>序列号

签名算法

颁发者

有效期限

主体名称

主体公钥

CRL分发点

扩展信息

发行者签名</code></pre><h4 id="证书获取"><a href="#证书获取" class="headerlink" title="证书获取"></a>证书获取</h4><p>证书类型:<br>    证书授权机构的证书<br>    服务器<br>    用户证书<br>获取证书两种方法:<br>    • 使用证书授权机构<br>        生成签名请求(csr)<br>        将csr发送给CA<br>        从CA处接收签名<br>    • 自签名的证书<br>        自已签发自己的公钥    </p>
<h3 id="安全协议"><a href="#安全协议" class="headerlink" title="安全协议"></a>安全协议</h3><p>SSL: Secure Socket Layer,TLS: Transport Layer Security<br>        1995:SSL 2.0 Netscape<br>        1996: SSL 3.0<br>        1999: TLS 1.0<br>        2006: TLS 1.1 IETF(Internet工程任务组) RFC 4346<br>        2008:TLS 1.2 当前使用<br>        2015: TLS 1.3<br>    功能:机密性,认证,完整性,重放保护<br> 两阶段协议,分为握手阶段和应用阶段<br>    握手阶段(协商阶段):客户端和服务器端认证对方身份(依赖于PKI体系,利用数字证书进行身份认证),并协商通信中使用的安全参数、密码套件以及主密钥.后续通信使用的所有密钥都是通过MasterSecret生成.<br>    应用阶段:在握手阶段完成后进入,在应用阶段通信双方使用握手阶段协商好的密钥进行安全通信</p>
<h4 id="SSL-TLS图解"><a href="#SSL-TLS图解" class="headerlink" title="SSL/TLS图解"></a>SSL/TLS图解</h4><p><img data-src="https://github.com/Markupzh/Markupzh.github.io/blob/master/photo/post_secure_safe_03.png" alt=""></p>
<h4 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h4><p>Handshake协议:包括协商安全参数和密码套件、服务器身份认证(客户端身份认证可选)、密钥交换<br>ChangeCipherSpec 协议:一条消息表明握手协议已经完成<br>Alert 协议:对握手协议中一些异常的错误提醒,分为fatal和warning两个级别,fatal类型错误会直接中断SSL链接,而Warning级别的错误SSL链接仍可继续,只是会给出错误警告<br>Record 协议:包括对消息的分段、压缩、消息认证和完整性保护、加密等<br>HTTPS 协议:就是“HTTP 协议”和“SSL/TLS 协议”的组合.HTTP over SSL”或“HTTP over TLS”,对http协议的文本数据进行加密处理后,成为二进制形式传输</p>
<h4 id="HTTPS结构"><a href="#HTTPS结构" class="headerlink" title="HTTPS结构"></a>HTTPS结构</h4><p><img data-src="https://github.com/Markupzh/Markupzh.github.io/blob/master/photo/post_secure_safe_04.png" alt=""></p>
<h4 id="HTTPS工作过程"><a href="#HTTPS工作过程" class="headerlink" title="HTTPS工作过程"></a>HTTPS工作过程</h4><p><img data-src="https://github.com/Markupzh/Markupzh.github.io/blob/master/photo/post_secure_safe_05.png" alt=""></p>
<h4 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h4><p>OpenSSL:开源项目<br>    三个组件:<br>        openssl: 多用途的命令行工具,包openssl<br>        libcrypto: 加密算法库,包openssl-libs<br>        libssl:加密模块应用库,实现了ssl及tls,包nss<br>openssl命令:<br>    两种运行模式:交互模式和批处理模式<br>    openssl version:程序版本号<br>    标准命令、消息摘要命令、加密命令<br>    标准命令:<br>        enc, ca, req, …</p>
<h5 id="openssl命令"><a href="#openssl命令" class="headerlink" title="openssl命令"></a>openssl命令</h5><p><strong>对称加密:</strong><br>    工具:openssl enc, gpg<br>    算法:3des, aes, blowfish, twofish<br><strong>enc命令:</strong><br>    帮助:man enc<br>    加密:<br>    openssl enc -e -des3 -a -salt -in testfile -out testfile.cipher<br><strong>解密:</strong><br>    openssl enc -d -des3 -a -salt –in testfile.cipher<br>    -out testfile<br>    openssl ?</p>
<p><strong>单向加密:</strong><br>    工具:md5sum, sha1sum, sha224sum,sha256sum… openssl dgst<br><strong>dgst命令:</strong><br>    帮助:man dgst<br>    openssl dgst -md5 [-hex默认] /PATH/SOMEFILE<br>    openssl dgst -md5 testfile<br>    md5sum /PATH/TO/SOMEFILE<br><strong>MAC:</strong></p>
<p>Message Authentication Code,单向加密的一种延伸应用,用于实现网络通信中保证所传输数据的完整性机制<br>CBC-MAC<br>HMAC:使用md5或sha1算法</p>
<p><strong>生成用户密码:</strong><br>    passwd命令:<br>    帮助:man sslpasswd<br>    openssl passwd -1 -salt SALT(最多8位)<br>    openssl passwd -1 –salt centos<br><strong>生成随机数:</strong><br>    帮助:man sslrand<br>    openssl rand -base64|-hex NUM<br>    NUM: 表示字节数；-hex时,每个字符为十六进制,相当于4位二进制,出现的字符数为NUM*2</p>
<p><strong>公钥加密:</strong><br>    算法:RSA, ELGamal<br>    工具:gpg, openssl rsautl(man rsautl)<br><strong>数字签名:</strong><br>    算法:RSA, DSA, ELGamal<br><strong>密钥交换:</strong><br>    算法:dh<br>    DSA: Digital Signature Algorithm<br>    DSS:Digital Signature Standard<br>    RSA:</p>
<p><strong>生成密钥对:</strong></p>
<p>​    man genrsa</p>
<p><strong>生成私钥:</strong><br>    openssl genrsa -out /PATH/TO/PRIVATEKEY.FILE NUM_BITS<br>    (umask 077; openssl genrsa –out test.key –des 2048)<br>    openssl rsa -in test.key –out test2.key 将加密key解密<br><strong>从私钥中提取出公钥</strong><br>    openssl rsa -in PRIVATEKEYFILE –pubout –out PUBLICKEYFILE<br>    openssl rsa –in test.key –pubout –out test.key.pub<br><strong>随机数生成器:伪随机数字</strong><br>    键盘和鼠标,块设备中断<br>    /dev/random:仅从熵池返回随机数；随机数用尽,阻塞<br>    /dev/urandom:从熵池返回随机数；随机数用尽,会利用软件生成伪随机数,非阻塞</p>
<h4 id="OpenSSL-的几个简单使用"><a href="#OpenSSL-的几个简单使用" class="headerlink" title="OpenSSL 的几个简单使用"></a>OpenSSL 的几个简单使用</h4><p>PKI:Public Key Infrastructure<br>    CA<br>    RA<br>    CRL<br>    证书存取库<br>建立私有CA:<br>    OpenCA<br>    openssl<br>证书申请及签署步骤:<br>    1、生成申请请求<br>    2、RA核验<br>    3、CA签署<br>    4、获取证书</p>
<h4 id="创建CA和申请证书"><a href="#创建CA和申请证书" class="headerlink" title="创建CA和申请证书"></a>创建CA和申请证书</h4><p>创建私有CA:<br>    openssl的配置文件:/etc/pki/tls/openssl.cnf<br>    三种策略:匹配、支持和可选<br>    匹配指要求申请填写的信息跟CA设置信息必须一致,支持指必须填写这项申请信息,可选指可有可无</p>
<h5 id="1-创建所需要的文件"><a href="#1-创建所需要的文件" class="headerlink" title="1.创建所需要的文件"></a>1.创建所需要的文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch &#x2F;etc&#x2F;pki&#x2F;CA&#x2F;index.txt 生成证书索引数据库文件</span><br><span class="line">echo 01 &gt; &#x2F;etc&#x2F;pki&#x2F;CA&#x2F;serial 指定第一个颁发证书的序列号</span><br></pre></td></tr></table></figure>

<h5 id="2-CA自签证书"><a href="#2-CA自签证书" class="headerlink" title="2.CA自签证书"></a>2.CA自签证书</h5><p>生成私钥<br>    cd /etc/pki/CA/<br>    (umask 066; openssl genrsa -out etc/pki/CA/private/cakey.pem 2048)</p>
<p>生成自签名证书<br>openssl req -new -x509 –key<br>/etc/pki/CA/private/cakey.pem -days 7300 -out<br>/etc/pki/CA/cacert.pem<br>    -new:                             生成新证书签署请求<br>    -x509:                             专用于CA生成自签证书<br>    -key:                             生成请求时用到的私钥文件<br>    -days n:                        证书的有效期限<br>    -out /PATH/TO/SOMECERTFILE:     证书的保存路径</p>
<h5 id="3-颁发证书"><a href="#3-颁发证书" class="headerlink" title="3.颁发证书"></a>3.颁发证书</h5><p>在需要使用证书的主机生成证书请求<br>    给web服务器生成私钥<br>    (umask 066; openssl genrsa -out /etc/pki/tls/private/test.key 2048)<br>    生成证书申请文件<br>    openssl req -new -key /etc/pki/tls/private/test.key -days 365 -out etc/pki/tls/test.csr<br>将证书请求文件传输给CA<br>CA签署证书,并将证书颁发给请求者<br>    openssl ca -in /tmp/test.csr –out<br>    /etc/pki/CA/certs/test.crt -days 365<br>注意:默认国家,省,公司名称三项必须和CA一致</p>
<p>查看证书中的信息:<br>    openssl x509 -in /PATH/FROM/CERT_FILE -noout - text|issuer|subject|serial|dates<br>    openssl ca -status SERIAL 查看指定编号的证书状态</p>
<h5 id="4-吊销证书"><a href="#4-吊销证书" class="headerlink" title="4.吊销证书"></a>4.吊销证书</h5><p> 在客户端获取要吊销的证书的serial<br>    openssl x509 -in /PATH/FROM/CERT_FILE -noout -serial - subject<br> 在CA上,根据客户提交的serial与subject信息,对比检验是否与index.txt文件中的信息一致,<br>吊销证书:<br>    openssl ca -revoke /etc/pki/CA/newcerts/SERIAL.pem<br> 指定第一个吊销证书的编号,注意:第一次更新证书吊销列表前,才需要执行<br>    echo 01 &gt; /etc/pki/CA/crlnumber<br> 更新证书吊销列表<br>    openssl ca -gencrl -out /etc/pki/CA/crl.pem<br> 查看crl文件:<br>    openssl crl -in /etc/pki/CA/crl.pem -noout -text</p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>vmware 虚拟机三种网络模式 桥接 NAT 仅主机</title>
    <url>/vmware-%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%89%E7%A7%8D%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5-NAT-%E4%BB%85%E4%B8%BB%E6%9C%BA%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>vmware为我们提供了3种网络工作模式,分别是:Bridge(桥接模式),NAT(网络地址转换模式),Host-Only(仅主机模式).</p>
<p>首先在说到VMware的网络模型前,先说一下VMware的几个虚拟设备:</p>
<p>VMnet0:这是VMware用于虚拟机桥接网络下的虚拟交换机</p>
<p>VMnet1:这是VMware用于Host-Only网络下的虚拟交换机</p>
<p>VMnet8:这是VMware用于虚拟NAT网络下的虚拟交换机</p>
<p>VMware Network Adapter VMnet1:这是Host用于Host-Only虚拟网络进行通信的虚拟网卡</p>
<p>VMware Network Adapter VMnet8:这是Host用于NAT虚拟网络进行通信的虚拟网卡</p>
<p>那么如何查看这些网卡的信息呢?</p>
<p>在windows主机命令行提示符环境中输入 ipconfig 便可以查询到VMware Network Adapter VMnet1,VMware Network Adapter VMnet8的ip地址.</p>
<h4 id="Bridge-桥接模式"><a href="#Bridge-桥接模式" class="headerlink" title="Bridge(桥接模式)"></a>Bridge(桥接模式)</h4><p>桥接模式就是将主机网卡与虚拟机网卡利用虚拟网桥进行通信,在桥接的作用下,类似把主机虚拟为一个交换机,所有桥接设置的虚拟机连接到这个交换机的一个接口上,物理主机也同样连接到这个交换机中,所以所有桥接下的网卡与网卡都是交换模式的,相互可以访问而不干扰,在桥接模式下,虚拟机的ip地址需要与主机在同一个网段,如果需要联网,则网关与DNS需要与主机网卡一致.</p>
<p>在桥接模式下,VMware虚拟出来的操作系统就像是局域网中的一台独立的主机,它可以访问该类网段内任何一台机器.</p>
<p>桥接网络环境下需要做到:</p>
<p>1.手动为虚拟机系统配置ip地址,子网掩码</p>
<p>2.在桥接的模式下虚拟机必须与物理机处于同一网段,(举个例子,物理机ip:192.168.1.2 虚拟机ip:192.168.1.3)这样虚拟系统才能和真实主机进行通信.</p>
<p>当我们想利用VMware在局域网内新建一个虚拟服务器,为局域网用户提供网络服务,就应该选择桥接模式,便可将虚拟机模拟接入主机所在的局域网,桥接网络相当于虚拟机与主机在一台交换机上,同时上网,虚拟机对物理机的直接影响较小.</p>
<p>但是桥接模式也有一定的问题,如果网络环境很缺少,或者对ip的管理比较严格的话,那桥接模式就不太适用了.如果解决这个问题就引入了vmware的另一种网络模式:NAT模式</p>
<h4 id="NAT-地址转换模式"><a href="#NAT-地址转换模式" class="headerlink" title="NAT(地址转换模式)"></a>NAT(地址转换模式)</h4><p>在NAT网络中,会使用到VMnet8虚拟交换机,物理机上的VMware Network Adapter VMnet8 虚拟网卡将会和VMnet8交换机相连,来实现物理机与虚拟机之间的通信.</p>
<p>注意:VMware Network Adapter VMnet8虚拟网卡仅仅是用于和VMnet8网段通信用的,它并不为VMnet8网段提供路由功能,处于虚拟NAT网络下的Guest是使用虚拟的NAT服务器连接的Internet的.</p>
<p>VMware Network Adapter VMnet8 虚拟网卡它仅仅是为Host和NAT虚拟网络下的Guest通信提供一个接口,所以,即便去掉这块网卡,虚拟机仍然是可以上网的,只是物理机无法再访问到VMnet8网段而已.</p>
<p>1.主机需要开启vmdhcp和vmnat服务.</p>
<p>2.NAT模式下的虚拟机的TCP/IP配置信息将由VMnet8(NAT)虚拟网络的DHCP服务器自动分配,需要开启DHCP功能.</p>
<p>使用NAT模式,就是让虚拟系统借助NAT功能,通过物理机所在的网络来访问外网,也就是说,使用NAT模式可以实现在虚拟机里访问到互联网,NAT模式下的虚拟机的TCP/IP配置信息是由VMnet8(NAT)虚拟网络的DHCP服务器提供的,无法进行手动修改,因此虚拟系统也就无法和本局域网中的其他真实主机进行通讯,采用NAT模式最大的优势就是虚拟系统接入互联网非常简单,不需要进行任何其他的配置,只需要宿主机能访问互联网即可.</p>
<p>NAT模式下的网络,相当于说虚拟机是通过物理机连接上的网络,等于物理机是个路由器,申请到一个上网的名额,带着隐藏在它下下面的虚拟机上网,自然所有的虚拟机使用的网络总和都限制在实体机的一个网络通道内,虚拟机会抢占物理机的网络,对物理机上网会有很大的影响.</p>
<h4 id="Host-Only-仅主机模式"><a href="#Host-Only-仅主机模式" class="headerlink" title="Host-Only(仅主机模式)"></a>Host-Only(仅主机模式)</h4><p>Host-Only模式其实就是NAT模式去除了虚拟NAT设备,然后使用VMware Network Adapter VMnet1 虚拟网卡连接VMnet1虚拟交换机来与虚拟机通信的,Host-Only模式将虚拟机与外网隔开,是虚拟机成为一个独立的系统,只与主机相互通讯.</p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>加密与安全(五)</title>
    <url>/%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8-%E4%BA%94/</url>
    <content><![CDATA[<h3 id="PAM认证机制"><a href="#PAM认证机制" class="headerlink" title="PAM认证机制"></a>PAM认证机制</h3><p>PAM:Pluggable Authentication Modules<br>    认证库:文本文件,MySQL,NIS,LDAP等<br>    Sun公司于1995 年开发的一种与认证相关的通用框架机制<br>    PAM 是关注如何为服务验证用户的 API,通过提供一些动态链接库和一套统一的API,将系统提供的服务和该服务的认证方式分开<br>    使得系统管理员可以灵活地根据需要给不同的服务配置不同的认证方式而无需更改服务程序<br>    一种认证框架,自身不做认证</p>
<p>它提供了对所有服务进行认证的中央机制,适用于login,远程登录(telnet,rlogin,fsh,ftp,点对点协议 (PPP)),su等应用程序中.系统管理员通过PAM配置文件来制定不同应用程序的不同认证策略；应用程序开发者通过在服务程序中使用PAM API(pam_xxxx( ))来实现对认证方法的调用；而PAM服务模块的开发者则利用PAM SPI来编写模块(主要调用函数pam_sm_xxxx( )供PAM接口库调用,将不同的认证机制加入到系统中；PAM接口库(libpam)则读取配置文件,将应用程序和相应的PAM服务模块联系起来</p>
<h4 id="图解PAM架构"><a href="#图解PAM架构" class="headerlink" title="图解PAM架构"></a>图解PAM架构</h4><p><img data-src="https://github.com/Markupzh/Markupzh.github.io/blob/master/photo/post_secure_safe_08.png" alt=""></p>
<h4 id="PAM认证原理"><a href="#PAM认证原理" class="headerlink" title="PAM认证原理"></a>PAM认证原理</h4><p>PAM认证一般遵循这样的顺序:Service(服务)→PAM(配置文件)→pam_*.so<br>PAM认证首先要确定那一项服务,然后加载相应的PAM的配置文件(位于/etc/pam.d下),最后调用认证文件(位于/lib/security下)进行安全认证</p>
<p><img data-src="https://github.com/Markupzh/Markupzh.github.io/blob/master/photo/post_secure_safe_09.png" alt=""></p>
<h4 id="PAM认证机制-1"><a href="#PAM认证机制-1" class="headerlink" title="PAM认证机制"></a>PAM认证机制</h4><h5 id="PAM相关文件"><a href="#PAM相关文件" class="headerlink" title="PAM相关文件"></a>PAM相关文件</h5><p>模块文件目录:/lib64/security/*.so<br>环境相关的设置:/etc/security/<br>主配置文件:/etc/pam.conf,默认不存在<br>为每种应用模块提供一个专用的配置文 件:/etc/pam.d/APP_NAME<br>注意:如/etc/pam.d存在,/etc/pam.conf将失效</p>
<h5 id="PAM认证过程"><a href="#PAM认证过程" class="headerlink" title="PAM认证过程:"></a>PAM认证过程:</h5><p>1.使用者执行/usr/bin/passwd 程序,并输入密码<br>2.passwd开始调用PAM模块,PAM模块会搜寻passwd程序的PAM相关设置文件,这个设置文件一般是在/etc/pam.d/里边的与程序同名的文件,即PAM会搜寻/etc/pam.d/passwd此设置文件<br>3.经由/etc/pam.d/passwd设定文件的数据,取用PAM所提供的相关模块来进行验证<br>4.将验证结果回传给passwd这个程序,而passwd这个程序会根据PAM回传的结果决定下一个动作(重新输入密码或者通过验证)</p>
<h5 id="PAM认证文件"><a href="#PAM认证文件" class="headerlink" title="PAM认证文件:"></a>PAM认证文件:</h5><p>通用配置文件/etc/pam.conf格式<br>    application type control module-path arguments<br>专用配置文件/etc/pam.d/* 格式<br>    type control module-path arguments<br>说明:<br>    服务名(application)<br>    telnet、login、ftp等,服务名字“OTHER”代表所有没有在该文件中明确配置的其它服务<br>    模块类型(module-type)<br>    control PAM库该如何处理与该服务相关的PAM模块的成功或失败情况<br>    module-path 用来指明本模块对应的程序文件的路径名<br>    Arguments 用来传递给该模块的参数</p>
<h5 id="PAM模块类型-module-type"><a href="#PAM模块类型-module-type" class="headerlink" title="PAM模块类型(module-type)"></a>PAM模块类型(module-type)</h5><p>Auth 账号的认证和授权<br>Account 与账号管理相关的非认证类的功能,如:用来限制/允许用户对某个服务的访问时间,当前有效的系统资源(最多可以有多少个用户),限制用户的位置(例如:root用户只能从控制台登录)<br>Password 用户修改密码时密码复杂度检查机制等功能<br>Session 用户获取到服务之前或使用服务完成之后需要进行一些附加的操作,如:记录打开/关闭数据的信息,监视目录等<br>-type 表示因为缺失而不能加载的模块将不记录到系统日志,对于那些不总是安装在系统上的模块有用</p>
<h5 id="PAM参数"><a href="#PAM参数" class="headerlink" title="PAM参数"></a>PAM参数</h5><p>Control:<br>PAM库如何处理与该服务相关的PAM模块成功或失败情况<br>两种方式实现:<br>    简单和复杂<br>简单方式实现:一个关健词实现<br>    required :一票否决,表示本模块必须返回成功才能通过认证,但是如果该模块返回失败,失败结果也不会立即通知用户,而是要等到同一type中的所有模块全部执行完毕再将失败结果返回给应用程序.即为必要条件</p>
<p>requisite :一票否决,该模块必须返回成功才能通过认证,但是一旦该模块返回失败,将不再执行同一type内的任何模块,而是直接将控制权返回给应用程序.是一个必要条件<br>sufficient :一票通过,表明本模块返回成功则通过身份认证的要求,不必再执行同一type内的其它模块,但如果本模块返回失败可忽略,即为充分条件<br>optional :表明本模块是可选的,它的成功与否不会对身份认证起关键作用,其返回值一般被忽略<br>include: 调用其他的配置文件中定义的配置信息</p>
<p>复杂详细实现:使用一个或多个“status=action”<br>[status1=action1 status2=action …]<br>    Status:检查结果的返回状态<br>    Action:采取行为 ok,done,die,bad,ignore,reset<br>ok 模块通过,继续检查<br>done 模块通过,返回最后结果给应用<br>bad 结果失败,继续检查<br>die 结果失败,返回失败结果给应用<br>ignore 结果忽略,不影响最后结果<br>reset 忽略已经得到的结果</p>
<p>module-path: 模块路径<br>    相对路径:<br>        /lib64/security目录下的模块可使用相对路径<br>        如:pam_shells.so、pam_limits.so<br>    绝对路径:<br>模块通过读取配置文件完成用户对系统资源的使用控制<br>    /etc/security/*.conf<br>注意:修改PAM配置文件将马上生效<br>建议:编辑pam规则时,保持至少打开一个root会话,以防止root身份验证错误<br>Arguments 用来传递给该模块的参数</p>
<h5 id="PAM文档说明"><a href="#PAM文档说明" class="headerlink" title="PAM文档说明"></a>PAM文档说明</h5><p>/user/share/doc/pam-*<br>rpm -qd pam<br>man –k pam_<br>man 模块名 如man rootok<br>《The Linux-PAM System Administrators’ Guide》</p>
<h5 id="PAM模块示例"><a href="#PAM模块示例" class="headerlink" title="PAM模块示例"></a>PAM模块示例</h5><h6 id="模块-pam-shells"><a href="#模块-pam-shells" class="headerlink" title="模块:pam_shells"></a>模块:pam_shells</h6><p>功能:检查有效shell<br>man pam_shells<br>示例:不允许使用/bin/csh的用户本地登录<br>vim /etc/pam.d/login<br>    auth required pam_shells.so<br>vim /etc/shells<br>    去掉 /bin/csh<br>useradd –s /bin/csh testuser<br>testuser将不可登录<br>tail /var/log/secure</p>
<h6 id="模块-pam-securetty-so"><a href="#模块-pam-securetty-so" class="headerlink" title="模块:pam_securetty.so"></a>模块:pam_securetty.so</h6><p>功能:只允许root用户在/etc/securetty列出的安全终端上登陆<br>示例:允许root在telnet登陆<br>vi /etc/pam.d/remote<br>#auth required pam_securetty.so #将这一行加上注释</p>
<p>或者/etc/securetty文件中加入<br>pts/0,pts/1…pts/n</p>
<h6 id="模块-pam-nologin-so"><a href="#模块-pam-nologin-so" class="headerlink" title="模块:pam_nologin.so"></a>模块:pam_nologin.so</h6><p>功能:<br>    如果/etc/nologin文件存在,将导致非root用户不能登陆<br>    如果用户shell是/sbin/nologin 时,当该用户登陆时,会显示/etc/nologin文件内容,并拒绝登陆</p>
<h6 id="模块-pam-limits-so"><a href="#模块-pam-limits-so" class="headerlink" title="模块:pam_limits.so"></a>模块:pam_limits.so</h6><p>功能:在用户级别实现对其可使用的资源的限制,例如:可打开的文件数量,可运行的进程数量,可用内存空间<br>修改限制的实现方式:<br>(1) ulimit命令,立即生效,但无法保存<br>    -n 最多的打开的文件描述符个数<br>    -u 最大用户进程数<br>    -S 使用 soft(软)资源限制<br>    -H 使用 hard(硬)资源限制<br>(2) 配置文件:/etc/security/limits.conf, /etc/security/limits.d/*.conf<br>配置文件:每行一个定义；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\&lt;domain\&gt;    \&lt;type\&gt;      \&lt;item\&gt;       \&lt;value&gt;</span><br></pre></td></tr></table></figure>

<h5 id="PAM图解"><a href="#PAM图解" class="headerlink" title="PAM图解"></a>PAM图解</h5><p><img data-src="https://github.com/Markupzh/Markupzh.github.io/blob/master/photo/post_secure_safe_10.png" alt=""></p>
<h5 id="pam-limits-so"><a href="#pam-limits-so" class="headerlink" title="pam_limits.so"></a>pam_limits.so</h5><p> &lt;domain&gt;应用于哪些对象<br>    Username 单个用户<br>    @group 组内所有用户<br>    * 所有用户<br> &lt;type&gt;限制的类型<br>    Soft 软限制,普通用户自己可以修改<br>    Hard 硬限制,由root用户设定,且通过kernel强制生效<br>    - 二者同时限定<br> &lt;item&gt;限制的资源<br>    nofile 所能够同时打开的最大文件数量,默认为1024<br>    nproc 所能够同时运行的进程的最大数量,默认为1024<br> &lt;value&gt;指定具体值</p>
<h6 id="pam-limits-so-1"><a href="#pam-limits-so-1" class="headerlink" title="pam_limits.so"></a>pam_limits.so</h6><p>限制用户最多打开的文件数和运行进程数<br>/etc/pam.d/system-auth<br>    session required pam_limits.so<br>vim /etc/security/limits.conf<br>    apache – nofile 10240 用户apache可打开10240个文件<br>    student hard nproc 20 用户student不能运行超过20个进程</p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>加密与安全(三)</title>
    <url>/%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8-%E4%B8%89/</url>
    <content><![CDATA[<h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><p>ssh: secure shell, protocol, 22/tcp, 安全的远程登录<br>具体的软件实现:<br>    OpenSSH: ssh协议的开源实现,CentOS默认安装<br>    dropbear:另一个开源实现<br>SSH协议版本<br>    v1: 基于CRC-32做MAC,不安全；man-in-middle<br>    v2:双方主机协议选择安全的MAC方式<br>    基于DH算法做密钥交换,基于RSA或DSA实现身份认证<br>两种方式的用户登录认证:<br>    基于password<br>    基于key</p>
<h4 id="Openssh-软件组成"><a href="#Openssh-软件组成" class="headerlink" title="Openssh 软件组成"></a>Openssh 软件组成</h4><p>OpenSSH介绍<br>相关包:<br>    openssh<br>    openssh-clients<br>    openssh-server<br>工具:<br>    基于C/S结构<br>    Client: ssh, scp, sftp,slogin<br>        Windows客户端:<br>        xshell, putty, securecrt, sshsecureshellclient<br>    Server: sshd</p>
<h5 id="ssh客户端"><a href="#ssh客户端" class="headerlink" title="ssh客户端"></a>ssh客户端</h5><p>客户端组件:<br> ssh, 配置文件:/etc/ssh/ssh_config<br>    Host PATTERN<br>        StrictHostKeyChecking no 首次登录不显示检查提示<br> 格式:ssh [user@]host [COMMAND]<br>    ssh [-l user] host [COMMAND]<br> 常见选项<br>    -p port:远程服务器监听的端口<br>    -b:指定连接的源IP<br>    -v:调试模式<br>    -C:压缩方式<br>    -X:支持x11转发<br>    -t:强制伪tty分配<br>        ssh -t remoteserver1 ssh remoteserver2</p>
<p>允许实现对远程系统经验证地加密安全访问<br>当用户远程连接ssh服务器时,会复制ssh服务器/etc/ssh/ssh_host*key.pub (CentOS7默认是ssh_host_ecdsa_key.pub)文件中的公钥到客户机的~./ssh/know_hosts中.下次连接时,会自动匹配相应私钥,不能匹配,将拒绝连接</p>
<h4 id="ssh服务登录验证"><a href="#ssh服务登录验证" class="headerlink" title="ssh服务登录验证"></a>ssh服务登录验证</h4><p>ssh服务登录验证方式:<br>    用户/口令<br>    基于密钥<br>基于用户和口令登录验证<br>    1 客户端发起ssh请求,服务器会把自己的公钥发送给用户<br>    2 用户会根据服务器发来的公钥对密码进行加密<br>    3 加密后的信息回传给服务器,服务器用自己的私钥解密,如果密码正确,则用户登录成功</p>
<h5 id="图解基于用户口令登录验证"><a href="#图解基于用户口令登录验证" class="headerlink" title="图解基于用户口令登录验证"></a>图解基于用户口令登录验证</h5><p><img data-src="https://github.com/Markupzh/Markupzh.github.io/blob/master/photo/post_secure_safe_06.png" alt=""></p>
<h5 id="基于密钥的登录方式"><a href="#基于密钥的登录方式" class="headerlink" title="基于密钥的登录方式"></a>基于密钥的登录方式</h5><p>1 首先在客户端生成一对密钥(ssh-keygen)<br>2 并将客户端的公钥ssh-copy-id 拷贝到服务端<br>3 当客户端再次发送一个连接请求,包括ip、用户名<br>4 服务端得到客户端的请求后,会到authorized_keys中查找,如果有响应的IP和用户,就会随机生成一个字符串,例如:acdf<br>5 服务端将使用客户端拷贝过来的公钥进行加密,然后发送给客户端<br>6 得到服务端发来的消息后,客户端会使用私钥进行解密,然后将解密后的字符串发送给服务端<br>7服务端接受到客户端发来的字符串后,跟之前的字符串进行对比,如果一致,就允许免密码登录</p>
<h5 id="图解基于密钥的登录方式"><a href="#图解基于密钥的登录方式" class="headerlink" title="图解基于密钥的登录方式"></a>图解基于密钥的登录方式</h5><p><img data-src="https://github.com/Markupzh/Markupzh.github.io/blob/master/photo/post_secure_safe_07.png" alt=""></p>
<h5 id="基于key认证"><a href="#基于key认证" class="headerlink" title="基于key认证"></a>基于key认证</h5><p>基于密钥的认证:</p>
<h6 id="1-在客户端生成密钥对"><a href="#1-在客户端生成密钥对" class="headerlink" title="(1) 在客户端生成密钥对"></a>(1) 在客户端生成密钥对</h6><p><code>ssh-keygen -t rsa [-P &#39;&#39;]\[-f “~/.ssh/id_rsa&quot;]</code></p>
<h6 id="2-把公钥文件传输至远程服务器对应用户的家目录"><a href="#2-把公钥文件传输至远程服务器对应用户的家目录" class="headerlink" title="(2) 把公钥文件传输至远程服务器对应用户的家目录"></a>(2) 把公钥文件传输至远程服务器对应用户的家目录</h6><p><code>ssh-copy-id [-i [identity_file]]\[user@]host</code></p>
<h6 id="3-测试"><a href="#3-测试" class="headerlink" title="(3) 测试"></a>(3) 测试</h6><h6 id="4-在SecureCRT或Xshell实现基于key验证"><a href="#4-在SecureCRT或Xshell实现基于key验证" class="headerlink" title="(4) 在SecureCRT或Xshell实现基于key验证:"></a>(4) 在SecureCRT或Xshell实现基于key验证:</h6><p>在SecureCRT工具—&gt;创建公钥—&gt;生成Identity.pub文件转化为openssh兼容格式(适合SecureCRT,Xshell不需要转化格式),并复制到需登录主机上相应文件authorized_keys中,注意权限必须为600,在需登录的ssh</p>
<p>主机上执行:</p>
<p><code>ssh-keygen -i -f Identity.pub &gt;&gt; .ssh/authorized_keys</code></p>
<h6 id="5-重设私钥口令"><a href="#5-重设私钥口令" class="headerlink" title="(5)重设私钥口令:"></a>(5)重设私钥口令:</h6><p><code>ssh-keygen –p</code></p>
<h6 id="6-验证代理-authentication-agent-保密解密后的密钥"><a href="#6-验证代理-authentication-agent-保密解密后的密钥" class="headerlink" title="(6)验证代理(authentication agent)保密解密后的密钥"></a>(6)验证代理(authentication agent)保密解密后的密钥</h6><p>• 这样口令就只需要输入一次<br>• 在GNOME中,代理被自动提供给root用户<br>• 否则运行ssh-agent bash</p>
<h6 id="7-钥匙通过命令添加给代理"><a href="#7-钥匙通过命令添加给代理" class="headerlink" title="(7)钥匙通过命令添加给代理"></a>(7)钥匙通过命令添加给代理</h6><p><code>ssh-add</code></p>
<h5 id="scp命令"><a href="#scp命令" class="headerlink" title="scp命令"></a>scp命令</h5><p>scp [options] SRC… DEST/<br>两种方式:<br>    scp [options][user@]host:/sourcefile /destpath<br>    scp [options] /sourcefile [user@]host:/destpath<br>常用选项:<br>    -C 压缩数据流<br>    -r 递归复制<br>    -p 保持原文件的属性信息<br>    -q 静默模式<br>    -P PORT 指明remote host的监听的端口</p>
<h5 id="rsync命令"><a href="#rsync命令" class="headerlink" title="rsync命令"></a>rsync命令</h5><p>基于ssh和rsh服务实现高效率的远程系统之间复制文件(增量更新)<br> 使用安全的shell连接做为传输方式<br>    • rsync –av /etc server1:/tmp 复制目录和目录下文件<br>    • rsync –av /etc/ server1:/tmp 只复制目录下文件<br> 比scp更快,只复制不同的文件<br> 选项:<br>    -n 模拟复制过程<br>    -v 显示详细过程<br>    -r 递归复制目录树<br>    -p 保留权限<br>    -t 保留时间戳<br>    -g 保留组信息<br>    -o 保留所有者信息<br>    -l 将软链接文件本身进行复制(默认)<br>    -L 将软链接文件指向的文件复制<br>    -a 存档,相当于–rlptgoD,但不保留ACL(-A)和SELinux属性(-X)</p>
<h5 id="sftp命令"><a href="#sftp命令" class="headerlink" title="sftp命令"></a>sftp命令</h5><p>交互式文件传输工具<br>用法和传统的ftp工具相似<br>利用ssh服务实现安全的文件上传和下载<br>使用ls cd mkdir rmdir pwd get put等指令,可用？或help获取帮助信息<br>    sftp [user@]host<br>    sftp&gt; help</p>
<h5 id="pssh工具"><a href="#pssh工具" class="headerlink" title="pssh工具"></a>pssh工具</h5><p> pssh是一个python编写可以在多台服务器上执行命令的工具,也可实现文件复制<br> 选项如下:<br>     –version:查看版本<br>     -h:主机文件列表,内容格式”[user@]host[:port]”<br>     -H:主机字符串,内容格式”[user@]host[:port]”<br>     -A:手动输入密码模式<br>     -i:每个服务器内部处理信息输出<br>     -l:登录使用的用户名<br>     -p:并发的线程数【可选】<br>     -o:输出的文件目录【可选】<br>     -e:错误输入文件【可选】<br>     -t:TIMEOUT 超时时间设置,0无限制【可选】<br>     -O:SSH的选项<br>     -P:打印出服务器返回信息<br>     -v:详细模式</p>
<h6 id="pssh示例"><a href="#pssh示例" class="headerlink" title="pssh示例"></a>pssh示例</h6><p>通过pssh批量关闭seLinux</p>
<p>pssh -H <a href="mailto:root@192.168.1.10">root@192.168.1.10</a> -i “sed -i “s/SELINUX=enforcing/SELINUX=disabled/“  /etc/selinux/config”</p>
<p>批量发送指令:<br>    pssh -H <a href="mailto:root@192.168.1.10">root@192.168.1.10</a> -i setenforce 0<br>    pssh -H <a href="mailto:xuewb@192.168.1.10">xuewb@192.168.1.10</a> -i hostname<br>当不支持ssh的key认证时,通过 -A选项,使用密码认证批量执行指令<br>    pssh -H <a href="mailto:xuewb@192.168.1.10">xuewb@192.168.1.10</a> -A -i hostname<br>将标准错误和标准正确重定向都保存至/app目录下<br>    pssh -H 192.168.1.10 -o /app -e /app -i “hostname”</p>
<h5 id="PSCP-PSSH"><a href="#PSCP-PSSH" class="headerlink" title="PSCP.PSSH"></a>PSCP.PSSH</h5><p>pscp.pssh功能是将本地文件批量复制到远程主机<br>    pscp [-vAr][-h hosts_file] [-H [user@]host[:port]][-l user] [-p par][-o outdir] [-e errdir][-t timeout] [-O options][-x args] [-X arg] local remote</p>
<p>Pscp-pssh选项<br>    -v 显示复制过程<br>    -r 递归复制目录<br>将本地curl.sh 复制到/app/目录<br>    pscp.pssh -H 192.168.1.10 /root/test/curl.sh /app/<br>    pscp.pssh -h host.txt /root/test/curl.sh /app/<br>将本地多个文件批量复制到/app/目录<br>    pscp.pssh -H 192.168.1.10 /root/f1.sh /root/f2.sh /app/<br>将本地目录批量复制到/app/目录<br>    pscp.pssh -H 192.168.1.10 -r /root/test/ /app/</p>
<h5 id="PSLURP"><a href="#PSLURP" class="headerlink" title="PSLURP"></a>PSLURP</h5><p>pslurp功能是将远程主机的文件批量复制到本地<br>    pslurp [-vAr][-h hosts_file] [-H [user@]host[:port]][-l user] [-p par][-o outdir] [-e errdir][-t timeout][-O options][-x args][-X arg][-L localdir]</p>
<p>remote local(本地名)<br>Pslurp选项<br>    -L 指定从远程主机下载到本机的存储的目录,local是下载到本地后的名称<br>    -r 递归复制目录<br>批量下载目标服务器的passwd文件至/app下,并更名为user<br>    pslurp -H 192.168.1.10 -L /app/ /etc/passwd user</p>
<h4 id="SSH端口转发"><a href="#SSH端口转发" class="headerlink" title="SSH端口转发"></a>SSH端口转发</h4><h5 id="本地转发"><a href="#本地转发" class="headerlink" title="本地转发:"></a>本地转发:</h5><p><code>-L localport:remotehost:remotehostport sshserver</code></p>
<p>选项:<br>    -f 后台启用<br>    -N 不打开远程shell,处于等待状态<br>    -g 启用网关功能<br>示例<br>    ssh –L 9527:telnetsrv:23 -N sshsrv<br>    telnet 127.0.0.1 9527<br>    当访问本机的9527的端口时,被加密后转发到sshsrv的ssh服务,再解密被转发到telnetsrv:23<br>data &lt;- -&gt; localhost:9527 &lt;- -&gt; localhost:XXXXX &lt;- -&gt; sshsrv:22  &lt;- -&gt; sshsrv:YYYYY &lt;- -&gt; telnetsrv:23</p>
<h5 id="远程转发"><a href="#远程转发" class="headerlink" title="远程转发:"></a>远程转发:</h5><p><code>-R sshserverport:remotehost:remotehostport sshserver</code></p>
<p>示例:<br>    ssh –R 9527:telnetsrv:23 –N sshsrv<br>    让sshsrv侦听9527端口的访问,如有访问,就加密后通过ssh服务转发请求到本机ssh客户端,再由本机解密后转发到telnetsrv:23<br>Data &lt;- -&gt; sshsrv:9527 &lt;- -&gt; sshsrv:22 &lt;- -&gt; localhost:XXXXX &lt;- -&gt; localhost:YYYYY &lt;- -&gt; telnetsrv:23</p>
<h5 id="动态端口转发"><a href="#动态端口转发" class="headerlink" title="动态端口转发:"></a>动态端口转发:</h5><p>当用firefox访问internet时,本机的1080端口做为代理服务器,firefox的访问请求被转发到sshserver上,由sshserver替之访问internet<br>    ssh -D 1080 root@sshserver<br>在本机firefox设置代理socket proxy:127.0.0.1:1080<br>    curl –socks5 127.0.0.1:1080 <a href="http://www.qq.com" target="_blank" rel="noopener">http://www.qq.com</a></p>
<h5 id="X-协议转发"><a href="#X-协议转发" class="headerlink" title="X 协议转发"></a>X 协议转发</h5><p>所有图形化应用程序都是X客户程序<br>    • 能够通过tcp/ip连接远程X服务器<br>    • 数据没有加密机,但是它通过ssh连接隧道安全进行<br>ssh -X user@remotehost gedit<br>    remotehost主机上的gedit工具,将会显示在本机的X服务器上传输的数据将通过ssh连接加密</p>
<h4 id="ssh服务器"><a href="#ssh服务器" class="headerlink" title="ssh服务器"></a>ssh服务器</h4><p>服务器端:sshd, 配置文件: /etc/ssh/sshd_config<br>常用参数:<br>    Port<br>    ListenAddress ip<br>    LoginGraceTime 2m<br>    PermitRootLogin yes<br>    StrictModes yes 检查.ssh/文件的所有者,权限等<br>    MaxAuthTries 6<br>    MaxSessions 10 同一个连接最大会话<br>    PubkeyAuthentication yes<br>    PermitEmptyPasswords no<br>    PasswordAuthentication yes</p>
<pre><code>GatewayPorts no

ClientAliveInterval:单位:秒

ClientAliveCountMax:默认3

UseDNS yes

GSSAPIAuthentication yes 提高速度可改为no

MaxStartups 未认证连接最大值,默认值10

Banner /path/file

限制可登录用户的办法:

    AllowUsers user1 user2 user3

        DenyUsers

        AllowGroups

        DenyGroups    </code></pre><h4 id="ssh服务的最佳实践"><a href="#ssh服务的最佳实践" class="headerlink" title="ssh服务的最佳实践"></a>ssh服务的最佳实践</h4><p>建议使用非默认端口<br>禁止使用protocol version 1<br>限制可登录用户<br>设定空闲会话超时时长<br>利用防火墙设置ssh访问策略<br>仅监听特定的IP地址<br>基于口令认证时,使用强密码策略<br>    tr -dc A-Za-z0-9_ &lt; /dev/urandom | head -c 30| xargs<br>使用基于密钥的认证<br>禁止使用空密码<br>禁止root用户直接登录<br>限制ssh的访问频度和并发在线数<br>经常分析日志</p>
<h4 id="编译安装dropbear示例"><a href="#编译安装dropbear示例" class="headerlink" title="编译安装dropbear示例"></a>编译安装dropbear示例</h4><p>ssh协议的另一个实现:dropbear<br>源码编译安装:<br>• 1、安装开发包组:yum groupinstall “Development tools”<br>• 2、下载dropbear-2017.75.tar.bz2<br>• 3、tar xf dropbear-2017.75.tar.bz2<br>• 4、less INSTALL README<br>• 5、./configure<br>• 6、make PROGRAMS=”dropbear dbclient dropbearkey dropbearconvert scp”<br>• 7、make PROGRAMS=”dropbear dbclient dropbearkey dropbearconvert scp” install</p>
<p>启动ssh服务:<br>• 8、ls /usr/local/sbin/ /usr/local/bin/<br>• 9、/usr/local/sbin/dropbear -h<br>• 10、mkdir /etc/dropbear<br>• 11、dropbearkey -t rsa -f /etc/dropbear/dropbear_rsa_host_key -s 2048<br>• 12、dropbearkey -t dss -f /etc/dropbear/dropbear_dsa_host_key<br>• 13、运行dropbear:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dropbear -p :2222 -F –E 	#前台运行</span><br><span class="line">dropbear -p :2222 		#后台运行</span><br></pre></td></tr></table></figure>

<p>客户端访问:<br>• 14、ssh -p 2222 <a href="mailto:root@127.0.0.1">root@127.0.0.1</a><br>• 15、dbclient -p 2222 <a href="mailto:root@127.0.0.1">root@127.0.0.1</a></p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>加密与安全(四)</title>
    <url>/%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8-%E5%9B%9B/</url>
    <content><![CDATA[<h3 id="AIDE"><a href="#AIDE" class="headerlink" title="AIDE"></a>AIDE</h3><h5 id="AIDE简介"><a href="#AIDE简介" class="headerlink" title="AIDE简介"></a>AIDE简介</h5><p>当一个入侵者进入了你的系统并且种植了木马,通常会想办法来隐蔽这个木马(除了木马自身的一些隐蔽特性外,他会尽量给你检查系统的过程设置障碍),通常入侵者会修改一些文件,比如管理员通常用ps -aux来查看系统进程,那么入侵者很可能用自己经过修改的ps程序来替换掉你系统上的ps程序,以使用ps命令查不到正在运行的木马程序.如果入侵者发现管理员正在运行crontab作业,也有可能替换掉crontab程序等等.所以由此可以看出对于系统文件或是关键文件的检查是很必要的.目前就系统完整性检查的工具用的比较多的有两款:Tripwire和AIDE,前者是一款商业软件,后者是一款免费的但功能也很强大的工具</p>
<p>AIDE(Advanced Intrusion Detection Environment)<br>• 高级入侵检测环境)是一个入侵检测工具,主要用途是检查文件的完整性,审计计算机上的那些文件被更改过了.<br>• AIDE能够构造一个指定文件的数据库,它使用aide.conf作为其配置文件.AIDE数据库能够保存文件的各种属性,包括:权限(permission)、索引节点序号(inode number)、所属用户(user)、所属用户组(group)、文件大小、最后修改时间(mtime)、创建时间(ctime)、最后访问时间(atime)、增加的大小以及连接数.AIDE还能够使用下列算法:sha1、md5、rmd160、tiger,以密文形式建立每个文件的校验码或散列号.<br>• 这个数据库不应该保存那些经常变动的文件信息,例如:日志文件、邮件、/proc文件系统、用户起始目录以及临时目录.</p>
<h5 id="安装AIDE"><a href="#安装AIDE" class="headerlink" title="安装AIDE"></a>安装AIDE</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install aide</span><br></pre></td></tr></table></figure>

<h5 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h5><p>vim /etc/aide.conf (指定对哪些文件进行检测)<br>/test/chameleon R<br>/bin/ps R+a<br>/usr/bin/crontab R+a<br>/etc PERMS<br>!/etc/mtab #“!”表示忽略这个文件的检查<br>R=p+i+n+u+g+s+m+c+md5 权限+索引节点+链接数+用户+组+大小+最后一次修改时间+创建时间+md5校验    值<br>NORMAL = R+rmd60+sha256    </p>
<h5 id="初始化默认的AIDE的库"><a href="#初始化默认的AIDE的库" class="headerlink" title="初始化默认的AIDE的库:"></a>初始化默认的AIDE的库:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;aide --init</span><br></pre></td></tr></table></figure>

<h5 id="生成检查数据库-建议初始数据库存放到安全的地方"><a href="#生成检查数据库-建议初始数据库存放到安全的地方" class="headerlink" title="生成检查数据库(建议初始数据库存放到安全的地方)"></a>生成检查数据库(建议初始数据库存放到安全的地方)</h5><p>cd /var/lib/aide<br>mv aide.db.new.gz aide.db.gz    </p>
<h5 id="检测"><a href="#检测" class="headerlink" title="检测:"></a>检测:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;aide --check</span><br></pre></td></tr></table></figure>

<h5 id="更新数据库"><a href="#更新数据库" class="headerlink" title="更新数据库"></a>更新数据库</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aide --update</span><br></pre></td></tr></table></figure>



<h3 id="sudo更改身份"><a href="#sudo更改身份" class="headerlink" title="sudo更改身份"></a>sudo更改身份</h3><p>su 切换身份:su –l username –c ‘command’<br>sudo<br>    • 来自sudo包,man 5 sudoers<br>    • sudo能够授权指定用户在指定主机上运行某些命令.如果未授权用户尝试使用 sudo,会提示联系管理员<br>    • sudo可以提供日志,记录每个用户使用sudo操作<br>    • sudo为系统管理员提供配置文件,允许系统管理员集中地管理用户的使用权限和使用的主机<br>    • sudo使用时间戳文件来完成类似“检票”的系统,默认存活期为5分钟的“入场券”<br>    • 通过visudo命令编辑配置文件,具有语法检查功能<br>        visudo –c 检查语法<br>        visudo -f /etc/sudoers.d/test</p>
<h4 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h4><p>配置文件:/etc/sudoers, /etc/sudoers.d/<br>时间戳文件:/var/db/sudo<br>日志文件:/var/log/secure<br>配置文件支持使用通配符glob:<br>？:任意单一字符</p>
<p>* :匹配任意长度字符</p>
<p>[wxc]:匹配其中一个字符</p>
<p>[!wxc]:除了这三个字符的其它字符</p>
<p>\x : 转义</p>
<p>[[alpha]] :字母 示例: /bin/ls [[alpha]]*    </p>
<p>配置文件规则有两类；<br>    1、别名定义:不是必须的<br>    2、授权规则:必须的</p>
<h4 id="sudoers"><a href="#sudoers" class="headerlink" title="sudoers"></a>sudoers</h4><p>授权规则格式:<br>    用户 登入主机=(代表用户) 命令<br>示例:<br>    root ALL=(ALL) ALL<br>格式说明:<br>    user: 运行命令者的身份<br>    host: 通过哪些主机<br>    (runas):以哪个用户的身份<br>    command: 运行哪些命令</p>
<h4 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h4><p> Users和runas:<br>    username<br>    #uid<br>    %group_name<br>    %#gid<br>    user_alias|runas_alias<br> host:<br>    ip或hostname<br>    network(/netmask)<br>    host_alias<br> command:<br>    command name<br>    directory<br>    sudoedit<br>    Cmnd_Alias</p>
<h4 id="sudo别名和示例"><a href="#sudo别名和示例" class="headerlink" title="sudo别名和示例"></a>sudo别名和示例</h4><p>别名有四种类型:User_Alias, Runas_Alias, Host_Alias ,Cmnd_Alias<br>别名格式:[A-Z]([A-Z][0-9]_)*</p>
<p>别名定义:<br>Alias_Type NAME1 = item1, item2, item3 : NAME2 = item4, item5</p>
<h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h5><p>Student ALL=(ALL) ALL<br>%wheel ALL=(ALL) ALL</p>
<h5 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h5><p>student ALL=(root) /sbin/pidof,/sbin/ifconfig<br>%wheel ALL=(ALL) NOPASSWD: ALL</p>
<h5 id="示例3"><a href="#示例3" class="headerlink" title="示例3:"></a>示例3:</h5><p>User_Alias NETADMIN= netuser1,netuser2<br>Cmnd_Alias NETCMD = /usr/sbin/ip<br>NETADMIN ALL=(root) NETCMD</p>
<h5 id="示例4"><a href="#示例4" class="headerlink" title="示例4:"></a>示例4:</h5><p>User_Alias SYSADER=mark,jack,%admins<br>User_Alias DISKADER=tom<br>Host_Alias SERS=<a href="http://www.google.com,172.16.0.0/24" target="_blank" rel="noopener">www.google.com,172.16.0.0/24</a><br>Runas_Alias OP=root<br>Cmnd_Alias SYDCMD=/bin/chown,/bin/chmod<br>Cmnd_Alias DSKCMD=/sbin/parted,/sbin/fdisk<br>SYSADER SERS= SYDCMD,DSKCMD<br>DISKADER ALL=(OP) DSKCMD </p>
<p>User_Alias ADMINUSER = adminuser1,adminuser2<br>Cmnd_Alias ADMINCMD =             /usr/sbin/useradd,/usr/sbin/usermod,<br>/usr/bin/passwd [a-zA-Z]*, !/usr/bin/passwd root ADMINUSER ALL=(root) NOPASSWD:ADMINCMD,<br>PASSWD:/usr/sbin/userdel</p>
<h5 id="示例5"><a href="#示例5" class="headerlink" title="示例5:"></a>示例5:</h5><p>Defaults:mark runas_default=tom<br>mark ALL=(tom,jerry) ALL</p>
<h5 id="示例6"><a href="#示例6" class="headerlink" title="示例6:"></a>示例6:</h5><p>mark 192.168.1.6,192.168.1.8=(root) /usr/sbin/,!/usr/sbin/useradd</p>
<h5 id="示例7"><a href="#示例7" class="headerlink" title="示例7:"></a>示例7:</h5><p>mark ALL=(ALL) /bin/cat /var/log/messages*</p>
<h4 id="sudo命令"><a href="#sudo命令" class="headerlink" title="sudo命令"></a>sudo命令</h4><p>ls -l /usr/bin/sudo<br>sudo –i –u mark 切换身份<br>sudo [-u user] COMMAND<br>    -V 显示版本信息等配置信息<br>    -u user 默认为root<br>    -l,ll 列出用户在主机上可用的和被禁止的命令<br>    -v 再延长密码有效期限5分钟,更新时间戳<br>    -k 清除时间戳(1970-01-01),下次需要重新输密码<br>    -K 与-k类似,还要删除时间戳文件<br>    -b 在后台执行指令<br>    -p 改变询问密码的提示符号<br>    示例:-p “password on %h for user %p:” </p>
<h3 id="TCP-Wrappers"><a href="#TCP-Wrappers" class="headerlink" title="TCP_Wrappers"></a>TCP_Wrappers</h3><p>作者:Wieste Venema,IBM,Google<br>工作在第四层(传输层)的TCP协议<br>对有状态连接的特定服务进行安全检测并实现访问控制<br>以库文件形式实现<br>某进程是否接受libwrap的控制取决于发起此进程的程序在编译时是否针对libwrap进行编译的<br>判断服务程序是否能够由tcp_wrapper进行访问控制的方法:<br>    ldd /PATH/TO/PROGRAM|grep libwrap.so<br>    strings PATH/TO/PROGRAM|grep libwrap.so</p>
<h4 id="TCP-Wrappers的使用"><a href="#TCP-Wrappers的使用" class="headerlink" title="TCP_Wrappers的使用"></a>TCP_Wrappers的使用</h4><p>配置文件:/etc/hosts.allow, /etc/hosts.deny<br>帮助参考:man 5 hosts_access,man 5 hosts_options<br>检查顺序:hosts.allow,hosts.deny(默认允许)<br>    注意:一旦前面规则匹配,直接生效,将不再继续<br>基本语法:<br>    daemon_list@host: client_list [ :options :option… ]<br>Daemon_list@host格式<br>    单个应用程序的二进制文件名,而非服务名,例如vsftpd<br>    以逗号或空格分隔的应用程序文件名列表,如:sshd,vsftpd<br>    ALL表示所有接受tcp_wrapper控制的服务程序<br>    主机有多个IP,可用@hostIP来实现控制如:<a href="mailto:in.telnetd@192.168.0.254">in.telnetd@192.168.0.254</a></p>
<p>客户端Client_list格式<br>    以逗号或空格分隔的客户端列表<br>    基于IP地址:192.168.10.1 192.168.1.<br>    基于主机名:<a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> .google.com 较少用<br>    基于网络/掩码:192.168.0.0/255.255.255.0<br>    基于net/prefixlen: 192.168.1.0/24(CentOS7)<br>    基于网络组(NIS 域):@mynetwork<br>    内置ACL:ALL,LOCAL,KNOWN,UNKNOWN,PARANOID<br>EXCEPT用法:<br>    示例:<br>    vsftpd: 172.16. EXCEPT 172.16.100.0/24 EXCEPT 172.16.100.1</p>
<p>[:options]选项:<br>帮助:man 5 hosts_options<br>    deny 主要用在/etc/hosts.allow定义“拒绝”规则<br>        如:vsftpd: 172.16. :deny<br>    allow 主要用在/etc/hosts.deny定义“允许”规则<br>        如:vsftpd:172.16. :allow<br>    spawn 启动一个外部程序完成执行的操作<br>        twist 实际动作是拒绝访问,使用指定的操作替换当前服务,标准I/O和ERROR发送到客户端,默认至/dev/null<br>测试工具:<br>    tcpdmatch [-d] daemon[@host] client<br>    -d 测试当前目录下的hosts.allow和hosts.deny</p>
<h5 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1:"></a>示例1:</h5><p>只允许192.168.1.0/24的主机访问sshd</p>
<p>/etc/hosts.allow<br>    sshd: 192.168.1.<br>/etc/hosts.deny<br>    sshd :ALL </p>
<h5 id="示例2-1"><a href="#示例2-1" class="headerlink" title="示例2:"></a>示例2:</h5><p>只允许192.168.1.0/24的主机访问telnet和vsftpd服务</p>
<p>/etc/hosts.allow<br>    vsftpd,in.telnetd: 192.168.1.<br>/etc/host.deny<br>    vsftpd,in.telnetd: ALL </p>
<h5 id="示例3-1"><a href="#示例3-1" class="headerlink" title="示例3:"></a>示例3:</h5><p>sshd: ALL :spawn echo “$(date +%%F) login attempt from %c to<br>%s,%d” &gt;&gt;/var/log/sshd.log<br>说明:<br>    在/etc/hosts.allow中添加,允许登录,并记录日志<br>    在/etc/hosts.deny中添加,拒绝登录,并记录日志<br>    %c 客户端信息<br>    %s 服务器端信息<br>    %d 服务名<br>    %p 守护进程的PID<br>    %% 表示%<br>vsftpd: 172.16. :twist /bin/echo “connection prohibited”</p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>运维自动化-系统部署(二)</title>
    <url>/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96-%E7%B3%BB%E7%BB%9F%E9%83%A8%E7%BD%B2-%E4%BA%8C/</url>
    <content><![CDATA[<h3 id="使用cobbler"><a href="#使用cobbler" class="headerlink" title="使用cobbler"></a>使用cobbler</h3><p>Cobbler:<br>    快速网络安装linux操作系统的服务，支持众多的Linux发行版：Red Hat、Fedora、CentOS、Debian、Ubuntu和SuSE，也可以支持网络安装windows<br>    PXE的二次封装，将多种安装参数封装到一个菜单<br>    Python编写<br>    提供了CLI和Web的管理形式</p>
<h4 id="cobbler-工作流程"><a href="#cobbler-工作流程" class="headerlink" title="cobbler 工作流程"></a>cobbler 工作流程</h4><pre><code>client裸机配置了从网络启动后，开机后会广播包请求DHCP服务器（cobbler server）发送其分配好的一个IP
DHCP服务器（cobbler server）收到请求后发送responese，包括其ip地址
client裸机拿到ip后再向cobbler server发送请求OS引导文件的请求
cobbler server告诉裸机OS引导文件的名字和TFTP server的ip和port
client裸机通过上面告知的TFTP server地址通信，下载引导文件
client裸机执行执行该引导文件，确定加载信息，选择要安装的os，期间会再向 cobbler server请求kickstart文件和os image
cobbler server发送请求的kickstart和os iamge
client裸机加载kickstart文件
client裸机接收os image，安装该os image</code></pre><h4 id="cobbler-介绍"><a href="#cobbler-介绍" class="headerlink" title="cobbler 介绍"></a>cobbler 介绍</h4><p>安装包<br>    cobbler 基于EPEL源<br>cobbler 服务集成<br>    PXE<br>    DHCP<br>    rsync<br>    Http<br>    DNS<br>    Kickstart<br>    IPMI 电源管理<br>检查cobbler环境<br>    cobbler check</p>
<p>cobbler 相关术语<br>    发行版：<br>        表示一个操作系统版本，它承载了内核和 initrd 的信息，以及内核参数等其他数据<br>    配置文件：<br>        包含一个发行版、一个 kickstart 文件以及可能的存储库，还包含更多特定的内核参数等其他数据<br>    系统：<br>        表示要配置的主机，它包含一个配置文件或一个镜像，还包含 IP 和 MAC 地址、电源管理（地址、凭据、类型）以及更为专业的数据等信息<br>    存储库：<br>        保存一个 yum 或 rsync 存储库的镜像信息</p>
<h4 id="cobbler-各种配置目录说明"><a href="#cobbler-各种配置目录说明" class="headerlink" title="cobbler 各种配置目录说明"></a>cobbler 各种配置目录说明</h4><pre><code>安装：yum install cobbler dhcp
配置文件目录 /etc/cobbler
    /etc/cobbler/settings : cobbler 主配置文件
    /etc/cobbler/iso/: iso模板配置文件
    /etc/cobbler/pxe: pxe模板文件
    /etc/cobbler/power: 电源配置文件
    /etc/cobbler/user.conf: web服务授权配置文件
    /etc/cobbler/users.digest: web访问的用户名密码配置文件
    /etc/cobbler/dhcp.template : dhcp服务器的的配置末班
    /etc/cobbler/dnsmasq.template : dns服务器的配置模板
    /etc/cobbler/tftpd.template : tftp服务的配置模板
    /etc/cobbler/modules.conf : 模块的配置文件</code></pre><h4 id="cobbler-目录介绍"><a href="#cobbler-目录介绍" class="headerlink" title="cobbler 目录介绍"></a>cobbler 目录介绍</h4><p>数据目录<br>    /var/lib/cobbler/config/: 用于存放distros，system，profiles 等信息配置文件<br>    /var/lib/cobbler/triggers/: 用于存放用户定义的cobbler命令<br>    /var/lib/cobbler/kickstart/: 默认存放kickstart文件<br>    /var/lib/cobbler/loaders/: 存放各种引导程序</p>
<p>镜像目录<br>    /var/www/cobbler/ks_mirror/: 导入的发行版系统的所有数据<br>    /var/www/cobbler/images/ : 导入发行版的kernel和initrd镜像用于远程网络启动<br>    /var/www/cobbler/repo_mirror/: yum 仓库存储目录</p>
<p>日志目录<br>    /var/log/cobbler/installing: 客户端安装日志<br>    /var/log/cobbler/cobbler.log : cobbler日志</p>
<h4 id="cobbler-命令介绍"><a href="#cobbler-命令介绍" class="headerlink" title="cobbler 命令介绍"></a>cobbler 命令介绍</h4><p>cobbler check 核对当前设置是否有问题<br>cobbler list 列出所有的cobbler元素<br>cobbler report 列出元素的详细信息<br>cobbler sync 同步配置到数据目录,更改配置最好都要执行下<br>cobbler reposync 同步yum仓库<br>cobbler distro 查看导入的发行版系统信息<br>cobbler system 查看添加的系统信息<br>cobbler profile 查看配置信息</p>
<h4 id="cobbler-重要的参数"><a href="#cobbler-重要的参数" class="headerlink" title="cobbler 重要的参数"></a>cobbler 重要的参数</h4><pre><code>/etc/cobbler/settings中重要的参数设置
default_password_crypted: &quot;$1$gEc7ilpP$pg5iSOj/mlxTxEslhRvyp/&quot;
manage_dhcp：1
manage_tftpd：1
pxe_just_once：1
next_server：&lt; tftp服务器的 IP 地址&gt;
server：&lt;cobbler服务器的 IP 地址&gt;</code></pre><h4 id="cobbler-环境检查"><a href="#cobbler-环境检查" class="headerlink" title="cobbler 环境检查"></a>cobbler 环境检查</h4><p>执行Cobbler check命令会报如下异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 : The ‘server’ field in &#x2F;etc&#x2F;cobbler&#x2F;settings must be set to something other than localhost, or kickstarting features will not work. This should be a resolvable hostname or IP for the boot server as reachable by all machines that will use it.</span><br><span class="line">2 : For PXE to be functional, the ‘next_server’ field in &#x2F;etc&#x2F;cobbler&#x2F;settings must be set to something other than 127.0.0.1, and should match the IP of the boot server on the PXE network.</span><br><span class="line">3 : some network boot-loaders are missing from &#x2F;var&#x2F;lib&#x2F;cobbler&#x2F;loaders, you may run ‘cobbler get-loaders’ to download them, or, if you only want to handle x86&#x2F;x86_64 netbooting, you may ensure that you have installed a recent version of the syslinux package installed and can ignore this message entirely. Files in this directory, should you want to support all architectures, should include pxelinux.0, menu.c32, elilo.efi, and yaboot. The ‘cobbler get-loaders’ command is the easiest way to resolve these requirements.</span><br><span class="line">4 : change ‘disable’ to ‘no’ in &#x2F;etc&#x2F;xinetd.d&#x2F;rsync</span><br><span class="line">5 : comment ‘dists’ on &#x2F;etc&#x2F;debmirror.conf for proper debian support</span><br><span class="line">6 : comment ‘arches’ on &#x2F;etc&#x2F;debmirror.conf for proper debian support</span><br><span class="line">7 : The default password used by the sample templates for newly installed machines (default_password_crypted in &#x2F;etc&#x2F;cobbler&#x2F;settings)</span><br><span class="line">is still set to ‘cobbler’ and should be changed, try: “openssl passwd -1 -salt ‘random-phrase-here’ ‘your-password-here’” to generate new one</span><br><span class="line">8 : fencing tools were not found, and are required to use the (optional) power management features. install cman or fence-agents to use them</span><br></pre></td></tr></table></figure>



<h4 id="cobbler-报错解决"><a href="#cobbler-报错解决" class="headerlink" title="cobbler 报错解决"></a>cobbler 报错解决</h4><pre><code>执行Cobbler check报错解决方式
修改/etc/cobbler/settings文件中的server参数的值为提供cobbler服务的主机相应的IP地址或主机名
修改/etc/cobbler/settings文件中的next_server参数的值为提供PXE服务的主机相应的IP地址
如果当前节点可以访问互联网，执行“cobbler get-loaders”命令即可；否则，需要安装syslinux程序包，而后复制/usr/share/syslinux/{pxelinux.0,memu.c32}等文件至/var/lib/cobbler/loaders/目录中
执行“chkconfig rsync on”命令即可
执行“openssl passwd -1 生成密码，并用其替换/etc/cobbler/settings文件中default_password_crypted参数的值</code></pre><h4 id="cobbler-相关管理"><a href="#cobbler-相关管理" class="headerlink" title="cobbler 相关管理"></a>cobbler 相关管理</h4><pre><code>下载启动菜单：
    联网：cobbler get-loaders
    不联网：cp /usr/share/syslinux/{pxelinux.0,menu.c32}  /var/lib/tftpboot

管理distro
    cobbler import --name=centos-7.5-x86_64 --path=/media/cdrom --arch=x86_64

管理profile
    cobbler profile add --name=centos-7.5-x86_64-basic --distro=centos-7.5-x86_64 --kickstart= /var/lib/cobbler/kickstarts/centos7_x86_64.cfg</code></pre><h4 id="cobbler-命令"><a href="#cobbler-命令" class="headerlink" title="cobbler 命令"></a>cobbler 命令</h4><pre><code>查看profiles
    cobbler profile list
查看引导文件
    cat /var/lib/tftpboot/pxelinux.cfg/default
同步cobbler配置
    cobbler sync
多系统引导方案
    cobbler import --name=CentOS-7-x86_64 --path=/media/cdrom 
    cobbler distro list
    cobbler profile list 
    cobbler sync</code></pre><h4 id="cobbler-实现步骤"><a href="#cobbler-实现步骤" class="headerlink" title="cobbler 实现步骤"></a>cobbler 实现步骤</h4><pre><code>安装包，并设置服务
检查配置
根据上面提示修改配置
下载启动相关文件菜单
配置DHCP服务
分别导入centos的安装源,并查看
准备kickstart文件并导入cobbler
测试</code></pre><h4 id="cobbler的web管理实现"><a href="#cobbler的web管理实现" class="headerlink" title="cobbler的web管理实现"></a>cobbler的web管理实现</h4><p>cobbler-web</p>
<pre><code>提供cobbler的基于web管理界面，epel源 yum install cobbler-web

认证方式
    认证方法配置文件：/etc/cobbler/modules.conf
    支持多种认证方法：
        authn_configfile
        authn_pam</code></pre><p>  使用authn_configfile模块认证cobbler_web用户<br>        vim /etc/cobbler/modules.conf<br>        [authentication]<br>        module=authn_configfile</p>
<p>创建其认证文件/etc/cobbler/users.digest，并添加所需的用户 htdigest -c /etc/cobbler/users.digest Cobbler admin<br>注意:添加第一个用户时,使用“-c”选项，后续添加其他用户时不要再使用，cobbler_web的realm只能为Cobbler</p>
<pre><code>使用authn_pam模块认证cobbler_web用户
    vim /etc/cobbler/modules.conf 
    [authentication]
    module = authn_pam
创建cobbler用户：useradd cobbler
    vim /etc/cobbler/users.conf
    [admins]
    admin = &quot;cobbler“

Web访问cobbler
    重启cobblerd服务
    通过https://cobblerserver/cobbler_web访问</code></pre>]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ops</tag>
      </tags>
  </entry>
  <entry>
    <title>配置Linux主机之间SSH互信连接</title>
    <url>/%E9%85%8D%E7%BD%AELinux%E4%B8%BB%E6%9C%BA%E4%B9%8B%E9%97%B4SSH%E4%BA%92%E4%BF%A1%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<p>无论在本地搭建实验环境还是在生产环境中,多节点并行计算设置中,建立Linux主机间的SSH互信是非常重要的环节.常见的互信机制包括RSH和SSH两种,其中SSH互信较常用到,下面介绍SSH的原理及其配置方法.</p>
<p>首先,我们先了解下配置ssh互信的原理,ssh互信,说白了,就是在目标机器上,预先设置好经过认证的key文件,当需要访问目标机器时,目标机器通过key文件,对访问者进行自动认证,从而实现互信.</p>
<p>了解了ssh互信的原理,我们把配置ssh互信的步骤,进行有效的分割:</p>
<p>1.首先,在要配置互信的机器上,生成各自的经过认证的key文件;</p>
<p>2.其次,将所有的key文件汇总到一个总的认证文件中;</p>
<p>3.将这个包含了所有互信机器认证key的认证文件,分发到各个机器中去;</p>
<p>4.验证互信;</p>
<p>实例演示:CentOS 7.5系统的两台电脑,IP分别为192.168.0.100和192.168.0.101,主机名(hostname)分别为node0和node1,默认都已安装SSH服务,要实现两个名称相同的账号root间的互信连接.</p>
<p>备注:主机名可以通过root用户修改/etc/sysconfig/network中的hostname变量名,重启设定生效,而hostname命令只修改当前显示的主机名,重启后即失效. </p>
<p>1.节点node1上,以root身份修改/etc/hosts文件,以建立主机IP和主机名(hostname)间的映射,其文件格式如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Do not remove the following line, or various programs</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> that require network functionality will fail.</span></span><br><span class="line">127.0.0.1       localhost.localdomain localhost</span><br><span class="line">::1             localhost6.localdomain6 localhost6</span><br><span class="line">192.168.100.100 node1.localdomain     node1</span><br><span class="line">192.168.100.101 node2.localdomain     node2</span><br></pre></td></tr></table></figure>

<p>IP hostname.domainname hostname,其中各项以Tab键隔开.</p>
<p>注意:修改该文件不是必须步骤,但方便以后用主机名直接访问各主机,省去了输入IP地址的麻烦.在节点node2上进行相同操作.</p>
<p> 2.用户root身份,在node1上生成认证RSA密钥(这里有个细节,就是ssh互信的认证文件,需要放在用户的home目录下的.ssh目录中,因此我们要首先建立这个目录,并且保证这个目录的权限是700):</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdir .ssh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> chmod 700 .ssh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ssh-keygen -t rsa</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/home/deven/.ssh/id_rsa): </span><br><span class="line">Enter passphrase (empty for no passphrase): </span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /home/deven/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /home/deven/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">89:56:d6:4a:b2:6c:4a:05:86:ae:cd:7d:80:dd:3c:f1 deven@node1</span><br></pre></td></tr></table></figure>

<p>中间过程直接3个回车.在~/.ssh/目录下,生成了两个文件:id_rsa(私钥文件放在本地) 和 id_rsa.pub(公钥文件放在信任服务器).</p>
<p>在node2上,以用户root身份进行相同操作.</p>
<p>3.将所有的公钥文件 id_rsa.pub汇总到一个总的认证文件authorized-keys中:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ssh root@node2 cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span></span><br></pre></td></tr></table></figure>

<p>4.经过1,2两步,目前node1上存在一份完整的认证key文件,这时候,把她拷到node2主机的对应目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> scp ~/.ssh/authorized_keys root@node2:~/.ssh/authorized_keys</span></span><br></pre></td></tr></table></figure>

<p>5.大功告成,这时候,再互相用ssh命令连接,看看是否配置成功.</p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>运维自动化-系统部署(一)</title>
    <url>/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96-%E7%B3%BB%E7%BB%9F%E9%83%A8%E7%BD%B2-%E4%B8%80/</url>
    <content><![CDATA[<h3 id="安装Linux系统"><a href="#安装Linux系统" class="headerlink" title="安装Linux系统"></a>安装Linux系统</h3><p>CentOS系统安装系统启动流程：<br>    bootloader–&gt;kernel(initramfs)–&gt;rootfs–&gt;/sbin/init</p>
<p>anaconda: 系统安装程序<br>    gui：图形窗口<br>    tui: 基于图形库curses的文本窗口</p>
<h4 id="安装程序启动过程"><a href="#安装程序启动过程" class="headerlink" title="安装程序启动过程"></a>安装程序启动过程</h4><p>MBR：isolinux/boot.cat<br>stage2: isolinux/isolinux.bin<br>配置文件：isolinux/isolinux.cfg<br>    每个对应的菜单选项：<br>        加载内核：isolinuz/vmlinuz<br>        向内核传递参数：append initrd=initrd.img …<br>装载根文件系统，并启动anaconda<br>    默认启动GUI接口<br>    若是显式指定使用TUI接口：向内核传递text参数即可<br>    (1)按tab键,在后面增加text<br>    (2)按ESC键：boot: linux text</p>
<h3 id="anaconda工作过程"><a href="#anaconda工作过程" class="headerlink" title="anaconda工作过程"></a>anaconda工作过程</h3><p>Anaconda安装系统分成三个阶段：<br><strong>安装前配置阶段</strong><br>    安装过程使用的语言键盘类型<br>    安装目标存储设备<br>        Basic Storage：本地磁盘<br>        特殊设备：iSCSI<br>    设定主机名<br>    配置网络接口时区<br>    管理员密码<br>    设定分区方式及MBR的安装位置<br>    创建一个普通用户<br>    选定要安装的程序包</p>
<p><strong>安装阶段</strong><br>    在目标磁盘创建分区，执行格式化操作等<br>    将选定的程序包安装至目标位置<br>    安装bootloader和initramfs</p>
<p><strong>图形模式首次启动</strong><br>    iptables<br>    selinux<br>    core dump</p>
<h4 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h4><p>启动安装过程一般应位于引导设备；后续的anaconda及其安装用到的程序包等可来自下面几种方式:<br>    本地光盘<br>    本地硬盘<br>    NFS<br>    URL:<br>        ftp server: yum repository<br>        http server: yum repostory<br>如果想手动指定安装源：<br>    boot: linux askmethod</p>
<h4 id="指定安装源"><a href="#指定安装源" class="headerlink" title="指定安装源"></a>指定安装源</h4><p><strong>centos6</strong><br>    DVD drive        repo=cdrom :device<br>    Hard Drive        repo=hd:device/path<br>    HTTP Server        repo=<a href="http://host/path" target="_blank" rel="noopener">http://host/path</a><br>    HTTPS Server    repo=<a href="https://host/path" target="_blank" rel="noopener">https://host/path</a><br>    FTP Server        repo=<a href="ftp://username:password@">ftp://username:password@</a> host/path<br>    NFS Server        repo=nfs:server:/path<br>    ISO images on an NFS Server repo=nfsiso:server:/path</p>
<p><strong>centos7</strong><br>    Any CD/DVD drive    inst.repo=cdrom<br>    Hard Drive            inst.repo=hd:device:/path<br>    HTTP Server            inst.repo=<a href="http://host/path" target="_blank" rel="noopener">http://host/path</a><br>    HTTPS Server        inst.repo=<a href="https://host/path" target="_blank" rel="noopener">https://host/path</a><br>    FTP Server            inst.repo=<a href="ftp://username:password@">ftp://username:password@</a> host/path<br>    NFS Server            inst.repo=nfs:[options:]server:/path</p>
<h4 id="系统安装-1"><a href="#系统安装-1" class="headerlink" title="系统安装"></a>系统安装</h4><p>anaconda的配置方式：<br>    (1)    交互式配置方式<br>    (2)    通过读取事先给定的配置文件自动完成配置按特定语法给出的配置选项kickstart文件</p>
<p>安装boot引导选项：boot:<br>    text: 文本安装方式<br>    askmethod: 手动指定使用的安装方法</p>
<p>与网络相关的引导选项：<br>ip=IPADDR<br>netmask=MASK<br>gateway=GW<br>dns=DNS_SERVER_IP<br>ifname=NAME:MAC_ADDR    </p>
<p>与远程访问功能相关的引导选项：<br>    vnc<br>    vncpassword=’PASSWORD’</p>
<p>指明kickstart文件的位置： ks=<br>    DVD drive: ks=cdrom:/PATH/TO/KICKSTART_FILE<br>    Hard drive: ks=hd:device:/directory/KICKSTART_FILE<br>    HTTP server: ks=<a href="http://host:port/path/to/KICKSTART_FILE">http://host:port/path/to/KICKSTART_FILE</a><br>    FTP server: ks=<a href="ftp://host:port/path/to/KICKSTART_FILE">ftp://host:port/path/to/KICKSTART_FILE</a><br>    HTTPS server: ks=<a href="https://host:port/path/to/KICKSTART_FILE">https://host:port/path/to/KICKSTART_FILE</a><br>    NFS server:ks=nfs:host:/path/to/KICKSTART_FILE</p>
<p>启动紧急救援模式：<br>    rescue</p>
<p>官方文档：《Installation Guide》</p>
<h4 id="kickstart文件的格式"><a href="#kickstart文件的格式" class="headerlink" title="kickstart文件的格式"></a>kickstart文件的格式</h4><p>命令段：指明各种安装前配置，如键盘类型等<br>程序包段：指明要安装的程序包组或程序包，不安装的程序包等<br>    %packages<br>    @group_name<br>    package<br>    -package<br>    %end</p>
<p>脚本段：<br>%pre: 安装前脚本<br>    运行环境：运行于安装介质上的微型Linux环境</p>
<p>%post: 安装后脚本<br>    运行环境：安装完成的系统</p>
<p>命令段中的命令：<br>必备命令<br>    authconfig: 认证方式配置<br>        authconfig –useshadow –passalgo=sha512<br>    bootloader：bootloader的安装位置及相关配置<br>        bootloader –location=mbr –driveorder=sda – append=”crashkernel=auto rhgb quiet”<br>    keyboard: 设定键盘类型<br>    lang: 语言类型<br>    part: 创建分区<br>    rootpw: 指明root的密码<br>    timezone: 时区</p>
<p>可选命令<br>    install OR upgrade<br>    text: 文本安装界面<br>    network<br>    firewall<br>    selinux<br>    halt<br>    poweroff<br>    reboot<br>    repo<br>    user：安装完成后为系统创建新用户<br>    url: 指明安装源<br>    key –skip 跳过安装号码,适用于rhel版本</p>
<p>创建kickstart文件的方式<br>    直接手动编辑<br>        依据某模板修改<br>    可使用创建工具：system-config-kickstart<br>        依据某模板修改并生成新配置<br>        /root/anaconda-ks.cfg<br>    检查ks文件的语法错误：ksvalidator<br>        ksvalidator /PATH/TO/KICKSTART_FILE</p>
<p>系统光盘中isolinux目录列表<br>    solinux.bin：光盘引导程序，在mkisofs的选项中需要明确给出文件路径，这个文件属于SYSLINUX项目<br>    isolinux.cfg：isolinux.bin的配置文件，当光盘启动后（即运行isolinux.bin），会自动去找isolinux.cfg文件<br>    vesamenu.c32：是光盘启动后的安装图形界面，也属于SYSLINUX项目，menu.c32版本是纯文本的菜单<br>    Memtest：内存检测，这是一个独立的程序<br>    splash.jgp：光盘启动界面的背景图<br>    vmlinuz是内核映像<br>    initrd.img是ramfs (先cpio，再gzip压缩)</p>
<h4 id="制作引导光盘和U盘"><a href="#制作引导光盘和U盘" class="headerlink" title="制作引导光盘和U盘"></a>制作引导光盘和U盘</h4><p>创建引导光盘：<br>    mkdir –pv /app/myiso<br>    cp -r /misc/cd/isolinux/ /app/myiso/<br>    vim /app/myiso/isolinux/isolinux.cfg initrd=initrd.img text ks=cdrom:/myks.cfg<br>    cp /root/myks.cfg /app/myiso/<br>    mkisofs -R -J -T -v –no-emul-boot –boot-load-size 4 –boot-info-table -V “CentOS 6.9 x86_64 boot” -b isolinux/isolinux.bin -c isolinux/boot.cat -o /root/boot.iso /app/myiso/<br>    注意：以上相对路径都是相对于光盘的根，和工作目录无关</p>
<p>创建U盘启动盘<br>    dd if=/dev/sr0 of=/dev/sdb</p>
<h5 id="mkisofs选项"><a href="#mkisofs选项" class="headerlink" title="mkisofs选项"></a>mkisofs选项</h5><pre><code>-o 指定映像文件的名称。
-b 指定在制作可开机光盘时所需的开机映像文件。
-c 制作可开机光盘时，会将开机映像文件中的 no-eltorito-catalog 全部内容作成一个文件。
-no-emul-boot 非模拟模式启动。
-boot-load-size 4 设置载入部分的数量
-boot-info-table 在启动的图像中现实信息
-R 或 -rock   使用 Rock RidgeExtensions
-J 或 -joliet   使用 Joliet 格式的目录与文件名称
-v 或 -verbose   执行时显示详细的信息
-T 或 -translation-table 建立文件名的转换表，适用于不支持 Rock Ridge Extensions 的系统上</code></pre><h3 id="DHCP服务"><a href="#DHCP服务" class="headerlink" title="DHCP服务"></a>DHCP服务</h3><p>网络配置<br>    静态指定<br>    动态获取: bootp:boot protocol MAC与IP一一静态对应dhcp:增强的bootp，动态</p>
<p>DHCP: （Dynamic Host Configuration Protocol）<br>    动态主机配置协议<br>    局域网协议，UDP协议</p>
<p>主要用途：<br>    用于内部网络和网络服务供应商自动分配IP地址给用户<br>    用于内部网络管理员作为对所有电脑作集中管理的手段</p>
<p>使用场景<br>    自动化安装系统<br>    解决IPV4资源不足问题</p>
<p>DHCP共有八种报文<br>    DHCP DISCOVER：客户端到服务器<br>    DHCP OFFER ：服务器到客户端<br>    DHCP REQUEST：客户端到服务器<br>    DHCP ACK ：服务器到客户端<br>    DHCP NAK：服务器到客户端,通知用户无法分配合适的IP地址<br>    DHCP DECLINE ：客户端到服务器，指示地址已被使用<br>    DHCP RELEASE：客户端到服务器，放弃网络地址和取消剩余的租约时间<br>    DHCP INFORM：客户端到服务器, 客户端如果需要从DHCP服务器端获取更为详细的配置信息，则发送Inform报文向服务器进行请求，极少用到</p>
<p>续租<br>    50% ：租赁时间达到50%时来续租，刚向DHCP服务器发向新的DHCPREQUEST请求。如果dhcp服务没有拒绝的理由，则回应DHCPACK信息。当DHCP客户端收到该应答信息后，就重新开始新的租用周期<br>    87.5%：如果之前DHCP Server没有回应续租请求，等到租约期的7/8时，主机会再发送一次广播请求</p>
<h4 id="DHCP服务简介"><a href="#DHCP服务简介" class="headerlink" title="DHCP服务简介"></a>DHCP服务简介</h4><p>同网段多DHCP服务<br>    DHCP服务必须基于本地<br>    先到先得的原则</p>
<p>跨网段<br>    RFC 1542 Compliant Routers<br>    dhcrelay: 中继</p>
<p>相关协议<br>    Arp<br>    rarp</p>
<h4 id="DHCP实现"><a href="#DHCP实现" class="headerlink" title="DHCP实现"></a>DHCP实现</h4><p>Linux DHCP协议的实现程序：dhcp, dnsmasq（dhcp,dns）</p>
<p>Dhcp Server<br>    /usr/sbin/dhcpd<br>    /etc/dhcp/dhcpd.conf –&gt; /etc/rc.d/init.d/dhcpd<br>    /etc/dhcp/dhcpd6.conf–&gt; /etc/rc.d/init.d/dhcpd6<br>    /usr/sbin/dhcrelay<br>    /etc/rc.d/init.d/dhcrelay<br>    dhcp server:67/udp<br>    dhcp client: 68/udp<br>    dhcpv6 client:546/udp</p>
<p>Dhcp client<br>    dhclient<br>    自动获取的IP信息：    /var/lib/dhclient</p>
<h4 id="DHCP配置文件"><a href="#DHCP配置文件" class="headerlink" title="DHCP配置文件"></a>DHCP配置文件</h4><p>dhcpd.conf:<br>    帮助参考：man 5 dhcpd.conf<br>    全局配置<br>    subnet {<br>        …<br>    }<br>    host {</p>
<p>​    }</p>
<p>地址分配记录<br>    /var/lib/dhcpd/dhcpd.leases</p>
<h4 id="dhcpd-conf示例"><a href="#dhcpd-conf示例" class="headerlink" title="dhcpd.conf示例"></a>dhcpd.conf示例</h4><p>option domain-name “magedu.com”;<br>option domain-name-servers 192.168.0.1,8.8.8.8;<br>default-lease-time 86400;<br>max-lease-time 86400;<br>subnet 192.168.100.0 netmask 255.255.255.0 {<br>    range 192.168.100.1 192.168.100.200;<br>    option routers 192.168.100.1;<br>}</p>
<p>其它配置选项：<br>    filename: 指明引导文件名称<br>    next-server：提供引导文件的服务器IP地址<br>示例：<br>    filename “pxelinux.0”;<br>    next-server 192.168.100.100;<br>检查语法<br>    service dhcpd configtest</p>
<h3 id="PXE介绍"><a href="#PXE介绍" class="headerlink" title="PXE介绍"></a>PXE介绍</h3><p>PXE：<br>    Preboot Excution Environment 预启动执行环境<br>    Intel公司研发<br>    基于Client/Server的网络模式，支持远程主机通过网络从远端服务器下载映像，并由此支持通过网络启动操作系统<br>    PXE可以引导和安装Windows,linux等多种操作系统</p>
<p>PXE工作原理<br>    Client向PXE Server上的DHCP发送IP地址请求消息，DHCP检测Client是否合法（主要是检测Client的网卡MAC地址），如果合法则返回Client的IP地址，同时将启动文件pxelinux.0的位置信息一并传送给Client<br>    Client向PXE Server上的TFTP发送获取pxelinux.0请求消息，TFTP接收到消息之后再向Client<br>发送pxelinux.0大小信息，试探Client是否满意，当TFTP收到Client发回的同意大小信息之后，正式向Client发送pxelinux.0<br>    Client执行接收到的pxelinux.0文件<br>    Client向TFTP Server发送针对本机的配置信息文件（在TFTP 服务的pxelinux.cfg目录下），<br>TFTP将配置文件发回Client，继而Client根据配置文件执行后续操作。<br>    Client向TFTP发送Linux内核请求信息，TFTP接收到消息之后将内核文件发送给Client<br>    Client向TFTP发送根文件请求信息，TFTP接收到消息之后返回Linux根文件系统<br>    Client启动Linux内核<br>    Client下载安装源文件，读取自动化安装脚本</p>
<h4 id="PXE自动化安装CentOS-7"><a href="#PXE自动化安装CentOS-7" class="headerlink" title="PXE自动化安装CentOS 7"></a>PXE自动化安装CentOS 7</h4><p>安装前准备：关闭防火墙和SELINUX，DHCP服务器静态IP<br>安装软件包<br>    httpd tftp-server dhcp syslinux system-config-kickstart<br>配置文件共享服务：<br>    systemctl enable httpd<br>    systemctl start httpd<br>    mkdir /var/www/html/centos/7<br>    mount /dev/sr0 /var/www/html/centos/7<br>准备kickstart文件<br>    /var/www/html/ks/centos7.cfg 注意：权限<br>配置tftp服务<br>    systemctl enable tftp.socket<br>    systemctl start tftp.socket<br>配置DHCP服务<br>    vim /etc/dhcp/dhcpd.conf<br>    option domain-name “example.com”;<br>    default-lease-time 600;<br>    max-lease-time 7200;<br>    subnet 192.168.100.0 netmask 255.255.255.0 {<br>        range 192.168.100.1 192.168.100.200;<br>        filename “pxelinux.0”;<br>        next-server 192.168.100.100;<br>    }<br>    systemctl enable dhcpd<br>    systemctl start dhcpd</p>
<p>准备相关文件<br>mkdir /var/lib/tftpboot/pxelinux.cfg/<br>cp /usr/share/syslinux/{pxelinux.0,menu.c32} /var/lib/tftpboot/<br>cp /misc/cd/isolinux/{vmlinuz,initrd.img} /var/lib/tftpboot/<br>cp /misc/cd/isolinux/isolinux.cfg  /var/lib/tftpboot/pxelinux.cfg/default</p>
<p>文件列表如下：</p>
<p>/var/lib/tftpboot/<br>├── initrd.img<br>├── menu.c32<br>├── pxelinux.0<br>├── pxelinux.cfg<br>│    └── default<br>└── vmlinuz</p>
<p>准备启动菜单<br>    Vim /var/lib/tftpboot/pxelinux.cfg/default<br>    default menu.c32<br>    timeout 600<br>    menu title PXE INSTALL MENU<br>    label auto<br>        menu label Auto Install CentOS 7<br>        kernel vmlinuz<br>        append initrd=initrd.img ks=<a href="http://192.168.100.100/ks/centos7.cfg" target="_blank" rel="noopener">http://192.168.100.100/ks/centos7.cfg</a><br>    label manual<br>        menu label Manual Install CentOS 7<br>        kernel vmlinuz<br>        append initrd=initrd.img inst.repo=<a href="http://192.168.100.100/centos/7" target="_blank" rel="noopener">http://192.168.100.100/centos/7</a><br>    label local<br>        menu default<br>        menu label ^Boot from local drive<br>        localboot 0xffff</p>
<p>安装前准备：关闭防火墙和SELINUX，DHCP服务器静态IP</p>
<h5 id="1-安装相应软件包"><a href="#1-安装相应软件包" class="headerlink" title="1 安装相应软件包"></a>1 安装相应软件包</h5><pre><code>yum install dhcp httpd tftp-server syslinux chkconfig tftp on
chkconfig xinetd on 
chkconfig httpd on 
chkconfig dhcpd on 
service httpd start 
service xneted start</code></pre><h5 id="2-准备Yum-源和相关目录"><a href="#2-准备Yum-源和相关目录" class="headerlink" title="2 准备Yum 源和相关目录"></a>2 准备Yum 源和相关目录</h5><pre><code>mkdir -pv /var/www/html/centos/{6,ks} 
mount /dev/sr0 /var/www/html/centos/6</code></pre><h5 id="3-准备kickstart文件"><a href="#3-准备kickstart文件" class="headerlink" title="3 准备kickstart文件"></a>3 准备kickstart文件</h5><pre><code>/var/www/html/centos/ks/centos6.cfg</code></pre><p>注意权限：<br>    chmod 644 /var/www/html/centos/ks/centos6.cfg</p>
<h5 id="4-准备相关的启动文件"><a href="#4-准备相关的启动文件" class="headerlink" title="4 准备相关的启动文件"></a>4 准备相关的启动文件</h5><pre><code>mkdir /var/lib/tftpboot/pxelinux.cfg/
cp /usr/share/syslinux/pxelinux.0 /var/lib/tftpboot/ 
cd /misc/cd/images/pxeboot/
cp vmlinuz initrd.img /var/lib/tftpboot 
cd /misc/cd/isolinux/
cp boot.msg vesamenu.c32 splash.jpg /var/lib/tftpboot</code></pre><h5 id="5-准备启动菜单文件"><a href="#5-准备启动菜单文件" class="headerlink" title="5 准备启动菜单文件"></a>5 准备启动菜单文件</h5><pre><code>cp /misc/cd/isolinux/isolinux.cfg /var/lib/tftpboot/pxelinux.cfg/default
vim /var/lib/tftpboot/pxelinux.cfg/default 
default vesamenu.c32 指定菜单风格 
#prompt 1
timeout 600 
display boot.msg
menu background splash.jpg
menu title Welcome to wang CentOS 6 
menu color border 0 #ffffffff #00000000 
menu color sel 7 #ffffffff #ff000000 
menu color title 0 #ffffffff #00000000 
menu color tabmsg 0 #ffffffff #00000000 
menu color unsel 0 #ffffffff #00000000 
menu color hotsel 0 #ff000000 #ffffffff 
menu color hotkey 7 #ffffffff #ff000000 
menu color scrollbar 0 #ffffffff #00000000
label auto
    menu label ^Automatic Install Centos6
    kernel vmlinuz
    append initrd=initrd.img ks=http://192.168.100.100/centos/ks/centos6.cfg
label manual
    menu label ^Manual Install Centos
    kernel vmlinuz
    append initrd=initrd.img inst.repo=http://192.168.100.100/centos/6
label local
    menu default
    menu label Boot from ^local drive
    localboot 0xffff</code></pre><p>目录结构如下：<br>    tree /var/lib/tftpboot/<br>    /var/lib/tftpboot/<br>    ├── boot.msg<br>    ├── initrd.img<br>    ├── pxelinux.0<br>    ├── pxelinux.cfg<br>    │    └── default<br>    ├── splash.jpg<br>    ├── vesamenu.c32<br>    └── vmlinuz</p>
<p>​    1 directory, 7 files</p>
<h5 id="6-配置dhcp服务"><a href="#6-配置dhcp服务" class="headerlink" title="6 配置dhcp服务"></a>6 配置dhcp服务</h5><p>​    cp /usr/share/doc/dhcp-4.1.1/dhcpd.conf.sample /etc/dhcp/dhcpd.conf<br>    vim /etc/dhcp/dhcpd.conf<br>    option domain-name “magedu.com”;<br>    option domain-name-servers 192.168.100.1;<br>    subnet 192.168.100.0 netmask 255.255.255.0 {<br>        range 192.168.100.1 192.168.100.200;<br>        option routers 192.168.100.1;<br>        filename “pxelinux.0”;<br>        next-server 192.168.100.100;<br>    }</p>
<p>​    service dhcpd start</p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ops</tag>
      </tags>
  </entry>
  <entry>
    <title>运维自动化之ANSIBLE(一)</title>
    <url>/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E4%B9%8BANSIBLE/</url>
    <content><![CDATA[<h3 id="运维自动化发展历程及技术应用"><a href="#运维自动化发展历程及技术应用" class="headerlink" title="运维自动化发展历程及技术应用"></a>运维自动化发展历程及技术应用</h3><h5 id="企业实际应用场景分析"><a href="#企业实际应用场景分析" class="headerlink" title="企业实际应用场景分析"></a>企业实际应用场景分析</h5><p>Dev开发环境</p>
<p>使用者:程序员</p>
<p>功能:程序员开发软件，测试BUG的环境</p>
<p>管理者:程序员</p>
<p>测试环境</p>
<p>使用者:QA测试工程师</p>
<p>功能:测试经过Dev环境测试通过的软件的功能</p>
<p>管理者:运维</p>
<p>说明:测试环境往往有多套,测试环境满足测试功能即可，不宜过多</p>
<p>1、测试人员希望测试环境有多套,公司的产品多产品线并发，即多个版本，意味着多个版本同步测试</p>
<p>2、通常测试环境有多少套和产品线数量保持一样</p>
<p>发布环境:代码发布机，有些公司为堡垒机（安全屏障）</p>
<p>使用者:运维</p>
<p>功能:发布代码至生产环境</p>
<p>管理者:运维（有经验）</p>
<p>发布机:往往需要有2台（主备）</p>
<p>生产环境</p>
<p>使用者:运维，少数情况开放权限给核心开发人员，极少数公司将权限完全开放给开发人员并其维护</p>
<p>功能:对用户提供公司产品的服务</p>
<p>管理者:只能是运维</p>
<p>生产环境服务器数量:一般比较多，且应用非常重要。往往需要自动工具协助部署配置应用<br>灰度环境（生产环境的一部分）</p>
<p>使用者:运维</p>
<p>功能:在全量发布代码前将代码的功能面向少量精准用户发布的环境,可基于主机或用户执行灰度发布</p>
<p>案例:共100台生产服务器，先发布其中的10台服务器，这10台服务器就是灰度服务器</p>
<p>管理者:运维</p>
<p>灰度环境:往往该版本功能变更较大，为保险起见特意先让一部分用户优化体验该功能，待这部分用户使用没有重大问题的时候，再全量发布至所有服务器</p>
<h5 id="程序发布"><a href="#程序发布" class="headerlink" title="程序发布"></a>程序发布</h5><p>程序发布要求:</p>
<p>不能导致系统故障或造成系统完全不可用</p>
<p>不能影响用户体验</p>
<p>预发布验证:</p>
<p>新版本的代码先发布到服务器（跟线上环境配置完全相同，只是未接入到调度器）</p>
<p>灰度发布:</p>
<p>基于主机，用户，业务</p>
<p>发布路径:</p>
<pre><code>/webapp/markupzh 

/webapp/markupzh-1.1 

/webapp/markupzh-1.2</code></pre><p>发布过程:</p>
<p>在调度器上下线一批主机(标记为maintanance状态) –&gt; 关闭服务 –&gt; 部署新版本的应用程序 –&gt; 启动服务 –&gt; 在调度器上启用这一批服务器</p>
<p>自动化灰度发布:</p>
<p>脚本、发布平台</p>
<h5 id="自动化运维应用场景"><a href="#自动化运维应用场景" class="headerlink" title="自动化运维应用场景"></a>自动化运维应用场景</h5><p>文件传输</p>
<p>应用部署</p>
<p>配置管理</p>
<p>任务流编排</p>
<h5 id="常用自动化运维工具"><a href="#常用自动化运维工具" class="headerlink" title="常用自动化运维工具"></a>常用自动化运维工具</h5><pre><code>Ansible:python,Agentless,中小型应用环境

Saltstack:python，一般需部署agent，执行效率更高

Puppet:ruby, 功能强大,配置复杂，重型,适合大型环境

Fabric:python，agentless

Chef: ruby,国内应用少

Cfengine

func</code></pre><h3 id="企业级自动化运维工具应用实战ansible"><a href="#企业级自动化运维工具应用实战ansible" class="headerlink" title="企业级自动化运维工具应用实战ansible"></a>企业级自动化运维工具应用实战ansible</h3><p>公司计划在年底做一次大型市场促销活动，全面冲刺下交易额，为明年的上市做准备。公司要求各业务组对年底大促做准备，运维部要求所有业务容量进行三倍的扩容，并搭建出多套环境可以共开发和测试人员做测试，运维老大为了在年底有所表现，要求运维部门同学尽快实现，接到这个任务时，有没有更快的解决方案？</p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>模块化:调用特定的模块，完成特定任务</p>
<p>有Paramiko，PyYAML，Jinja2（模板语言）三个关键模块</p>
<p>支持自定义模块</p>
<p>基于Python语言实现</p>
<p>部署简单，基于python和SSH(默认已安装)，agentless</p>
<p>安全，基于OpenSSH</p>
<p>支持playbook编排任务</p>
<p>幂等性:一个任务执行1遍和执行n遍效果一样，不因重复执行带来意外情况</p>
<p>无需代理不依赖PKI（无需ssl）</p>
<p>可使用任何编程语言写模块</p>
<p>YAML格式，编排任务，支持丰富的数据结构</p>
<p>较强大的多层解决方案</p>
<h4 id="Ansible主要组成部分"><a href="#Ansible主要组成部分" class="headerlink" title="Ansible主要组成部分"></a>Ansible主要组成部分</h4><p>ANSIBLE PLAYBOOKS:任务剧本（任务集），编排定义Ansible任务集的配置文件，由Ansible顺序依次执行，通常是JSON格式的YML文件</p>
<p>INVENTORY:Ansible管理主机的清单/etc/anaible/hosts</p>
<p>MODULES:Ansible执行命令的功能模块，多数为内置核心模块，也可自定义</p>
<p>PLUGINS:模块功能的补充，如连接类型插件、循环插件、变量插件、过滤插件等，该功能不常用</p>
<p>API:供第三方程序调用的应用程序编程接口</p>
<p>ANSIBLE:组合INVENTORY、API、MODULES、PLUGINS的绿框，可以理解为是ansible命令工具，其为核心执行工具</p>
<p>Ansible命令执行来源:</p>
<pre><code>USER，普通用户，即SYSTEM ADMINISTRATOR

CMDB（配置管理数据库） API 调用

PUBLIC/PRIVATE CLOUD API调用

USER-&gt; Ansible Playbook -&gt; Ansibile</code></pre><p>利用ansible实现管理的方式:</p>
<pre><code>Ad-Hoc 即ansible命令，主要用于临时命令使用场景

Ansible-playbook 主要用于长期规划好的，大型项目的场景，需要有前提的规划</code></pre><p>Ansible-playbook（剧本）执行过程:</p>
<pre><code>将已有编排好的任务集写入Ansible-Playbook

通过ansible-playbook命令分拆任务集至逐条ansible命令，按预定规则逐条执行</code></pre><p>Ansible主要操作对象:</p>
<pre><code>HOSTS主机

NETWORKING网络设备</code></pre><p>注意事项</p>
<p>执行ansible的主机一般称为主控端，中控，master或堡垒机</p>
<p>主控端Python版本需要2.6或以上</p>
<p>被控端Python版本小于2.4需要安装python-simplejson</p>
<p>被控端如开启SELinux需要安装libselinux-python</p>
<p>windows不能做为主控端</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><h5 id="rpm包安装-EPEL源"><a href="#rpm包安装-EPEL源" class="headerlink" title="rpm包安装: EPEL源"></a>rpm包安装: EPEL源</h5><p><code>yum install ansible</code>    </p>
<p>编译安装:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum -y install python-jinja2 PyYAML python-paramiko python-babel python-crypto</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tar xf ansible-1.5.4.tar.gz </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> ansible-1.5.4 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> python setup.py build </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> python setup.py install </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdir /etc/ansible</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cp -r examples/* /etc/ansible</span></span><br></pre></td></tr></table></figure>

<h5 id="Git方式"><a href="#Git方式" class="headerlink" title="Git方式:"></a>Git方式:</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> git <span class="built_in">clone</span> git://github.com/ansible/ansible.git --recursive <span class="built_in">cd</span> ./ansible</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">source</span> ./hacking/env-setup</span></span><br></pre></td></tr></table></figure>

<h5 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装:"></a>pip安装:</h5><p>pip是安装Python包的管理器，类似yum </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum install python-pip python-devel</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yum install gcc glibc-devel zibl-devel rpm-bulid openssl-devel pip install --upgrade pip</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> pip install ansible --upgrade</span></span><br></pre></td></tr></table></figure>

<h5 id="确认安装"><a href="#确认安装" class="headerlink" title="确认安装:"></a>确认安装:</h5><p><code>ansible --version</code></p>
<h4 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h4><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><pre><code>/etc/ansible/ansible.cfg 主配置文件，配置ansible工作特性                     

/etc/ansible/hosts 主机清单

/etc/ansible/roles/ 存放角色的目录</code></pre><h5 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h5><pre><code>/usr/bin/ansible 主程序，临时命令执行工具 

/usr/bin/ansible-doc 查看配置文档，模块功能查看工具 

/usr/bin/ansible-galaxy 下载/上传优秀代码或Roles模块的官网平台

/usr/bin/ansible-playbook 定制自动化任务，编排剧本工具

/usr/bin/ansible-pull 远程执行命令的工具

/usr/bin/ansible-vault 文件加密工具 

/usr/bin/ansible-console 基于Console界面与用户交互的执行工具</code></pre><h5 id="主机清单inventory"><a href="#主机清单inventory" class="headerlink" title="主机清单inventory"></a>主机清单inventory</h5><p>Inventory 主机清单</p>
<p>ansible的主要功用在于批量主机操作，为了便捷地使用其中的部分主机，可以在inventory file中将其分组命名</p>
<p>默认的inventory file为/etc/ansible/hosts</p>
<p>inventory file可以有多个，且也可以通过Dynamic Inventory来动态生成</p>
<p>/etc/ansible/hosts文件格式</p>
<p>inventory文件遵循INI文件风格，中括号中的字符为组名。可以将同一个主机同时归并到多个不同的组中；此外，当如若目标主机使用了非默认的SSH端口，还可以在主机名称之后使用冒号加端口号来标明</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ntp.markupzh.com</span><br><span class="line">[webservers]</span><br><span class="line">www1.markupzh.com:2222</span><br><span class="line">www2.markupzh.com</span><br><span class="line">[dbservers]</span><br><span class="line">db1.markupzh.com</span><br><span class="line">db2.markupzh.com</span><br><span class="line">db3.markupzh.com</span><br></pre></td></tr></table></figure>

<p>如果主机名称遵循相似的命名模式，还可以使用列表的方式标识各主机</p>
<p>示例:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[websrvs]</span><br><span class="line">www[01:100].example.com</span><br><span class="line">[dbsrvs] </span><br><span class="line">db-[a:f].example.com</span><br></pre></td></tr></table></figure>

<h5 id="ansible-配置文件"><a href="#ansible-配置文件" class="headerlink" title="ansible 配置文件"></a>ansible 配置文件</h5><p>Ansible 配置文件/etc/ansible/ansible.cfg （一般保持默认）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[defaults]</span><br><span class="line"><span class="meta">#</span><span class="bash">inventory = /etc/ansible/hosts <span class="comment"># 主机列表配置文件</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">library = /usr/share/my_modules/ <span class="comment"># 库文件存放目录</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">remote_tmp = <span class="variable">$HOME</span>/.ansible/tmp <span class="comment">#临时py命令文件存放在远程主机目录</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">local_tmp = <span class="variable">$HOME</span>/.ansible/tmp <span class="comment"># 本机的临时命令执行目录</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">forks = 5	<span class="comment"># 默认并发数</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">sudo_user = root <span class="comment"># 默认sudo 用户</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">ask_sudo_pass = True <span class="comment">#每次执行ansible命令是否询问ssh密码</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">ask_pass = True</span></span><br><span class="line"><span class="meta">#</span><span class="bash">remote_port = 22</span></span><br><span class="line"><span class="meta">#</span><span class="bash">host_key_checking = False <span class="comment"># 检查对应服务器的host_key，建议取消注释 #log_path=/var/log/ansible.log #日志文件</span></span></span><br></pre></td></tr></table></figure>

<h4 id="ansible系列命令"><a href="#ansible系列命令" class="headerlink" title="ansible系列命令"></a>ansible系列命令</h4><p>ansible ansible-doc </p>
<p>ansible-playbook </p>
<p>ansible-vault </p>
<p>ansible-console     </p>
<p>ansible-galaxy </p>
<p>ansible-pull</p>
<p>ansible-doc: 显示模块帮助</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible-doc options</span><br><span class="line">-a	显示所有模块的文档</span><br><span class="line">-l, --list	列出可用模块</span><br><span class="line">-s, --snippet显示指定模块的playbook片段</span><br></pre></td></tr></table></figure>

<h5 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h5><p>ansible-doc –l 列出所有模块<br>ansible-doc ping 查看指定模块帮助用法<br>ansible-doc –s ping 查看指定模块帮助用法</p>
<p>ansible通过ssh实现配置管理、应用部署、任务执行等功能，建议配置ansible端能基于密钥认证的方式联系各被管理节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible &lt;host-pattern&gt; -m module_name</span><br><span class="line">--version 显示版本</span><br><span class="line">-m module	指定模块，默认为command</span><br><span class="line">-v 详细过程 –vv -vvv更详细</span><br><span class="line">--list-hosts 显示主机列表，可简写 --list</span><br><span class="line">-k, --ask-pass	提示输入ssh连接密码，默认Key验证</span><br><span class="line">-K, --ask-become-pass 提示输入sudo时的口令</span><br><span class="line">-C, --check	检查，并不执行</span><br><span class="line">-T, --timeout=TIMEOUT 执行命令的超时时间，默认10s </span><br><span class="line">-u, --user=REMOTE_USER 执行远程执行的用户 </span><br><span class="line">-b, --become 代替旧版的sudo 切换</span><br></pre></td></tr></table></figure>

<h5 id="ansible的Host-pattern"><a href="#ansible的Host-pattern" class="headerlink" title="ansible的Host-pattern"></a>ansible的Host-pattern</h5><p>匹配主机的列表</p>
<p>All :表示所有Inventory中的所有主机 </p>
<pre><code>ansible all –m ping</code></pre><p><code>*</code>:通配符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible "*" -m ping</span><br><span class="line">ansible 192.168.1.* -m ping</span><br><span class="line">ansible "*srvs" -m ping</span><br></pre></td></tr></table></figure>

<p>或关系</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible "websrvs:appsrvs" -m ping</span><br><span class="line">ansible "192.168.1.10:192.168.1.20"  -m ping</span><br></pre></td></tr></table></figure>

<p>逻辑与</p>
<p><code>ansible &quot;websrvs:&amp;dbsrvs&quot; –m ping</code></p>
<p>在websrvs组并且在dbsrvs组中的主机</p>
<p>逻辑非</p>
<p><code>ansible &#39;websrvs:!dbsrvs&#39; –m ping</code></p>
<p>在websrvs组，但不在dbsrvs组中的主机注意:此处为单引号</p>
<p>综合逻辑</p>
<p><code>ansible &#39;websrvs:dbsrvs:&amp;appsrvs:!ftpsrvs&#39; –m ping</code></p>
<p>正则表达式</p>
<p><code>ansible &quot;websrvs:&amp;dbsrvs&quot; –m ping</code></p>
<p><code>ansible &quot;~(web|db).*\.markupzh\.com&quot; –m ping</code></p>
<h4 id="ansible命令执行过程"><a href="#ansible命令执行过程" class="headerlink" title="ansible命令执行过程"></a>ansible命令执行过程</h4><pre><code>1. 加载自己的配置文件 默认/etc/ansible/ansible.cfg

2. 加载自己对应的模块文件，如command

3. 通过ansible将模块或命令生成对应的临时py文件，并将该 文件传输至远程服务器的对应执行用户$HOME/.ansible/tmp/ansible-tmp-数字/XXX.PY文件

4. 给文件+x执行

5. 执行并返回结果

6. 删除临时py文件，sleep 0退出

执行状态:

    绿色:执行成功并且不需要做改变的操作

    黄色:执行成功并且对目标主机做变更

    红色:执行失败</code></pre><h4 id="ansible使用示例"><a href="#ansible使用示例" class="headerlink" title="ansible使用示例"></a>ansible使用示例</h4><p>以mark用户执行ping存活检测 </p>
<p><code>ansible all -m ping -u mark -k</code></p>
<p>以mark sudo至root执行ping存活检测 </p>
<p><code>ansible all -m ping -u mark –b -k</code></p>
<p>以mark sudo至markupzh用户执行ping存活检测</p>
<p><code>ansible all -m ping -u mark –b -k --become-user markupzh</code></p>
<p>以mark sudo至root用户执行ls</p>
<p><code>ansible all -m command -u mark --become-user=root -a &#39;ls /root&#39; -b –k -K</code></p>
<h4 id="ansible常用模块"><a href="#ansible常用模块" class="headerlink" title="ansible常用模块"></a>ansible常用模块</h4><p>Command:在远程主机执行命令，默认模块，可忽略-m选项</p>
<p><code>ansible srvs -m command -a &#39;service vsftpd start&#39;</code></p>
<p><code>ansible srvs -m command -a &#39;echo markupzh |passwd --stdin mark&#39;</code>不成功</p>
<p>此命令不支持 $VARNAME &lt; &gt; | ; &amp; 等，用shell模块实现</p>
<p>Shell:和command相似，用shell执行命令</p>
<p><code>ansible srv -m shell -a &#39;echo markupzh |passwd –stdin mark&#39;</code></p>
<p>调用bash执行命令 类似 cat /tmp/stanley.md | awk -F’|’ ‘{print $1,$2}’ &amp;&gt; /tmp/example.txt 这些复杂命令，即使使用shell也可能会失败，解决办法:写到脚本时，copy到远程，执行，再把需要的结果拉回执行命令的机器</p>
<p><strong>Script</strong>:运行脚本</p>
<p><code>-a &quot;/PATH/TO/SCRIPT_FILE&quot;</code></p>
<p><code>snsible websrvs -m script -a f1.sh</code></p>
<p><strong>Copy</strong>:从服务器复制文件到客户端</p>
<p><code>ansible srv -m copy -a &quot;src=/root/f1.sh dest=/tmp/f2.sh owner=mark mode=600 backup=yes&quot;</code></p>
<p>如目标存在，默认覆盖，此处指定先备份</p>
<p><code>ansible srv -m copy -a &quot;content=&#39;test content\n&#39; dest=/tmp/f1.txt&quot;</code></p>
<p>利用内容，直接生成目标文件</p>
<p><strong>Fetch</strong>:从客户端取文件至服务器端，copy相反，目录可先tar</p>
<p><code>ansible srv -m fetch -a &#39;src=/root/a.sh dest=/data/scripts&#39;</code></p>
<p><strong>File</strong>:设置文件属性</p>
<p><code>ansible srv -m file -a &quot;path=/root/a.sh owner=mark mode=755&quot;</code></p>
<p><code>ansible web -m file -a &#39;src=/app/testfile dest=/app/testfile-link state=link&#39;</code></p>
<p><strong>Hostname</strong>:管理主机名</p>
<p><code>ansible node1 -m hostname -a &quot;name=websrv&quot;</code></p>
<p><strong>Cron</strong>:计划任务</p>
<p>支持时间:minute，hour，day，month，weekday</p>
<p><code>ansible srv -m cron -a &quot;minute=*/5 job=&#39;/usr/sbin/ntpdate</code></p>
<p><code>172.16.0.1 &amp;&gt;/dev/null&#39; name=Synctime&quot;</code>创建任务</p>
<p><code>ansible srv -m cron -a &#39;state=absent name=Synctime&#39;</code> 删除任务</p>
<p><strong>Yum</strong>:管理包</p>
<p><code>ansible srv -m yum -a &#39;name=httpd state=latest&#39;</code> 安装</p>
<p><code>ansible srv -m yum -a &#39;name=httpd state=absent&#39;</code> 删除</p>
<p><strong>Service</strong>:管理服务</p>
<p><code>ansible srv -m service -a &#39;name=httpd state=stopped&#39;</code></p>
<p><code>ansible srv -m service -a &#39;name=httpd state=started&#39;</code></p>
<p><code>ansible srv –m service –a &#39;name=httpd state=reloaded&#39;</code></p>
<p><code>ansible srv -m service -a &#39;name=httpd state=restarted&#39;</code></p>
<p><strong>User</strong>:管理用户</p>
<p><code>ansible srv -m user -a &#39;name=user1 comment=&quot;test user&quot; uid=2048 home=/app/user1 group=root&#39;</code></p>
<p><code>ansible srv -m user -a &#39;name=sysuser1 system=yes home=/app/sysuser1 &#39;</code></p>
<p><code>ansible srv -m user -a &#39;name=user1 state=absent remove=yes&#39;</code>删除用户及家目录等数据</p>
<p><strong>Group</strong>:管理组</p>
<p><code>ansible srv -m group -a &quot;name=testgroup system=yes&quot;</code></p>
<p><code>ansible srv -m group -a &quot;name=testgroup state=absent&quot;</code></p>
<h4 id="ansible系列命令-1"><a href="#ansible系列命令-1" class="headerlink" title="ansible系列命令"></a>ansible系列命令</h4><p><code>ansible-galaxy</code></p>
<p>连接 <a href="https://galaxy.ansible.com" target="_blank" rel="noopener">https://galaxy.ansible.com</a> 下载相应的roles</p>
<p>列出所有已安装的galaxy</p>
<p><code>ansible-galaxy list</code></p>
<p>安装galaxy</p>
<p><code>ansible-galaxy install geerlingguy.redis</code></p>
<p>删除galaxy</p>
<p><code>ansible-galaxy remove geerlingguy.redis</code></p>
<p>ansible-pull</p>
<p>推送命令至远程，效率无限提升，对运维要求较高</p>
<h5 id="Ansible-playbook"><a href="#Ansible-playbook" class="headerlink" title="Ansible-playbook"></a>Ansible-playbook</h5><p>ansible-playbook hello.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">cat</span> <span class="string">hello.yml</span></span><br><span class="line"><span class="comment">#hello world yml file</span></span><br><span class="line"><span class="string">-hosts:</span> <span class="string">websrvs</span></span><br><span class="line">    <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">tasks:</span></span><br><span class="line">    <span class="string">-name:</span> <span class="string">hello</span> <span class="string">world</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">/usr/bin/wall</span> <span class="string">hello</span> <span class="string">world</span></span><br></pre></td></tr></table></figure>

<h5 id="Ansible-vault"><a href="#Ansible-vault" class="headerlink" title="Ansible-vault"></a>Ansible-vault</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">功能:管理加密解密yml文件</span></span><br><span class="line"><span class="string">ansible-vault</span> <span class="string">[create|decrypt|edit|encrypt|rekey|view]</span></span><br><span class="line"><span class="string">ansible-vault</span> <span class="string">encrypt</span> <span class="string">hello.yml</span> <span class="string">加密</span></span><br><span class="line"><span class="string">ansible-vault</span> <span class="string">decrypt</span> <span class="string">hello.yml</span> <span class="string">解密</span></span><br><span class="line"><span class="string">ansible-vault</span> <span class="string">view</span> <span class="string">hello.yml</span> <span class="string">查看</span></span><br><span class="line"><span class="string">ansible-vault</span> <span class="string">edit</span> <span class="string">hello.yml</span> <span class="string">编辑加密文件</span></span><br><span class="line"><span class="string">ansible-vault</span> <span class="string">rekey</span> <span class="string">hello.yml</span> <span class="string">修改口令</span></span><br><span class="line"><span class="string">ansible-vault</span> <span class="string">create</span> <span class="string">new.yml</span> <span class="string">创建新文件</span></span><br></pre></td></tr></table></figure>

<h5 id="Ansible-console"><a href="#Ansible-console" class="headerlink" title="Ansible-console"></a>Ansible-console</h5><p>Ansible-console:2.0+新增，可交互执行命令，支持tab</p>
<p><code>root@test (2)[f:10] $</code></p>
<p>执行用户@当前操作的主机组 (当前组的主机数量)[f:并发数]$</p>
<p>设置并发数: forks n 例如: forks 10</p>
<p>切换组: cd 主机组 例如: cd web</p>
<p>列出当前组主机列表: list</p>
<p>列出所有的内置命令: ?或help</p>
<p>示例:    </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@all (2)[f:5]$ list </span><br><span class="line">root@all (2)[f:5]$ cd appsrvs </span><br><span class="line">root@appsrvs (2)[f:5]$ list</span><br><span class="line">root@appsrvs (2)[f:5]$ yum name=httpd state=present </span><br><span class="line">root@appsrvs (2)[f:5]$ service name=httpd state=started</span><br></pre></td></tr></table></figure>

<h5 id="playbook"><a href="#playbook" class="headerlink" title="playbook"></a>playbook</h5><p>playbook是由一个或多个”play”组成的列表</p>
<p>play的主要功能在于将事先归并为一组的主机装扮成事先通过ansible中的task定义好的角色。从根本上来讲，所谓task无非是调用ansible的一个module。将多个play组织在一个playbook中，即可以让它们联同起来按事先编排的机制同唱一台大戏</p>
<p>Playbook采用YAML语言编写</p>
<h4 id="YAML介绍"><a href="#YAML介绍" class="headerlink" title="YAML介绍"></a>YAML介绍</h4><p>YAML是一个可读性高的用来表达资料序列的格式。YAML参考了其他多种语言，包括:XML、C语言、Python、Perl以及电子邮件格式RFC2822等。Clark Evans在2001年在首次发表了这种语言，另外Ingy döt Net与Oren Ben-Kiki也是这语言的共同设计者</p>
<p>YAML Ain’t Markup Language，即YAML不是XML。不过，在开发的这种语言时，YAML的意思其实是:”Yet Another Markup Language”（仍是一种标记语言）</p>
<p>特性    </p>
<p>YAML的可读性好</p>
<p>YAML和脚本语言的交互性好</p>
<p>YAML使用实现语言的数据类型</p>
<p>YAML有一个一致的信息模型</p>
<p>YAML易于实现</p>
<p>YAML可以基于流来处理</p>
<p>YAML表达能力强，扩展性好</p>
<p>更多的内容及规范参见<a href="http://www.yaml.org" target="_blank" rel="noopener">http://www.yaml.org</a></p>
<h5 id="YAML语法简介"><a href="#YAML语法简介" class="headerlink" title="YAML语法简介"></a>YAML语法简介</h5><p>在单一档案中，可用连续三个连字号(——)区分多个档案。另外，还有选择性的连续三个点号( … )用来表示档案结尾</p>
<p>次行开始正常写Playbook的内容，一般建议写明该Playbook的功能</p>
<p>使用#号注释代码</p>
<p>缩进必须是统一的，不能空格和tab混用</p>
<p>缩进的级别也必须是一致的，同样的缩进代表同样的级别，程序判别配置的级别是通过缩进结合换行来实现的</p>
<p>YAML文件内容是区别大小写的，k/v的值均需大小写敏感</p>
<p>k/v的值可同行写也可换行写。同行使用:分隔</p>
<p>v可是个字符串，也可是另一个列表</p>
<p>一个完整的代码块功能需最少元素需包括 name: task</p>
<p>一个name只能包括一个task</p>
<p>YAML文件扩展名通常为yml或yaml</p>
<p>List:列表，其所有元素均使用”-“打头</p>
<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例:"></a>示例:</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">A</span> <span class="string">list</span> <span class="string">of</span> <span class="string">tasty</span> <span class="string">fruits</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Apple</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Orange</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Strawberry</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Mango</span></span><br></pre></td></tr></table></figure>

<p>Dictionary:字典，通常由多个key与value构成</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">An</span> <span class="string">employee</span> <span class="string">record</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">Example</span> <span class="string">Developer</span></span><br><span class="line"><span class="attr">job:</span> <span class="string">Developer</span></span><br><span class="line"><span class="attr">skill:</span> <span class="string">Elite</span></span><br></pre></td></tr></table></figure>

<p>也可以将key:value放置于{}中进行表示，用,分隔多个key:value</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">An</span> <span class="string">employee</span> <span class="string">record</span></span><br><span class="line"><span class="string">&#123;name:</span> <span class="string">Example</span> <span class="string">Developer,</span> <span class="attr">job:</span> <span class="string">Developer,</span> <span class="attr">skill:</span> <span class="string">Elite&#125;</span></span><br></pre></td></tr></table></figure>

<p>YAML语法</p>
<p>YAML的语法和其他高阶语言类似，并且可以简单表达清单、散列表、标量等数据结构。其结构（Structure）通过空格来展示，序列（Sequence）里的项用”-“来代表，Map里的键值对用”:”分隔</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">John</span> <span class="string">Smith</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">41</span></span><br><span class="line"><span class="attr">gender:</span> <span class="string">Male</span> </span><br><span class="line"><span class="attr">spouse:</span></span><br><span class="line">	<span class="attr">name:</span> <span class="string">Jane</span> <span class="string">Smith</span></span><br><span class="line">	<span class="attr">age:</span> <span class="number">37</span></span><br><span class="line">	<span class="attr">gender:</span> <span class="string">Female</span> </span><br><span class="line"><span class="attr">children:</span></span><br><span class="line">	<span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Jimmy</span> <span class="string">Smith</span></span><br><span class="line">	<span class="attr">age:</span> <span class="number">17</span></span><br><span class="line">	<span class="attr">gender:</span> <span class="string">Male</span></span><br><span class="line">	<span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Jenny</span> <span class="string">Smith</span> </span><br><span class="line">	<span class="string">age</span> <span class="number">13</span></span><br><span class="line">	<span class="attr">gender:</span> <span class="string">Female</span></span><br></pre></td></tr></table></figure>

<h4 id="Playbook核心元素"><a href="#Playbook核心元素" class="headerlink" title="Playbook核心元素"></a>Playbook核心元素</h4><p>Hosts  执行的远程主机列表<br>Tasks  任务集<br>Varniables 内置变量或自定义变量在playbook中调用<br>Templates 模板，可替换模板文件中的变量并实现一些简单逻辑的文件<br>Handlers 和notity结合使用，由特定条件触发的操作，满足条件方才执行，否则不执行<br>tags 标签 指定某条任务执行，用于选择运行playbook中的部分代码。ansible具有幂等性，因此会自动跳过没有变化的部分，即便如此，有些代码为测试其确实没有发生变化的时间依然会非常地长。此时，如果确信其没有变化，就可以通过tags跳过此些代码片断<br><code>ansible-playbook –t tagsname useradd.yml</code></p>
<h4 id="playbook基础组件"><a href="#playbook基础组件" class="headerlink" title="playbook基础组件"></a>playbook基础组件</h4><p>Hosts:<br>playbook中的每一个play的目的都是为了让某个或某些主机以某个指定的用户身份执行任务。hosts用于指定要执行指定任务的主机，须事先定义在主机清单中<br>可以是如下形式:<br>​    one.example.com<br>​    one.example.com:two.example.com<br>​    192.168.1.50<br>​    192.168.1.*</p>
<p>Websrvs:dbsrvs   两个组的并集</p>
<p>Websrvs:&amp;dbsrvs   两个组的交集</p>
<p>webservers:!phoenix 在websrvs组，但不在dbsrvs组</p>
<p>示例: - hosts: websrvs:dbsrvs</p>
<p>remote_user: 可用于Host和task中。也可以通过指定其通过sudo的方式在远程主机上执行任务，其可用于play全局或某任务；此外，甚至可以在sudo时使用sudo_user指定sudo时切换的用户</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">websrvs</span></span><br><span class="line">	<span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line">	<span class="string">-name:</span> <span class="string">test</span> <span class="string">connection</span></span><br><span class="line"><span class="attr">ping:</span></span><br><span class="line">	<span class="attr">remote_user:</span> <span class="string">markupzh</span></span><br><span class="line">	<span class="attr">sudo:</span> <span class="literal">yes</span>	<span class="string">默认sudo为root</span></span><br><span class="line">	<span class="string">sudo_user:mark</span>	<span class="string">sudo为mark</span></span><br></pre></td></tr></table></figure>

<p>task列表和action<br>play的主体部分是task list。task list中的各任务按次序逐个在hosts中指定的所有主机上执行，即在所有主机上完成第一个任务后，再开始第二个任务</p>
<p>task的目的是使用指定的参数执行模块，而在模块参数中可以使用变量。模块执行是幂等的，这意味着多次执行是安全的，因为其结果均一致</p>
<p>每个task都应该有其name，用于playbook的执行结果输出，建议其内容尽可能清晰地描述任务执行步骤。如果未提供name，则action的结果将用于输出</p>
<p>playbook基础组件<br>tasks:任务列表</p>
<p>格式:<br>(1) action: module arguments</p>
<p>(2) module: arguments    建议使用</p>
<p>注意:shell和command模块后面跟命令，而非key=value</p>
<p>某任务的状态在运行后为changed时，可通过”notify”通知给相应的 handlers</p>
<p>任务可以通过”tags”打标签，而后可在ansible-playbook命令上使用-t指定进行调用</p>
<p>示例: </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">disable</span> <span class="string">selinux</span></span><br><span class="line">  <span class="attr">command:</span> <span class="string">/sbin/setenforce</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>如果命令或脚本的退出码不为零，可以使用如下方式替代 </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">run</span> <span class="string">this</span> <span class="string">command</span> <span class="string">and</span> <span class="string">ignore</span> <span class="string">the</span> <span class="string">result</span></span><br><span class="line">  <span class="attr">shell:</span> <span class="string">/usr/bin/somecommand</span> <span class="string">||</span> <span class="string">/bin/true</span></span><br></pre></td></tr></table></figure>

<p>或者使用ignore_errors来忽略错误信息:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">run</span> <span class="string">this</span> <span class="string">command</span> <span class="string">and</span> <span class="string">ignore</span> <span class="string">the</span> <span class="string">result</span></span><br><span class="line">  <span class="attr">shell:</span> <span class="string">/usr/bin/somecommand</span></span><br><span class="line">  <span class="attr">ignore_errors:</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h4 id="运行playbook"><a href="#运行playbook" class="headerlink" title="运行playbook"></a>运行playbook</h4><p>运行playbook的方式</p>
<p><code>ansible-playbook &lt;filename.yml&gt; ... [options]</code></p>
<p>常见选项</p>
<p>–check 只检测可能会发生的改变，但不真正执行操作</p>
<p>–list-hosts 列出运行任务的主机</p>
<p>–limit 主机列表 只针对主机列表中的主机执行</p>
<p>-v 显示过程 -vv -vvv 更详细</p>
<p>示例</p>
<p><code>ansible-playbook file.yml --check</code> 只检测 </p>
<p><code>ansible-playbook file.yml</code></p>
<p><code>ansible-playbook file.yml --limit websrvs</code></p>
<h4 id="Playbook与ShellScripts相比较"><a href="#Playbook与ShellScripts相比较" class="headerlink" title="Playbook与ShellScripts相比较"></a>Playbook与ShellScripts相比较</h4><p>SHELL脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装Apache</span></span><br><span class="line">yum install --quiet -y httpd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制配置文件</span></span><br><span class="line">cp /tmp/httpd.conf /etc/httpd/conf/httpd.conf </span><br><span class="line">cp /tmp/vhosts.conf /etc/httpd/conf.d/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动Apache，并设置开机启动 </span></span><br><span class="line">service httpd start </span><br><span class="line">chkconfig httpd on</span><br></pre></td></tr></table></figure>

<p>Playbook定义</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span> </span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"安装Apache"</span></span><br><span class="line">  <span class="attr">yum:</span>  <span class="string">name=httpd</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"复制配置文件"</span></span><br><span class="line">  <span class="attr">copy:</span> <span class="string">src=/tmp/httpd.conf</span> <span class="string">dest=/etc/httpd/conf/</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"复制配置文件"</span></span><br><span class="line">  <span class="attr">copy:</span> <span class="string">src=/tmp/vhosts.conf</span> <span class="string">dest=/etc/httpd/conf.cd/</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"启动Apache，并设置开机启动"</span></span><br><span class="line">  <span class="attr">service:</span> <span class="string">name=httpd</span> <span class="string">state=started</span> <span class="string">enabled=yes</span></span><br></pre></td></tr></table></figure>

<h4 id="Playbook示例"><a href="#Playbook示例" class="headerlink" title="Playbook示例"></a>Playbook示例</h4><p>示例:sysuser.yml创建mysql用户</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">create</span> <span class="string">mysql</span> <span class="string">user</span></span><br><span class="line">	<span class="attr">user:</span> <span class="string">name=mysql</span> <span class="string">system=yes</span> <span class="string">uid=36</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">create</span> <span class="string">a</span> <span class="string">group</span></span><br><span class="line">	<span class="attr">group:</span> <span class="string">name=httpd</span> <span class="string">system=yes</span></span><br></pre></td></tr></table></figure>

<p>示例:httpd.yml安装httpd</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">websrvs</span></span><br><span class="line"><span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">httpd</span></span><br><span class="line">  <span class="attr">yum:</span> <span class="string">name=httpd</span> <span class="string">state=present</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">configure</span> <span class="string">file</span></span><br><span class="line">  <span class="attr">copy:</span> <span class="string">src=files/httpd.conf</span> <span class="string">dest=/etc/httpd/conf/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">start</span> <span class="string">service</span></span><br><span class="line">  <span class="attr">service:</span> <span class="string">name=httpd</span> <span class="string">state=started</span> <span class="string">enabled=yes</span></span><br></pre></td></tr></table></figure>

<h4 id="handlers和notify结合使用触发条件"><a href="#handlers和notify结合使用触发条件" class="headerlink" title="handlers和notify结合使用触发条件"></a>handlers和notify结合使用触发条件</h4><p>Handlers</p>
<p>是task列表，这些task与前述的task并没有本质上的不同,用于当关注的资源发生变化时，才会采取一定的操作</p>
<p>Notify此action可用于在每个play的最后被触发，这样可避免多次有改变发生时每次都执行指定的操作，仅在所有的变化发生完成后一次性地执行指定操作。在notify中列出的操作称为handler，也即notify中调用handler中定义的操作</p>
<h4 id="Playbook中handlers使用"><a href="#Playbook中handlers使用" class="headerlink" title="Playbook中handlers使用"></a>Playbook中handlers使用</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">websrvs</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">httpd</span></span><br><span class="line">    <span class="attr">yum:</span> <span class="string">name=httpd</span> <span class="string">state=present</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">configure</span> <span class="string">file</span></span><br><span class="line">    <span class="attr">copy:</span> <span class="string">src=files/httpd.conf</span> <span class="string">dest=/etc/httpd/conf/</span></span><br><span class="line">    <span class="attr">notify:</span> <span class="string">restart</span> <span class="string">httpd</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ensure</span> <span class="string">apache</span> <span class="string">is</span> <span class="string">running</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">name=httpd</span> <span class="string">state=started</span> <span class="string">enabled=yes</span> <span class="attr">handlers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">restart</span> <span class="string">httpd</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">name=httpd</span> <span class="string">status=restarted</span></span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">websrvs</span></span><br><span class="line"><span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">add</span> <span class="string">group</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">name=nginx</span> <span class="string">state=present</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">add</span> <span class="string">user</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">name=nginx</span> <span class="string">state=present</span> <span class="string">group=nginx</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Nginx</span></span><br><span class="line">  <span class="attr">yum:</span> <span class="string">name=nginx</span> <span class="string">state=present</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">    <span class="attr">copy:</span> <span class="string">src=/root/config.txt</span> <span class="string">dest=/etc/nginx/nginx.conf</span></span><br><span class="line">    <span class="attr">notify:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Restart</span> <span class="string">Nginx</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Check</span> <span class="string">Nginx</span> <span class="string">Process</span> </span><br><span class="line"><span class="attr">handlers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Restart</span> <span class="string">Nginx</span></span><br><span class="line">  <span class="attr">service:</span> <span class="string">name=nginx</span> <span class="string">state=restarted</span> <span class="string">enabled=yes</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Check</span> <span class="string">Nginx</span> <span class="string">process</span></span><br><span class="line">  <span class="attr">shell:</span> <span class="string">killall</span> <span class="number">-0</span> <span class="string">nginx</span> <span class="string">&gt;</span> <span class="string">/tmp/nginx.log</span></span><br></pre></td></tr></table></figure>

<h4 id="Playbook中tags使用"><a href="#Playbook中tags使用" class="headerlink" title="Playbook中tags使用"></a>Playbook中tags使用</h4><p>示例:httpd.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">websrvs</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span> </span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">httpd</span></span><br><span class="line">      <span class="attr">yum:</span> <span class="string">name=httpd</span> <span class="string">state=present</span></span><br><span class="line">      </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">configure</span> <span class="string">file</span></span><br><span class="line">      <span class="attr">copy:</span> <span class="string">src=files/httpd.conf</span> <span class="string">dest=/etc/httpd/conf/</span></span><br><span class="line">      <span class="attr">tags:</span> <span class="string">conf</span></span><br><span class="line"></span><br><span class="line"> 	<span class="bullet">-</span> <span class="attr">name:</span> <span class="string">start</span> <span class="string">httpd</span> <span class="string">service</span></span><br><span class="line"> 	<span class="attr">tags:</span> <span class="string">service</span></span><br><span class="line"> 	<span class="attr">service:</span> <span class="string">name=httpd</span> <span class="string">state=started</span> <span class="string">enabled=yes</span></span><br><span class="line">  <span class="string">ansible-playbook</span> <span class="string">–t</span> <span class="string">conf</span> <span class="string">httpd.yml</span></span><br></pre></td></tr></table></figure>

<h4 id="Playbook中变量使用"><a href="#Playbook中变量使用" class="headerlink" title="Playbook中变量使用"></a>Playbook中变量使用</h4><p>变量名:</p>
<p>仅能由字母、数字和下划线组成，且只能以字母开头</p>
<p>变量来源:</p>
<p>1 ansible setup facts 远程主机的所有变量都可直接调用</p>
<p>2 在/etc/ansible/hosts中定义</p>
<p>普通变量:主机组中主机单独定义，优先级高于公共变量公共（组）变量:针对主机组中所有主机定义统一变量</p>
<p>3 通过命令行指定变量，优先级最高</p>
<p>ansible-playbook –e varname=value</p>
<p>4 在playbook中定义<br>  vars:<br>​    -    var1: value1<br>​    -    var2: value2</p>
<p>5 在独立的变量YAML文件中定义</p>
<p>6 在role中定义<br>变量命名<br>变量名仅能由字母、数字和下划线组成，且只能以字母开头</p>
<p>变量定义:key=value<br>示例:http_port=80</p>
<p>变量调用方式:<br>​<br>通过 调用变量，且变量名前后必须有空格，有时用”“才生效</p>
<p>ansible-playbook –e 选项指定<br><code>ansible-playbook test.yml -e &quot;hosts=www user=markupzh&quot;</code></p>
<p>示例:使用setup变量</p>
<p>var.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">websrvs</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">create</span> <span class="string">log</span> <span class="string">file</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">name=/var/log/</span> <span class="string">&#123;&#123;</span> <span class="string">ansible_fqdn</span> <span class="string">&#125;&#125;</span> <span class="string">state=touch</span></span><br><span class="line"></span><br><span class="line"><span class="string">ansible-playbook</span> <span class="string">var.yml</span></span><br></pre></td></tr></table></figure>
<p>示例:变量</p>
<p>var.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">websrvs</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span> </span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install</span> <span class="string">package</span></span><br><span class="line">    <span class="attr">yum:</span> <span class="string">name=&#123;&#123;</span> <span class="string">pkname</span> <span class="string">&#125;&#125;</span> <span class="string">state=present</span></span><br><span class="line"></span><br><span class="line"><span class="string">ansible-playbook</span> <span class="string">–e</span> <span class="string">pkname=httpd</span> <span class="string">var.yml</span></span><br></pre></td></tr></table></figure>

<p>示例:变量</p>
<p>var.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">websrvs</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span> </span><br><span class="line">  <span class="attr">vars:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">username:</span> <span class="string">user1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">groupname:</span> <span class="string">group1</span> </span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">create</span> <span class="string">group</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">name=&#123;&#123;</span> <span class="string">groupname</span> <span class="string">&#125;&#125;</span> <span class="string">state=present</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">create</span> <span class="string">user</span></span><br><span class="line">	  <span class="attr">user:</span> <span class="string">name=&#123;&#123;</span> <span class="string">username</span> <span class="string">&#125;&#125;</span> <span class="string">state=present</span></span><br><span class="line"></span><br><span class="line"><span class="string">ansible-playbook</span> <span class="string">var.yml</span></span><br><span class="line"><span class="string">ansible-playbook</span> <span class="string">-e</span> <span class="string">"username=user2 groupname=group2"</span>  <span class="string">var2.yml</span></span><br></pre></td></tr></table></figure>

<p>主机变量</p>
<p>可以在inventory中定义主机时为其添加主机变量以便于在playbook中使用</p>
<p>示例:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[websrvs]</span><br><span class="line">www1.markupzh.com http_port=80 maxRequestsPerChild=808 www2.markupzh.com http_port=8080 maxRequestsPerChild=909</span><br></pre></td></tr></table></figure>

<p>组变量</p>
<p>组变量是指赋予给指定组内所有主机上的在playbook中可用的变量</p>
<p>示例:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[websrvs]</span><br><span class="line">www1.markupzh.com</span><br><span class="line">www2.markupzh.com</span><br><span class="line">[websrvs:vars]</span><br><span class="line">ntp_server=ntp.markupzh.com nfs_server=nfs.markupzh.com</span><br></pre></td></tr></table></figure>

<p>普通变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[websrvs]</span><br><span class="line">192.168.99.101 http_port=8080 hname=www1</span><br><span class="line">192.168.99.102 http_port=80   hname=www2</span><br></pre></td></tr></table></figure>

<p>公共（组）变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[websvrs:vars] </span><br><span class="line">http_port=808</span><br><span class="line">mark="_"</span><br><span class="line"></span><br><span class="line">[websrvs]</span><br><span class="line">192.168.99.101 http_port=8080 hname=www1</span><br><span class="line">192.168.99.102 http_port=80 hname=www2</span><br><span class="line"></span><br><span class="line">ansible websvrs –m hostname –a 'name=&#123;&#123; hname &#125;&#125;&#123;&#123; mark &#125;&#125;&#123;&#123; http_port &#125;&#125;'</span><br></pre></td></tr></table></figure>

<p>命令行指定变量:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ansible websvrs –e http_port&#x3D;8000 –m hostname –a &#39;name&#x3D;&#123;&#123; hname &#125;&#125;&#123;&#123; mark &#125;&#125;&#123;&#123; http_port &#125;&#125;&#39;</span><br></pre></td></tr></table></figure>

<p>使用变量文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat vars.yml </span><br><span class="line"></span><br><span class="line">var1: httpd </span><br><span class="line">var2: nginx</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat var.yml</span><br><span class="line"></span><br><span class="line">- hosts: web</span><br><span class="line">  remote_user: root </span><br><span class="line">  vars_files:</span><br><span class="line">    - vars.yml</span><br><span class="line">  tasks:</span><br><span class="line">    - name: create httpd log</span><br><span class="line">    file: name=/app/&#123;&#123; var1 &#125;&#125;.log state=touch</span><br><span class="line">    - name: create nginx log</span><br><span class="line">    file: name=/app/&#123;&#123; var2 &#125;&#125;.log state=touch</span><br></pre></td></tr></table></figure>

<p>模板templates</p>
<p>文本文件，嵌套有脚本（使用模板编程语言编写）</p>
<p>Jinja2语言，使用字面量，有下面形式字符串:使用单引号或双引号</p>
<p>数字:整数，浮点数</p>
<p>列表:[item1, item2, …]</p>
<p>元组:(item1, item2, …)</p>
<p>字典:{key1:value1, key2:value2, …}</p>
<p>布尔型:true/false</p>
<p>算术运算:+, -, <em>, /, //, %, *</em></p>
<p>比较操作:==, !=, &gt;, &gt;=, &lt;, &lt;=</p>
<p>逻辑运算:and, or, not</p>
<p>流表达式:For If When</p>
<h4 id="templates"><a href="#templates" class="headerlink" title="templates"></a>templates</h4><p>templates功能:根据模块文件动态生成对应的配置文件</p>
<p>templates文件必须存放于templates目录下，且命名为 .j2 结尾</p>
<p>yaml/yml 文件需和templates目录平级，目录结构如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./</span><br><span class="line">├── temnginx.yml</span><br><span class="line">└── templates</span><br><span class="line">	  └── nginx.conf.j2</span><br></pre></td></tr></table></figure>

<h4 id="Templates示例"><a href="#Templates示例" class="headerlink" title="Templates示例"></a>Templates示例</h4><p>示例:利用templates 同步nginx配置文件准备templates/nginx.conf.j2文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim temnginx.yml</span><br><span class="line"></span><br><span class="line">- hosts: websrvs</span><br><span class="line">  remote_user: root</span><br><span class="line"></span><br><span class="line">  tasks:</span><br><span class="line">    - name: template config to remote hosts</span><br><span class="line">	 template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line">ansible-playbook temnginx.yml</span><br></pre></td></tr></table></figure>

<h4 id="Playbook中template变更替换"><a href="#Playbook中template变更替换" class="headerlink" title="Playbook中template变更替换"></a>Playbook中template变更替换</h4><p>修改文件nginx.conf.j2 下面行为</p>
<p><code>worker_processes ;</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat temnginx2.yml</span><br><span class="line"></span><br><span class="line">- hosts: websrvs</span><br><span class="line">  remote_user: root</span><br><span class="line"></span><br><span class="line">  tasks:</span><br><span class="line">	- name: template config to remote hosts</span><br><span class="line">	template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line">ansible-playbook temnginx2.yml</span><br></pre></td></tr></table></figure>

<h4 id="Playbook中template算术运算"><a href="#Playbook中template算术运算" class="headerlink" title="Playbook中template算术运算"></a>Playbook中template算术运算</h4><p>算法运算:</p>
<p>示例:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim nginx.conf.j2</span><br><span class="line"></span><br><span class="line">worker_processes &#123;&#123; ansible_processor_vcpus**2 &#125;&#125;; </span><br><span class="line">worker_processes &#123;&#123; ansible_processor_vcpus+2 &#125;&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="when"><a href="#when" class="headerlink" title="when"></a>when</h4><p>条件测试:如果需要根据变量、facts或此前任务的执行结果来做为某task执行与否的前提时要用到条件测试,通过when语句实现，在task中使用，jinja2的语法格式</p>
<p>when语句</p>
<p>在task后添加when子句即可使用条件测试；when语句支持Jinja2表达式语法</p>
<p>示例:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"shutdown RedHat flavored systems"</span></span><br><span class="line">  <span class="attr">command:</span> <span class="string">/sbin/shutdown</span> <span class="string">-h</span> <span class="string">now</span></span><br><span class="line">  <span class="attr">when:</span> <span class="string">ansible_os_family</span> <span class="string">==</span> <span class="string">"RedHat"</span></span><br></pre></td></tr></table></figure>

<p>示例:when条件判断</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">websrvs</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span> </span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">add</span> <span class="string">group</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">tags:</span> <span class="string">user</span></span><br><span class="line">      <span class="attr">user:</span> <span class="string">name=nginx</span> <span class="string">state=present</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">add</span> <span class="string">user</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">user:</span> <span class="string">name=nginx</span> <span class="string">state=present</span> <span class="string">group=nginx</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Nginx</span></span><br><span class="line">      <span class="attr">yum:</span> <span class="string">name=nginx</span> <span class="string">state=present</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">restart</span> <span class="string">Nginx</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">name=nginx</span> <span class="string">state=restarted</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">ansible_distribution_major_version</span> <span class="string">==</span> <span class="string">"6"</span></span><br></pre></td></tr></table></figure>

<p>示例:when条件判断</p>
<p>示例: </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install</span> <span class="string">conf</span> <span class="string">file</span> <span class="string">to</span> <span class="string">centos7</span></span><br><span class="line">    <span class="attr">template:</span> <span class="string">src=nginx.conf.c7.j2</span></span><br><span class="line">    <span class="attr">when:</span> <span class="string">ansible_distribution_major_version</span> <span class="string">==</span> <span class="string">"7"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install</span> <span class="string">conf</span> <span class="string">file</span> <span class="string">to</span> <span class="string">centos6</span></span><br><span class="line">    <span class="attr">template:</span> <span class="string">src=nginx.conf.c6.j2</span></span><br><span class="line">    <span class="attr">when:</span> <span class="string">ansible_distribution_major_version</span> <span class="string">==</span> <span class="string">"6"</span></span><br></pre></td></tr></table></figure>

<p>迭代:with_items</p>
<p>迭代:当有需要重复性执行的任务时，可以使用迭代机制</p>
<p>对迭代项的引用，固定变量名为”item”</p>
<p>要在task中使用with_items给定要迭代的元素列表</p>
<p>列表格式:</p>
<p>字符串</p>
<p>字典</p>
<p>示例:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">add</span> <span class="string">several</span> <span class="string">users</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">name=&#123;&#123;</span> <span class="string">item</span> <span class="string">&#125;&#125;</span> <span class="string">state=present</span> <span class="string">groups=wheel</span> </span><br><span class="line">  <span class="attr">with_items:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">testuser1</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">testuser2</span></span><br></pre></td></tr></table></figure>

<p>上面语句的功能等同于下面的语句:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">add</span> <span class="string">user</span> <span class="string">testuser1</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">name=testuser1</span> <span class="string">state=present</span> <span class="string">groups=wheel</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">add</span> <span class="string">user</span> <span class="string">testuser2</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">name=testuser2</span> <span class="string">state=present</span> <span class="string">groups=wheel</span></span><br></pre></td></tr></table></figure>

<p>示例:迭代</p>
<p>将多个文件进行copy到被控端</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">testsrv</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line"><span class="string">tasks</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Create</span> <span class="string">rsyncd</span> <span class="string">config</span></span><br><span class="line">  <span class="attr">copy:</span> <span class="string">src=&#123;&#123;</span> <span class="string">item</span> <span class="string">&#125;&#125;</span> <span class="string">dest=/etc/&#123;&#123;</span> <span class="string">item</span> <span class="string">&#125;&#125;</span> <span class="attr">with_items:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">rsyncd.secrets</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">rsyncd.conf</span></span><br></pre></td></tr></table></figure>

<p>示例:迭代</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">websrvs</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span> </span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">copy</span> <span class="string">file</span></span><br><span class="line">	  <span class="attr">copy:</span> <span class="string">src=&#123;&#123;</span> <span class="string">item</span> <span class="string">&#125;&#125;</span> <span class="string">dest=/tmp/&#123;&#123;</span> <span class="string">item</span> <span class="string">&#125;&#125;</span></span><br><span class="line">	  <span class="attr">with_items:</span></span><br><span class="line">		  <span class="bullet">-</span> <span class="string">file1</span></span><br><span class="line">		  <span class="bullet">-</span> <span class="string">file2</span></span><br><span class="line">		  <span class="bullet">-</span> <span class="string">file3</span></span><br><span class="line">	<span class="bullet">-</span> <span class="attr">name:</span> <span class="string">yum</span> <span class="string">install</span> <span class="string">httpd</span></span><br><span class="line">	  <span class="attr">yum:</span> <span class="string">name=&#123;&#123;</span> <span class="string">item</span> <span class="string">&#125;&#125;</span> <span class="string">state=present</span></span><br><span class="line">	  <span class="attr">with_items:</span></span><br><span class="line">		  <span class="bullet">-</span> <span class="string">apr</span></span><br><span class="line">		  <span class="bullet">-</span> <span class="string">apr-util</span></span><br><span class="line">		  <span class="bullet">-</span> <span class="string">httpd</span></span><br></pre></td></tr></table></figure>

<p>示例:迭代</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">hosts:websrvs</span> </span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  </span><br><span class="line">  <span class="string">tasks</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install</span> <span class="string">some</span> <span class="string">packages</span></span><br><span class="line">	  <span class="attr">yum:</span> <span class="string">name=&#123;&#123;</span> <span class="string">item</span> <span class="string">&#125;&#125;</span> <span class="string">state=present</span></span><br><span class="line">	  <span class="attr">with_items:</span></span><br><span class="line">		<span class="bullet">-</span> <span class="string">nginx</span></span><br><span class="line">		<span class="bullet">-</span> <span class="string">memcached</span></span><br><span class="line">		<span class="bullet">-</span> <span class="string">php-fpm</span></span><br></pre></td></tr></table></figure>

<p>示例:迭代嵌套子变量</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">hosts:websrvs</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">add</span> <span class="string">some</span> <span class="string">groups</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">name=&#123;&#123;</span> <span class="string">item</span> <span class="string">&#125;&#125;</span> <span class="string">state=present</span></span><br><span class="line">      <span class="attr">with_items:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">group1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">group2</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">group3</span></span><br><span class="line">	<span class="bullet">-</span> <span class="attr">name:</span> <span class="string">add</span> <span class="string">some</span> <span class="string">users</span></span><br><span class="line">	  <span class="attr">user:</span> <span class="string">name=&#123;&#123;</span> <span class="string">item.name</span> <span class="string">&#125;&#125;</span> <span class="string">group=&#123;&#123;</span> <span class="string">item.group</span> <span class="string">&#125;&#125;</span> <span class="string">state=present</span> <span class="attr">with_items:</span></span><br><span class="line">	    <span class="bullet">-</span> <span class="string">&#123;</span> <span class="attr">name:</span> <span class="string">'user1'</span><span class="string">,</span> <span class="attr">group:</span> <span class="string">'group1'</span> <span class="string">&#125;</span></span><br><span class="line">	    <span class="bullet">-</span> <span class="string">&#123;</span> <span class="attr">name:</span> <span class="string">'user2'</span><span class="string">,</span> <span class="attr">group:</span> <span class="string">'group2'</span> <span class="string">&#125;</span></span><br><span class="line">	    <span class="bullet">-</span> <span class="string">&#123;</span> <span class="attr">name:</span> <span class="string">'user3'</span><span class="string">,</span> <span class="attr">group:</span> <span class="string">'group3'</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="roles"><a href="#roles" class="headerlink" title="roles"></a>roles</h4><p>ansilbe自1.2版本引入的新特性，用于层次性、结构化地组织playbook。roles能够根据层次型结构自动装载变量文件、tasks以及handlers等。要使用roles只需要在playbook中使用include指令即可。简单来讲，roles就是通过分别将变量、文件、任务、模板及处理器放置于单独的目录中，并可以便捷地include它们的一种机制。角色一般用于基于主机构建服务的场景中，但也可以是用于构建守护进程等场景中</p>
<p>复杂场景:建议使用roles，代码复用度高</p>
<p>变更指定主机或主机组</p>
<p>如命名不规范维护和传承成本大</p>
<p>某些功能需多个Playbook，通过Includes即可实现</p>
<p>角色(roles):角色集合 </p>
<p>roles/</p>
<p>  mysql/</p>
<p>  httpd/</p>
<p>  nginx/</p>
<p>  memcached/</p>
<h4 id="roles目录结构"><a href="#roles目录结构" class="headerlink" title="roles目录结构"></a>roles目录结构</h4><p>每个角色，以特定的层级目录结构进行组织</p>
<p>roles目录结构: </p>
<p>playbook.yml </p>
<p>  roles/<br>​     project/<br>​     tasks/<br>​     files/<br>​     vars/<br>​     templates/<br>​     handlers/<br>​     default/  不常用<br>​     meta/    不常用</p>
<p>Roles各目录作用:</p>
<pre><code>/roles/project/ :项目名称,有以下子目录

files/ :存放由copy或script模块等调用的文件

templates/:template模块查找所需要模板文件的目录

tasks/:定义task,role的基本元素，至少应该包含一个名为main.yml的文件；其它的文件需要在此文件中通过include进行包含

handlers/:至少应该包含一个名为main.yml的文件；其它的文件需要在此文件中通过include进行包含

vars/:定义变量，至少应该包含一个名为main.yml的文件；其它的文件需要在此文件中通过include进行包含

meta/:定义当前角色的特殊设定及其依赖关系,至少应该包含一个名为main.yml的文件，其它文件需在此文件中通过include进行包含

default/:设定默认变量时使用此目录中的main.yml文件</code></pre><p>创建role:</p>
<pre><code>创建role的步骤

(1) 创建以roles命名的目录

(2) 在roles目录中分别创建以各角色名称命名的目录，如webservers等

(3) 在每个角色命名的目录中分别创建files、handlers、meta、tasks、templates和vars目录；用不到的目录可以创建为空目录，也可以不创建

(4) 在playbook文件中，调用各角色</code></pre><h4 id="playbook调用角色"><a href="#playbook调用角色" class="headerlink" title="playbook调用角色"></a>playbook调用角色</h4><p>调用角色方法1:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">websrvs</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span> </span><br><span class="line">  <span class="attr">roles:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">memcached</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>

<p>调用角色方法2:传递变量给角色</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">  <span class="attr">remote_user:</span></span><br><span class="line">  <span class="attr">roles:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#123;</span> <span class="attr">role:</span> <span class="string">nginx,</span> <span class="attr">username:</span> <span class="string">nginx</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>键role用于指定角色名称</p>
<p>后续的k/v用于传递变量给角色</p>
<p>调用角色方法3:还可基于条件测试实现角色调用 roles:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">&#123;</span> <span class="attr">role:</span> <span class="string">nginx,</span> <span class="attr">username:</span> <span class="string">nginx,</span> <span class="attr">when:</span> <span class="string">ansible_distribution_major_version</span> <span class="string">==</span> <span class="string">'7'</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="推荐资料"><a href="#推荐资料" class="headerlink" title="推荐资料"></a>推荐资料</h4><pre><code>http://galaxy.ansible.com
https://galaxy.ansible.com/explore#/
http://github.com/
http://ansible.com.cn/
https://github.com/ansible/ansible
https://github.com/ansible/ansible-examples</code></pre>]]></content>
  </entry>
  <entry>
    <title>java接口多态探究</title>
    <url>/java%E6%8E%A5%E5%8F%A3%E5%A4%9A%E6%80%81%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>python 常见知识点</title>
    <url>/python-%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3>]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql必知必会(一)</title>
    <url>/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E4%B8%80/</url>
    <content><![CDATA[<p>常用操作:</p>
<h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p>介绍如何使用sql的select语句来检索单个表列,多个表列以及所有表列.</p>
<h3 id="检索数据的排序"><a href="#检索数据的排序" class="headerlink" title="检索数据的排序"></a>检索数据的排序</h3><p>如何用select语句的order by子句对检索出的数据进行排序.这个子句必须是select 语句中的最后一条子句,</p>
<p>可根据需要,利用它在一个或者多个列上对数据进行排序</p>
<h3 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h3><p>where</p>
<p>利用select和where子句过滤返回的数据</p>
<h3 id="数据过滤"><a href="#数据过滤" class="headerlink" title="数据过滤"></a>数据过滤</h3><p>组合where</p>
<p>and操作符</p>
<p>or操作符</p>
<p>计算次序</p>
<p>in操作符</p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring部分</title>
    <url>/Spring%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<p>本文档根据B站视频进行spring部分的学习记录</p>
<p>Spring5最新完整教程IDEA版</p>
<h2 id="1-Spring简介"><a href="#1-Spring简介" class="headerlink" title="1.Spring简介"></a>1.Spring简介</h2><ul>
<li>spring理念: 使现有的技术更加容易使用,本身是一个大杂烩,整合了现有的技术框架</li>
<li>spring总结: Spring就是一个轻量级的控制反转(IOC)和面向切面编程(AOP)的框架</li>
</ul>
<h2 id="2-spring组成及拓展"><a href="#2-spring组成及拓展" class="headerlink" title="2.spring组成及拓展"></a>2.spring组成及拓展</h2><p>spring Boot 构建一切<br>    一个快速开发的脚手架<br>    基于SpringBoot可以快速开发单个微服务<br>    约定大于配置<br>spring Cloud 协调一切<br>    SpringCloud是基于SpringBoot实现的<br>spring Cloud Data Flow 连接一切</p>
<p>学习springBoot的前提,需要完全掌握spring及springMVC</p>
<h2 id="3-IOC理论推导"><a href="#3-IOC理论推导" class="headerlink" title="3.IOC理论推导"></a>3.IOC理论推导</h2><p>1.UserDao接口<br>2.UserDaoImpl实现类<br>3.UserService业务接口<br>4.UserServiceImpl业务实现类</p>
<p>在我们之前的业务中,用户的需求可能会影响我们原来的代码,我们需要根据用户的需求去修改源代码,如果程序<br>代码量十分大,修改一次的成本代价十分高昂</p>
<p>我们使用一个set接口实现,已经发生了革命性的变化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用set进行动态实现值的注入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>之前程序是主动创建对象,控制权在程序员手上</li>
<li>使用了set注入后,程序不再具有主动性,而是变成了被动的接受对象</li>
</ul>
<p>这种思想,从本质上解决了问题,不用再去管理对象的创建了,系统的耦合性大大降低,可以更加专注于业务的实现上<br>这是IOC的原型</p>
<h2 id="4-IOC本质"><a href="#4-IOC本质" class="headerlink" title="4.IOC本质"></a>4.IOC本质</h2><p>控制反转IOC(Inversion of Control),是一种设计思想,DI(依赖注入)是实现IOC的一种方法<br>没有IOC的程序中,我们使用面向对象编程,对象的创建与对象间的依赖关系完全硬编码在程序中,对象的创建由程序自己控制,<br>控制反转后将对象的创建转移给第三方,简单来说就是:获得依赖对象的方式反转了</p>
<p>IOC是Spring框架的核心内容,使用多种方式完美的实现了IOC,可以使用XML配置,也可以使用注解<br>Spring容器在初始化的时,先读取配置文件,根据配置文件或元数据创建与组织对象存入容器中,程序使用时再从<br>IOC容器中取出需要的对象</p>
<p>采用xml方式配置Bean的时候,Bean的定义信息是和现实分离的,而采用注解的方式可以把两者何为一体,Bean的定义信息直接以<br>注解的形式定义在实现类中,从而达到了零配置的目的</p>
<p>控制反转时一种通过描述(XML或注解)并通过第三方去生产或获取特定对象的方式,在Spring中实现控制反转的时IOC容器,其实现<br>方法是依赖注入(Dependency Injection,DI)</p>
<h2 id="5-HelloSpring"><a href="#5-HelloSpring" class="headerlink" title="5.HelloSpring"></a>5.HelloSpring</h2><p>创建一个spring项目</p>
<p>beans的示例:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用spring来创建对象,在spring这些都成为bean</span></span><br><span class="line"><span class="comment">        java的写法:</span></span><br><span class="line"><span class="comment">        类型 变量名 = new 类型();</span></span><br><span class="line"><span class="comment">        Hello hello = new Hello();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        spring的写法</span></span><br><span class="line"><span class="comment">        id = 变量名</span></span><br><span class="line"><span class="comment">        class = new的对象;</span></span><br><span class="line"><span class="comment">        bean = 对象 new hello();</span></span><br><span class="line"><span class="comment">        property 相当于给对象中的属性设置一个值</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"hello"</span> <span class="attr">class</span>=<span class="string">"pojo.Hello"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"str"</span> <span class="attr">value</span>=<span class="string">"Spring"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取spring的上下文对象</span></span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">    <span class="comment">//我们的对象都在spring中管理了,我们使用,直接去里面取出来就可以</span></span><br><span class="line">    Hello hello = (Hello) context.getBean(<span class="string">"hello"</span>);</span><br><span class="line">    System.out.println(hello.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pojo对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制:谁来控制对象的创建,传统应用程序的对象是由程序本身控制创建的,使用spring后,对象是由spring来创建的<br>反转:程序本身不创建对象,而变成被动的接收对象<br>依赖注入:就是利用set方法来进行注入的<br>IOC是一种编程思想,由主动的编程变成被动的接收<br>要实现不同的操作,不用在程序中去改动了,要实现不同的操作,只需要在xml配置文件中进行修改<br>所谓IOC一句话搞定,对象由spring来创建,管理,装配</p>
<h2 id="6-IOC创建对象方式"><a href="#6-IOC创建对象方式" class="headerlink" title="6.IOC创建对象方式"></a>6.IOC创建对象方式</h2><p>1.使用无参构造创建对象,默认<br>2.使用有参构造创建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">setName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sout(<span class="string">"name="</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>beans.xml实现:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">- 2.1 下标赋值</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.kuang.User"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"testValue"</span></span></span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">- 2.2 通过类型创建(不建议使用)</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.kuang.User"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"testValue"</span></span></span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">- 2.3 直接通过参数名来设置</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.kuang.User"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"testValue"</span></span></span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>测试类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">MyTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    psvm()&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        User user = (User)context.getBean(<span class="string">"user"</span>);</span><br><span class="line">        user.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:<br>在配置文件加载的时候,容器(可以理解为spirng中加载的bean的context)中管理的对象就已经初始化了</p>
<h2 id="7-Spring配置说明"><a href="#7-Spring配置说明" class="headerlink" title="7.Spring配置说明"></a>7.Spring配置说明</h2><h3 id="1-别名"><a href="#1-别名" class="headerlink" title="1.别名"></a>1.别名</h3><p>示例:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"marktest.demo.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"marktest2333"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">alias</span>=<span class="string">"user2"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">MyTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    psvm()&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        User user = (User)context.getBean(<span class="string">"user2"</span>);</span><br><span class="line">        user.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Bean的配置"><a href="#2-Bean的配置" class="headerlink" title="2.Bean的配置"></a>2.Bean的配置</h3><p>示例:</p>
<p>id: bean的唯一标识符,也就是相当于对象名<br>class: bean对象所对应的全限定名: 包名 + 类名<br>name: 也是别名,而且name 可以同时取多个别名(逗号,空格,分号都可以进行分隔)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"marktest.demo.User"</span> <span class="attr">name</span>=<span class="string">"user3,u3 u4;u5"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"marktest3222"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-import"><a href="#3-import" class="headerlink" title="3.import"></a>3.import</h3><p>这个import一般用于团队开发,可以将多个配置文件,导入合并为一个<br>不同的人负责不同的类进行开发,不同的类需要注册在不同的bean中,可以利用import将所有人的beans.xml合并成一个总的<br>例如:</p>
<p>新建一个applicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"beans.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"beans2.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"beans3.xml"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="8-DI依赖注入环境"><a href="#8-DI依赖注入环境" class="headerlink" title="8.DI依赖注入环境"></a>8.DI依赖注入环境</h2><h3 id="1-构造器注入"><a href="#1-构造器注入" class="headerlink" title="1.构造器注入"></a>1.构造器注入</h3><p>参考前面IOC创建对象方式</p>
<h3 id="2-set方式注入-重点"><a href="#2-set方式注入-重点" class="headerlink" title="2.set方式注入[重点]"></a>2.set方式注入[重点]</h3><p>依赖注入:本质是Set注入</p>
<ul>
<li><p>依赖:bean对象的创建依赖于容器</p>
</li>
<li><p>注入:bean对象中的所有属性,由容器来注入</p>
</li>
</ul>
<p>[测试环境搭建]</p>
<p>1.创建两个实体类</p>
<p>Address.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.marktest.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Address&#123;"</span> +</span><br><span class="line">                <span class="string">"address='"</span> + address + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Address</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Address</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Student.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.marktest.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="keyword">private</span> String[] books;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbys;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; card;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; games;</span><br><span class="line">    <span class="keyword">private</span> String wife;</span><br><span class="line">    <span class="keyword">private</span> Properties info;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", address="</span> + address.toString() +</span><br><span class="line">                <span class="string">", books="</span> + Arrays.toString(books) +</span><br><span class="line">                <span class="string">", hobbys="</span> + hobbys +</span><br><span class="line">                <span class="string">", card="</span> + card +</span><br><span class="line">                <span class="string">", games="</span> + games +</span><br><span class="line">                <span class="string">", wife='"</span> + wife + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", info="</span> + info +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Address <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(Address address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getBooks() &#123;</span><br><span class="line">        <span class="keyword">return</span> books;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBooks</span><span class="params">(String[] books)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.books = books;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getHobbys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hobbys;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHobbys</span><span class="params">(List&lt;String&gt; hobbys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hobbys = hobbys;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getCard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> card;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCard</span><span class="params">(Map&lt;String, String&gt; card)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.card = card;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getGames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> games;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGames</span><span class="params">(Set&lt;String&gt; games)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.games = games;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWife</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> wife;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWife</span><span class="params">(String wife)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.wife = wife;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(Properties info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.创建beans文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:util</span>=<span class="string">"http://www.springframework.org/schema/util"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"com.marktest.pojo.Student"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--第一种普通注入,value--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"marktest1122"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.创建测试类文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">Student student = (Student) context.getBean(<span class="string">"student"</span>);</span><br><span class="line">System.out.printf(student.toString());</span><br></pre></td></tr></table></figure>

<p>4.完善注入信息</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:util</span>=<span class="string">"http://www.springframework.org/schema/util"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"address"</span> <span class="attr">class</span>=<span class="string">"com.marktest.pojo.Address"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">value</span>=<span class="string">"内蒙"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"com.marktest.pojo.Student"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--第一种普通注入,value--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"marktest1122"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--第二种,Bean注入,ref--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">ref</span>=<span class="string">"address"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--第三种,数组注入--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"books"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>红楼梦<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>水浒传<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>西游记<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>三国演艺<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--第四种,List注入--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hobbys"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>听歌<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>看电影<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>敲代码<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--第五种,Map注入--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"card"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"身份证"</span> <span class="attr">value</span>=<span class="string">"123123123123123"</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"银行看"</span> <span class="attr">value</span>=<span class="string">"321312321312312"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--第六种,Set注入--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"games"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>LOL<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>COC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>BOB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--第七种,null注入--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"wife"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--第八种,properties注入--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"学号"</span>&gt;</span>123321001<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"性别"</span>&gt;</span>男<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"姓名"</span>&gt;</span>李华<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="3-拓展方式注入"><a href="#3-拓展方式注入" class="headerlink" title="3.拓展方式注入"></a>3.拓展方式注入</h3><p>我们可以使用p命名空间和c命名空间进行注入</p>
<p><strong>使用</strong></p>
<p>创建一个User实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.marktest.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"user&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建userbeans.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:c</span>=<span class="string">"http://www.springframework.org/schema/c"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans.xsd "</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--p命名空间注入,可以直接注入属性的值: properties--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.marktest.pojo.User"</span> <span class="attr">p:age</span>=<span class="string">"40"</span> <span class="attr">p:name</span>=<span class="string">"jack"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--c命名空间注入,通过构造器注入: construct-args --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user2"</span> <span class="attr">class</span>=<span class="string">"com.marktest.pojo.User"</span> <span class="attr">c:age</span>=<span class="string">"18"</span> <span class="attr">c:name</span>=<span class="string">"Fuck"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext context3 = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"userbeans.xml"</span>);</span><br><span class="line">    User user4 = context3.getBean(<span class="string">"user2"</span>, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.printf(user4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意点:</strong></p>
<p>p命名和c命令空间不能直接使用,需要导入xml约束</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xmlns:p="http://www.springframework.org/schema/p"</span><br><span class="line">xmlns:c="http://www.springframework.org/schema/c"</span><br></pre></td></tr></table></figure>

<h2 id="9-依赖注入之set注入"><a href="#9-依赖注入之set注入" class="headerlink" title="9.依赖注入之set注入"></a>9.依赖注入之set注入</h2><p>参考set方式注入</p>
<h2 id="10-c命名空间和p命名空间注入"><a href="#10-c命名空间和p命名空间注入" class="headerlink" title="10.c命名空间和p命名空间注入"></a>10.c命名空间和p命名空间注入</h2><p>参考拓展方式注入</p>
<h2 id="11-Bean的作用域"><a href="#11-Bean的作用域" class="headerlink" title="11.Bean的作用域"></a>11.Bean的作用域</h2><p>使用@test来检查Bean作用域的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext context3 = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"userbeans.xml"</span>);</span><br><span class="line">    User user4 = context3.getBean(<span class="string">"user2"</span>, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    User user5 = context3.getBean(<span class="string">"user2"</span>, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.printf(String.valueOf(user4==user5));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ol>
<li><p>singleton [单例] (Spring默认机制)<br>//scppe配置为singletion</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user2"</span> <span class="attr">class</span>=<span class="string">"com.marktest.pojo.User"</span> <span class="attr">c:age</span>=<span class="string">"18"</span> <span class="attr">c:name</span>=<span class="string">"Fuck"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>返回结果为true</p>
</li>
</ol>
</li>
<li><ol start="2">
<li><p>prototype [原型]<br>每次从容器中get的时候都会产生一个新对象<br>//scppe配置为prototype</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user2"</span> <span class="attr">class</span>=<span class="string">"com.marktest.pojo.User"</span> <span class="attr">c:age</span>=<span class="string">"18"</span> <span class="attr">c:name</span>=<span class="string">"Fuck"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>返回结果为false</p>
</li>
</ol>
</li>
<li><p>其余的request,session,application 这些只能在web开发中使用到</p>
</li>
</ul>
<h2 id="12-自动装配Bean"><a href="#12-自动装配Bean" class="headerlink" title="12.自动装配Bean"></a>12.自动装配Bean</h2><ul>
<li><p>自动装配是spring满足bean依赖的一种方式</p>
</li>
<li><p>spring会在上下文中自动寻找,并自动给bean装配属性</p>
</li>
</ul>
<p><strong>在spring中有三种装配方式:</strong><br>1.在xml中显示的配置<br>  示例:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat"</span> <span class="attr">class</span>=<span class="string">"com.markup.pojo.Cat"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dog"</span> <span class="attr">class</span>=<span class="string">"com.markup.pojo.Dog"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"people"</span> <span class="attr">class</span>=<span class="string">"com.markup.pojo.People"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"markup"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dog"</span> <span class="attr">ref</span>=<span class="string">"dog"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cat"</span> <span class="attr">ref</span>=<span class="string">"cat"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在xml中显示的配置,如果有引用bean的话需要用ref参数将上面通过bean创建的参数做引用<br>2.在java中显示装配<br>3.隐式的自动装配bean[重要]<br>    可以通过ByName和ByType的方式来实现自动装配</p>
<p><strong>测试环境搭建</strong></p>
<p>1.环境搭建: 一个人有两个宠物</p>
<p>2.ByName自动装配</p>
<p>示例:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat"</span> <span class="attr">class</span>=<span class="string">"com.markup.pojo.Cat"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dog"</span> <span class="attr">class</span>=<span class="string">"com.markup.pojo.Dog"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"people"</span> <span class="attr">class</span>=<span class="string">"com.markup.pojo.People"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"markup"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>byName: 会自动在容器上下文中查找和自己对象set方法后面的值对应的beanID</p>
<p>3.ByType自动装配</p>
<p>示例:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.markup.pojo.Cat"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.markup.pojo.Dog"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"people"</span> <span class="attr">class</span>=<span class="string">"com.markup.pojo.People"</span> <span class="attr">autowire</span>=<span class="string">"byType"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"markup"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>byType: 会自动在容器上下文中查找和自己对象属性类型相同的bean</p>
<p><strong>小结:</strong></p>
<p>ByName的时候,需要保证所有的bean的ID唯一,并且这个bean需要和自动注入的属性的set方法的值一致<br>ByType的时候,需要保证所有的bean的class唯一,并且这个bean需要和自动注入的属性的类型一致</p>
<p>4.使用注解实现自动装配</p>
<p>JDK 1.5 版本支持的注解, spring 2.5 支持的注解</p>
<p>1.导入约束<br>    context约束</p>
<p>2.配置注解的支持[重要]<br>    context:annotation-config/</p>
<p>示例代码:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context/spring-context.xsd "</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注解关键字:</p>
<p><strong>@Autowired注解</strong>[spring方式]</p>
<p>直接在属性上使用即可,也可以在set方式上使用<br>使用@Autowired我们可以不用编写set方法了,前提是这个自动装配的属性在IOC(spring)容器中存在,且符合名字byName.<br>测试代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果@Autowired自动装配的环境比较复杂,自动装配无法通过一个注解[@Autowired]完成的时候,我们可以<br>使用@Qualifier(value = “xxx”)去配置@Autowired的使用,执行一个唯一的bean对象注入.<br>测试代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(value = <span class="string">"cat111"</span>)</span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(value = <span class="string">"dog222"</span>)</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@Resource注解</strong>[java方式]</p>
<p>测试代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span>(name = <span class="string">"cat"</span>)</span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结</strong></p>
<p>@Resource和@Autowired的区别:<br>都是用来自动装配的,都可以放在属性字段上<br>@Autowired 通过byType的方式实现,并且必须要求这个对象存在 [常用]<br>@Resource 默认通过byName的方式实现,如果找不到,则通过byType实现,如果两个都找不到的情况下,就报错 [常用]<br>执行顺序不同:<br>@Autowired 通过byType的方式实现;@Resource 默认通过byName的方式实现.</p>
<h2 id="13-注解实现主动装配"><a href="#13-注解实现主动装配" class="headerlink" title="13.注解实现主动装配"></a>13.注解实现主动装配</h2><p>参考 4.使用注解实现自动装配</p>
<h2 id="14-Spring注解开发"><a href="#14-Spring注解开发" class="headerlink" title="14.Spring注解开发"></a>14.Spring注解开发</h2><p>在spring4之后要使用注解开发,必须要保证aop的包导入了<br>在使用注解需要导入context约束,增加注解的支持</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>1.bean</p>
<p>2.属性如何注入</p>
<p>@Component: 组件,放在类上,说明这个类被spring管理了</p>
<p>示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等价于 &lt;bean id="user" class="com.markup.pojo.User"/&gt;</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">//组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">//相当于bean中 &lt;property name="name" value="markup"/&gt;</span></span><br><span class="line">    <span class="comment">//    @Value("markup")</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相当于bean中 &lt;property name="name" value="markup"/&gt;</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"fuckjack"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.衍生的注解</p>
<p>@Component有几个衍生注解,在web开发中,会按照mvc三层加枸分层</p>
<ul>
<li>dao [@Repository]</li>
<li>service [@Service]</li>
<li>controller [@Controller]</li>
</ul>
<p>这四个注解功能都是一样的,都是代表将某个类注解到spring容器中,装配bean</p>
<p>4.自动装配</p>
<p>@Autowired: 自动装配通过类型,名字<br>    如果@Autowired不能唯一自动装配上属性,则需要通过@Qualifier(value=”xxx”)<br>@Nullable: 字段标记了这个注解,说明这个字段可以为null<br>@Resource: 自动装配通过名字,类型</p>
<p>5.作用域</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//组件</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>) <span class="comment">//指定bean的作用域为单例或者其他</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相当于bean中 &lt;property name="name" value="markup"/&gt;</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"fuckjack"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.小结</p>
<p>常用依赖:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>xml与注解:</p>
<p>xml更加万能,适用于任何场合,维护简单方便</p>
<p>注解 不是自己的类使用不了,维护相对复杂</p>
<p>xml与注解最佳实现:</p>
<p>xml 用来管理bean</p>
<p>注解只负责完成属性的注入</p>
<p>在使用的过程中,只需要注意一个问题,必须让注解生效,就需要开启注解的支持</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定要扫描的包,这个包下的注解就会生效--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.markup"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="15-使用JavaConfig实现配置"><a href="#15-使用JavaConfig实现配置" class="headerlink" title="15.使用JavaConfig实现配置"></a>15.使用JavaConfig实现配置</h2><p>现在完全不使用spring的xml配置了,全交给java来做<br>JavaConfig是spring的一个子功能<br>示例:</p>
<p><strong>实体类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@Component这个注解的意思,就是说明这个类被spring接管了,注册到了容器中</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">            <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">            <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"MARKUP"</span>) <span class="comment">//属性注入值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个注解也会被spring容器托管,注册到容器中,因为它本身就是一个@Compoent,</span></span><br><span class="line"><span class="comment">// @Configuration代表这是一个配置类,就和我们之前看到的beans.xml是一样的</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.markup.pojo"</span>)</span><br><span class="line"><span class="meta">@Import</span>(MarkConfig2<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MarkConfig</span> </span>&#123;</span><br><span class="line">	<span class="comment">//注册一个bean,就相当于之前写的一个bean标签,</span></span><br><span class="line">	<span class="comment">//这个方法的名字,就相当于bean标签中的id属性</span></span><br><span class="line">	<span class="comment">//这个方法的返回值,就相当于bean标签中的class属性</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//就是返回要注入到bean的对象</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mytest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果完全使用了配置类方式去做,我们就只能通过 ApplicationContext 上下文来获取容器,通过配置类的class对象加载</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(MarkConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        User getUser = context.getBean(<span class="string">"getUser"</span>, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(getUser.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种纯java的配置方式,在sprin中随处可见.</p>
<h2 id="16-内容回顾"><a href="#16-内容回顾" class="headerlink" title="16.内容回顾"></a>16.内容回顾</h2><p> spring的发展历程到配置的过程从xml配置到注解开发</p>
<h2 id="17-静态代理模式"><a href="#17-静态代理模式" class="headerlink" title="17.静态代理模式"></a>17.静态代理模式</h2><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>为什么要学习代理模式? 因为这就是springAOP的底层[springAOP和springMVC]<br>代理模式的分类</p>
<ul>
<li>静态代理</li>
<li>动态代理</li>
</ul>
<h3 id="静态代理模式"><a href="#静态代理模式" class="headerlink" title="静态代理模式"></a>静态代理模式</h3><p>角色分析:</p>
<ul>
<li>抽象角色:<br>一般会使用接口或者抽象类来解决</li>
<li>真实角色:<br>被代理的角色</li>
<li>代理角色:<br>代理真实角色,一般代理之后会做一些附属操作</li>
<li>客户:<br>访问代理对象的人</li>
</ul>
<p>代码步骤:</p>
<p>1.接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//租房</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Rent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.真实角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//房东</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Host</span> <span class="keyword">implements</span> <span class="title">Rent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"房东要出租房子"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.代理角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中介</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Rent</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Host host;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Host host)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        seeHouse();</span><br><span class="line">        host.rent();</span><br><span class="line">        hetong();</span><br><span class="line">        fare();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//看房</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seeHouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"中介带你看房"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收中介费</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fare</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"收中介费"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//签合同</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hetong</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"签租赁合同"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.客户端访问代理角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//租客</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不走代理直接调用房东租房的方法</span></span><br><span class="line">        <span class="comment">//        Host host = new Host();</span></span><br><span class="line">        <span class="comment">//        host.rent();</span></span><br><span class="line"></span><br><span class="line">        Host host = <span class="keyword">new</span> Host();</span><br><span class="line">        <span class="comment">//代理,中介帮房东租房子,但是代理角色一般会有一些附属操作</span></span><br><span class="line">        Proxy proxy = <span class="keyword">new</span> Proxy(host);</span><br><span class="line">        <span class="comment">//不用直接面对房东,直接找中介租房即可</span></span><br><span class="line">        proxy.rent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理模式的好处<br>    可以使真实角色的操作更加纯粹,不用去关注一些公共的业务<br>    公共业务交给代理角色,实现了业务的分工<br>    公共业务发生扩展的时候,方便集中管理</p>
<p>代理的缺点:<br>    一个真实的角色就会产生一个代理角色;代码量会翻倍,开发效率会变低</p>
<h2 id="18-静态代理模式再理解"><a href="#18-静态代理模式再理解" class="headerlink" title="18.静态代理模式再理解"></a>18.静态代理模式再理解</h2><p>1.接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.真实角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//真实对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"增加了一个用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"删除了一个用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"修改了一个用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"查询了一个用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.切勿修改原有代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.代理角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserService</span><span class="params">(UserService userService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log(<span class="string">"add"</span>);</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log(<span class="string">"delete"</span>);</span><br><span class="line">        userService.delete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log(<span class="string">"update"</span>);</span><br><span class="line">        userService.update();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log(<span class="string">"query"</span>);</span><br><span class="line">        userService.query();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//日志方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"[DEBUG]使用了"</span>+ msg+ <span class="string">"方法 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.客户端访问代理角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserServiceImpl userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line"></span><br><span class="line">        UserServiceProxy proxy = <span class="keyword">new</span> UserServiceProxy();</span><br><span class="line">        proxy.setUserService(userService);</span><br><span class="line"></span><br><span class="line">        proxy.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-动态代理模式详解"><a href="#19-动态代理模式详解" class="headerlink" title="19.动态代理模式详解"></a>19.动态代理模式详解</h2><p>动态代理和静态代理的角色一样<br>动态代理的代理类是动态生成的,不是我们直接写好的<br>动态代理分为两大类:基于接口的动态代理,基于类的动态代理<br>    基于接口: JDK动态代理<br>    基于类: cglib<br>    java字节码实现: javasist</p>
<p>需要了解两个类:<br>    Proxy:提供了创建动态代理类和实例的静态方法,它也是由这些方法创建的所有动态代理类的超类.<br>    InvocationHandler:是由代理实例的,调用处理程序实现的接口</p>
<p>动态代理的好处:<br>    可以使真实角色的操作更加纯粹,不用去关注一些公共的业务<br>    公共业务交给代理角色,实现了业务的分工<br>    公共业务发生扩展的时候,方便集中管理<br>    一个动态代理类代理的是一个接口,一般就是对应的一类业务<br>    一个动态代理类可以代理多个类,只要是实现了同一个接口即可</p>
<p>1.接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.真实角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"增加了一个用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"删除了一个用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"修改了一个用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"查询了一个用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.切勿修改原有代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.代理角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被代理的接口</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成得到代理类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(), target.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理代理实例并返回结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//动态代理的本质就是使用反射机制</span></span><br><span class="line">        log(method.getName());</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"执行了"</span>+ msg + <span class="string">"方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.客户端访问代理角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//真实角色</span></span><br><span class="line">        UserServiceImpl userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        <span class="comment">//代理角色</span></span><br><span class="line">        ProxyInvocationHandler pih = <span class="keyword">new</span> ProxyInvocationHandler();</span><br><span class="line">        <span class="comment">//设置要代理的对象</span></span><br><span class="line">        pih.setTarget(userService);</span><br><span class="line">        <span class="comment">//动态生成代理类</span></span><br><span class="line">        UserService   proxy = (UserService) pih.getProxy();</span><br><span class="line"></span><br><span class="line">        proxy.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="20-AOP实现方式一"><a href="#20-AOP实现方式一" class="headerlink" title="20.AOP实现方式一"></a>20.AOP实现方式一</h2><p>1.什么是AOP</p>
<p>AOP(Aspect Oriented Programming)意为: 面向切面编程,通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术.<br>AOP是OOP的延续,是软件开发中的一个热点,也是Spring框架中的一个重要的内容,是函数式编程的一种衍生泛型,利用AOP可以对<br>业务逻辑的各个部分进行隔离,从而使得业务逻辑各部分之间的耦合度降低,提高程序的可用性,同时提高了开发的效率</p>
<p>2.AOP在Spring中的作用</p>
<p>提供声明式事务,允许用户自定义切面<br>横切关注点:<br>    跨越应用程序多个模块的方法或功能,即与我们业务逻辑无关的,但是我们需要关注的部分,就是横切关注点,如日志,安全,缓存,事务等<br>切面(Aspect)<br>    横切关注点,被模块化的特殊对象,它是一个类<br>通知(Advice)<br>    切面必须要完成的工作,它是类中的一个方法<br>目标(Target)<br>    被通知的对象<br>代理(Proxy)<br>    向目标对象应用通知之后创建的对象<br>切入点(PointCut)<br>    切面通知执行的”地点”的定义<br>连接点(JoinPoint)<br>    与切入点匹配的执行点</p>
<p>SpringAOP中,通过advice定义横切逻辑,Spring中支持5种类型的Advice:<br>    通知类型        连接点                    实现接口<br>    前置通知        方法前                    org.springframework.aop.MethodBeforeAdvice<br>    后置通知        方法后                    org.springframework.aop.AfterReturningAdvice<br>    环绕通知        方法前后                org.aopallicance.intercept.MethodInterceptor<br>    异常抛出通知    方法抛出异常            org.springframework.aop.ThrowsAdvice<br>    引介通知        类中增加新的方法属性    org.springframework.aop.IntroductionInterceptor<br>即AOP在不改变原有代码的情况下,去增加新的功能 </p>
<p>3.使用Spring实现AOP</p>
<p>[重点] 使用AOP织入,需要导入一个依赖包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过给增删改查方法添加方法执行前后打印的方式来实践对AOP的理解</p>
<p>方式一:使用Spring的api接口 [spring API接口实现]</p>
<p>1.新建一个接口UserService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.markup.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quert</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.新建接口的实现UserServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.markup.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"增加了一个用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"删除了一个用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"修改了一个用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"查询了一个用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.添加检查方法执行时的Log方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.aop.MethodBeforeAdvice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> </span>&#123;</span><br><span class="line">    <span class="comment">//method: 要执行的目标对象的方法</span></span><br><span class="line">    <span class="comment">//args: 参数</span></span><br><span class="line">    <span class="comment">//target: 目标对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.printf(target.getClass().getName()+<span class="string">"的"</span>+method.getName()+<span class="string">"被执行了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.添加方法执行后的AfterLog方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.aop.AfterReturningAdvice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterLog</span> <span class="keyword">implements</span> <span class="title">AfterReturningAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//returnValue 返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] objects, Object o1)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行了"</span> + method.getName() + <span class="string">"方法,返回结果为: "</span> + returnValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.编写Spring Aop的配置文件 applicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--注册bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.markup.service.UserServiceImpl"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"log"</span> <span class="attr">class</span>=<span class="string">"com.markup.log.Log"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"afterLog"</span> <span class="attr">class</span>=<span class="string">"com.markup.log.AfterLog"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    方式一: 使用原生Spring API接口--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置AOP: 需要导入AOP的约束--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--切入点: expression:表达式,execute(要执行的位置)--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.markup.service.UserServiceImpl.*(..))"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--执行环绕增加--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"log"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"afterLog"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>6.测试结果 Mytest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mytest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">        <span class="comment">//被代理的是接口,此处用接口类型来做类型转换</span></span><br><span class="line">        UserService userService = (UserService) context.getBean(<span class="string">"userService"</span>);</span><br><span class="line"></span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式二:使用自定义类来实现api接口 [主要是切面定义]</p>
<h2 id="21-AOP实现方式二"><a href="#21-AOP实现方式二" class="headerlink" title="21.AOP实现方式二"></a>21.AOP实现方式二</h2><p>自定义类实现aop接口</p>
<p>1.自定义一个切入点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiyPointCut</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"======方法执行前======"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"======方法执行后======"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.修改之前的配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--注册bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.markup.service.UserServiceImpl"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"log"</span> <span class="attr">class</span>=<span class="string">"com.markup.log.Log"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"afterLog"</span> <span class="attr">class</span>=<span class="string">"com.markup.log.AfterLog"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!--方式二--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"diy"</span> <span class="attr">class</span>=<span class="string">"com.markup.diy.DiyPointCut"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--自定义切面,ref要引用的类--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"diy"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--切入点--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"point"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.markup.service.UserServiceImpl.*(..))"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--通知--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"before"</span> <span class="attr">pointcut-ref</span>=<span class="string">"point"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"after"</span> <span class="attr">pointcut-ref</span>=<span class="string">"point"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.之前的测试文件不变,执行之后即可发现在方法执行前后都有打印输出</p>
<h2 id="22-注解实现AOP"><a href="#22-注解实现AOP" class="headerlink" title="22.注解实现AOP"></a>22.注解实现AOP</h2><p>方式三:使用注解方式实现AOP</p>
<p>1.新建注解使用的切入点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.Signature;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式三: 使用注解方式实现AOP</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//标注这个类是一个切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationPointCut</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* com.markup.service.UserServiceImpl.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"------方法执行前------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"execution(* com.markup.service.UserServiceImpl.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"-----方法执行后-------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在环绕增强中,我们可以给定一个参数,代表我们要获取处理切入的点</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"execution(* com.markup.service.UserServiceImpl.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"环绕前"</span>);</span><br><span class="line"></span><br><span class="line">        Signature signature = pjp.getSignature();</span><br><span class="line">        System.out.println(<span class="string">"signature"</span> + signature);</span><br><span class="line">        <span class="comment">//执行方法</span></span><br><span class="line">        Object proceed = pjp.proceed();</span><br><span class="line">        System.out.printf(<span class="string">"环绕后"</span>);</span><br><span class="line"><span class="comment">//        System.out.println(proceed);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.修改之前的配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--注册bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.markup.service.UserServiceImpl"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"log"</span> <span class="attr">class</span>=<span class="string">"com.markup.log.Log"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"afterLog"</span> <span class="attr">class</span>=<span class="string">"com.markup.log.AfterLog"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--方式三--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"annotationPointCut"</span> <span class="attr">class</span>=<span class="string">"com.markup.diy.AnnotationPointCut"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启注解支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.执行测试结果Mytest</p>
<h2 id="23-回顾Mybatis"><a href="#23-回顾Mybatis" class="headerlink" title="23.回顾Mybatis"></a>23.回顾Mybatis</h2><p>步骤:</p>
<ol>
<li>导入相关jar包<br>junit<br>mybatis<br>mysql<br>spring<br>aop织入<br>mybatis-spring [new]</li>
<li>编写配置文件</li>
<li>测试</li>
</ol>
<p>回忆mybatis</p>
<p>​    0.导包编写pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>com.kuang.<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>spring-study<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-10-mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    1.编写实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    2.编写核心配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--configuration核心配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.kuang.pojo"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatis?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"admin"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"com.kuang.mapper.UserMapper"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    3.编写接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.kuang.pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    4.编写Mapper.xml, 注册接口</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--configuration核心配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.kuang.mapper.UserMapper"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUser"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">        select * from mybatis.user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    5.测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.kuang.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> com.kuang.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mytest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.加载配置文件</span></span><br><span class="line">        String resources = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resources);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.通过通过获取sqlSessionFactoryBuilder获取sqlSessionFactory</span></span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        <span class="comment">//3.创建会话并设置自动提交</span></span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        List&lt;User&gt; users = mapper.selectUser();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="24-整合Mybatis方式一"><a href="#24-整合Mybatis方式一" class="headerlink" title="24.整合Mybatis方式一"></a>24.整合Mybatis方式一</h2><p>Mybatis-Spring测试修改前面回顾Mybatis的代码</p>
<p>1.编写数据源配置</p>
<p>创建spring-dao.xml的文件,配置dataSource 创建对应的数据源之后,可以清理mybatis-config.xml中的数据源配置信息,通过spring来管理数据源</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--DataSource:使用spring的数据源替换mybatis c3p0 dbcp</span></span><br><span class="line"><span class="comment">    我们这里使用spring提供的JDBC</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatis?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"admin"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.sqlSessionFactory</p>
<p>要和Spring一起使用Mybatis,需要在Spring应用上下文中定义至少两样东西:一个SqlSessionFactory和至少一个数据映射器类</p>
<p>在MyBatis-Spring中,可使用SqlSessionFactoryBean来创建SqlSessionFactory,要配置这个工厂bean,只需要把下面代码放在Spring的XML配置文件中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--sqlSessionFactory--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--绑定Mybatis配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis-config.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:com/kuang/mapper/*.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.sqlSessionTemplate</p>
<p>就是我们需要管理的sqlSession</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--SqlSessionTemplate:就是我们要管理的sqlSession--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSession"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionTemplate"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--只能使用构造器注入sqlSessionFactory,因为它没有set方法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>4.需要给接口加实现类</p>
<p>创建一个UserMapperImpl实现类,spring无法直接创建mybatis的实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperImpl</span> <span class="keyword">implements</span> <span class="title">UserMapper</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在原来我们的所有操作都使用sqlSession来执行,现在都使用SqlSessionTemplate</span></span><br><span class="line">    <span class="keyword">private</span> SqlSessionTemplate sqlSession;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSession</span><span class="params">(SqlSessionTemplate sqlSession)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sqlSession = sqlSession;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> mapper.selectUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.将自己写的实现类注入mybatis</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userMapper"</span> <span class="attr">class</span>=<span class="string">"com.kuang.mapper.UserMapperImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSession"</span> <span class="attr">ref</span>=<span class="string">"sqlSession"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>6.测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring-dao.xml"</span>);</span><br><span class="line">    UserMapper userMapper = applicationContext.getBean(<span class="string">"userMapper"</span>, UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (User user : userMapper.selectUser()) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整spring-dao.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--DataSource:使用spring的数据源替换mybatis c3p0 dbcp</span></span><br><span class="line"><span class="comment">    我们这里使用spring提供的JDBC</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatis?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"admin"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--sqlSessionFactory--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--绑定Mybatis配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis-config.xml"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:com/kuang/mapper/*.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--SqlSessionTemplate:就是我们要管理的sqlSession--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSession"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionTemplate"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--只能使用构造器注入sqlSessionFactory,因为它没有set方法--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userMapper"</span> <span class="attr">class</span>=<span class="string">"com.kuang.mapper.UserMapperImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSession"</span> <span class="attr">ref</span>=<span class="string">"sqlSession"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>修改后的mybatis-config.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--configuration核心配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.kuang.pojo"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="25-整合Mybatis方式二"><a href="#25-整合Mybatis方式二" class="headerlink" title="25.整合Mybatis方式二"></a>25.整合Mybatis方式二</h2><p>通过继承SqlSessionDaoSupport直接返回sqlSession</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperImpl2</span> <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserMapper</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSqlSession().getMapper(UserMapper<span class="class">.<span class="keyword">class</span>).<span class="title">selectUser</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置applicationContext.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"spring-dao.xml"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userMapper"</span> <span class="attr">class</span>=<span class="string">"com.kuang.mapper.UserMapperImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSession"</span> <span class="attr">ref</span>=<span class="string">"sqlSession"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userMapper2"</span> <span class="attr">class</span>=<span class="string">"com.kuang.mapper.UserMapperImpl2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    UserMapper userMapper = applicationContext.getBean(<span class="string">"userMapper2"</span>, UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (User user : userMapper.selectUser()) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="26-事务回顾"><a href="#26-事务回顾" class="headerlink" title="26.事务回顾"></a>26.事务回顾</h2><p>回顾事务</p>
<p>把一组业务当成一个业务来做,要么都成功,要么都失败</p>
<p>事务在项目开发中,十分的重要,涉及到数据一致性的问题,不能马虎</p>
<p>确保完整性和一致性</p>
<p> 事务的ACID原则</p>
<p>原子性</p>
<p>一致性</p>
<p>隔离性:多个业务可能操作同一个资源,防止数据损坏</p>
<p>持久性:事务一旦提交,无论系统发生什么问题,结果都不会再被影响,被持久化的写到存储器中</p>
<h2 id="27-Spring声明式事务"><a href="#27-Spring声明式事务" class="headerlink" title="27.Spring声明式事务"></a>27.Spring声明式事务</h2><p>声明式事务:AOP</p>
<p>编程式事务: 需要在代码中,进行事务的管理</p>
<p>在配置文件中声明事务</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    配置声明式事务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    结合AOP实现事务的织入--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置事务通知--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        给哪些方法配置事务--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"add"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"delete"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"update"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"query"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"txPointCut"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.kuang12.mapper.*.*(..))"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"txPointCut"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>自定义mapper中添加错误的方法 delete写成deletes</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addUser"</span> <span class="attr">parameterType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">    insert into mybatis.user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteUser"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">    deletes from mybatis.user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在测试中提交事务的时候,要么一起成功,要么一起失败</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperImpl</span> <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserMapper</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="number">5</span>, <span class="string">"jiji"</span>, <span class="string">"123123"</span>);</span><br><span class="line">        UserMapper mapper = getSqlSession().getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        mapper.addUser(user);</span><br><span class="line">        mapper.deleteUser(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getSqlSession().getMapper(UserMapper<span class="class">.<span class="keyword">class</span>).<span class="title">selectUser</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSqlSession().getMapper(UserMapper<span class="class">.<span class="keyword">class</span>).<span class="title">addUser</span>(<span class="title">user</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSqlSession().getMapper(UserMapper<span class="class">.<span class="keyword">class</span>).<span class="title">deleteUser</span>(<span class="title">id</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="28-回顾和总结"><a href="#28-回顾和总结" class="headerlink" title="28.回顾和总结"></a>28.回顾和总结</h2><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="注解说明"><a href="#注解说明" class="headerlink" title="注解说明"></a>注解说明</h3><p>@Autowired:    自动装配通过类型名字</p>
<p>​    如果Autowired不能唯一自动装配上属性,则需要通过@Qualifier(value=”xxx”)来指定对象</p>
<p>@Nullable:    字段标记了这个注解,说明这个字段可以为null</p>
<p>@Rresource:    自动装配通过名字,类型</p>
<p>@Component:     组件,放在类上,说明这个类被Spring管理了,就是bean</p>
]]></content>
      <categories>
        <category>学海拾贝</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
</search>
